// auto-generated: "lalrpop 0.17.2"
// sha256: bca4bf1336afe7be10b4dc24946e4d4274f8dc978223a5ff7dc496f72d6de25f
use super::tok::{self, Tok};
use super::ast::*;
use std::str::FromStr;
#[allow(unused_extern_crates)]
extern crate lalrpop_util as __lalrpop_util;
#[allow(unused_imports)]
use self::__lalrpop_util::state_machine as __state_machine;

#[cfg_attr(rustfmt, rustfmt_skip)]
mod __parse__Sql {
    #![allow(non_snake_case, non_camel_case_types, unused_mut, unused_variables, unused_imports, unused_parens)]

    use super::super::tok::{self, Tok};
    use super::super::ast::*;
    use std::str::FromStr;
    #[allow(unused_extern_crates)]
    extern crate lalrpop_util as __lalrpop_util;
    #[allow(unused_imports)]
    use self::__lalrpop_util::state_machine as __state_machine;
    use super::__ToTriple;
    pub struct SqlParser {
        _priv: (),
    }

    impl SqlParser {
        pub fn new() -> SqlParser {
            SqlParser {
                _priv: (),
            }
        }

        #[allow(dead_code)]
        pub fn parse<
            'input,
            __TOKEN: __ToTriple<'input, >,
            __TOKENS: IntoIterator<Item=__TOKEN>,
        >(
            &self,
            text: &'input str,
            __tokens0: __TOKENS,
        ) -> Result<Sql, __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
        {
            let __tokens = __tokens0.into_iter();
            let mut __tokens = __tokens.map(|t| __ToTriple::to_triple(t));
            let __lookahead = match __tokens.next() {
                Some(Ok(v)) => Some(v),
                Some(Err(e)) => return Err(e),
                None => None,
            };
            match __state0(text, &mut __tokens, __lookahead, ::std::marker::PhantomData::<(&())>)? {
                (Some(__lookahead), _) => {
                    Err(__lalrpop_util::ParseError::ExtraToken { token: __lookahead })
                }
                (None, __Nonterminal::____Sql((_, __nt, _))) => {
                    Ok(__nt)
                }
                _ => unreachable!(),
            }
        }
    }

    #[allow(dead_code)]
    pub enum __Nonterminal<'input>
     {
        _22_2b_22_3f((usize, ::std::option::Option<Tok<'input>>, usize)),
        _22not_22_3f((usize, ::std::option::Option<Tok<'input>>, usize)),
        _28_22default_22_20_3cValue_3e_29((usize, Value, usize)),
        _28_22default_22_20_3cValue_3e_29_3f((usize, ::std::option::Option<Value>, usize)),
        _28_22not_22_20_22null_22_29((usize, (Tok<'input>, Tok<'input>), usize)),
        _28_22not_22_20_22null_22_29_3f((usize, ::std::option::Option<(Tok<'input>, Tok<'input>)>, usize)),
        _28_22where_22_20_3cWhereClauseList_3e_29((usize, Vec<WhereClause>, usize)),
        _28_22where_22_20_3cWhereClauseList_3e_29_3f((usize, ::std::option::Option<Vec<WhereClause>>, usize)),
        _28_3cColName_3e_20_22_2c_22_29((usize, Name, usize)),
        _28_3cColName_3e_20_22_2c_22_29_2a((usize, ::std::vec::Vec<Name>, usize)),
        _28_3cColName_3e_20_22_2c_22_29_2b((usize, ::std::vec::Vec<Name>, usize)),
        _28_3cColumn_3e_20_22_2c_22_29((usize, Column, usize)),
        _28_3cColumn_3e_20_22_2c_22_29_2a((usize, ::std::vec::Vec<Column>, usize)),
        _28_3cColumn_3e_20_22_2c_22_29_2b((usize, ::std::vec::Vec<Column>, usize)),
        _28_3cField_3e_20_22_2c_22_29((usize, Field, usize)),
        _28_3cField_3e_20_22_2c_22_29_2a((usize, ::std::vec::Vec<Field>, usize)),
        _28_3cField_3e_20_22_2c_22_29_2b((usize, ::std::vec::Vec<Field>, usize)),
        _28_3cSetClause_3e_20_22_2c_22_29((usize, SetClause, usize)),
        _28_3cSetClause_3e_20_22_2c_22_29_2a((usize, ::std::vec::Vec<SetClause>, usize)),
        _28_3cSetClause_3e_20_22_2c_22_29_2b((usize, ::std::vec::Vec<SetClause>, usize)),
        _28_3cTableName_3e_20_22_2c_22_29((usize, Name, usize)),
        _28_3cTableName_3e_20_22_2c_22_29_2a((usize, ::std::vec::Vec<Name>, usize)),
        _28_3cTableName_3e_20_22_2c_22_29_2b((usize, ::std::vec::Vec<Name>, usize)),
        _28_3cTableName_3e_20_22_2e_22_29((usize, Name, usize)),
        _28_3cTableName_3e_20_22_2e_22_29_3f((usize, ::std::option::Option<Name>, usize)),
        _28_3cValue_3e_20_22_2c_22_29((usize, Value, usize)),
        _28_3cValue_3e_20_22_2c_22_29_2a((usize, ::std::vec::Vec<Value>, usize)),
        _28_3cValue_3e_20_22_2c_22_29_2b((usize, ::std::vec::Vec<Value>, usize)),
        _28_3cValueList_3e_20_22_2c_22_29((usize, Vec<Value>, usize)),
        _28_3cValueList_3e_20_22_2c_22_29_2a((usize, ::std::vec::Vec<Vec<Value>>, usize)),
        _28_3cValueList_3e_20_22_2c_22_29_2b((usize, ::std::vec::Vec<Vec<Value>>, usize)),
        _28_3cWhereClause_3e_20_22and_22_29((usize, WhereClause, usize)),
        _28_3cWhereClause_3e_20_22and_22_29_2a((usize, ::std::vec::Vec<WhereClause>, usize)),
        _28_3cWhereClause_3e_20_22and_22_29_2b((usize, ::std::vec::Vec<WhereClause>, usize)),
        AlterStmt((usize, AlterStmt, usize)),
        ColName((usize, Name, usize)),
        Column((usize, Column, usize)),
        ColumnField((usize, Field, usize)),
        CommaList_3cColName_3e((usize, Vec<Name>, usize)),
        CommaList_3cColumn_3e((usize, Vec<Column>, usize)),
        CommaList_3cField_3e((usize, Vec<Field>, usize)),
        CommaList_3cSetClause_3e((usize, Vec<SetClause>, usize)),
        CommaList_3cTableName_3e((usize, Vec<Name>, usize)),
        CommaList_3cValue_3e((usize, Vec<Value>, usize)),
        CommaList_3cValueList_3e((usize, Vec<Vec<Value>>, usize)),
        CopyStmt((usize, CopyStmt, usize)),
        DatabaseName((usize, Name, usize)),
        DatabaseStmt((usize, DatabaseStmt, usize)),
        Expr((usize, Expr, usize)),
        Field((usize, Field, usize)),
        ForeignKeyField((usize, Field, usize)),
        Id((usize, Name, usize)),
        IdString((usize, Name, usize)),
        IndexName((usize, Name, usize)),
        IndexStmt((usize, IndexStmt, usize)),
        Name((usize, Name, usize)),
        Op((usize, Op, usize)),
        PathName((usize, Name, usize)),
        PrimaryKeyField((usize, Field, usize)),
        Selector((usize, Selector, usize)),
        SetClause((usize, SetClause, usize)),
        Sql((usize, Sql, usize)),
        Stmt((usize, Stmt, usize)),
        Stmt_2a((usize, ::std::vec::Vec<Stmt>, usize)),
        Stmt_2b((usize, ::std::vec::Vec<Stmt>, usize)),
        SystemStmt((usize, SystemStmt, usize)),
        TableName((usize, Name, usize)),
        TableStmt((usize, TableStmt, usize)),
        Type((usize, Type, usize)),
        Value((usize, Value, usize)),
        ValueList((usize, Vec<Value>, usize)),
        WhereClause((usize, WhereClause, usize)),
        WhereClauseList((usize, Vec<WhereClause>, usize)),
        ____Sql((usize, Sql, usize)),
    }

    fn __state0<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, __tok @ Tok::Alter, __loc2)) => {
                let __sym0 = (__loc1, (__tok), __loc2);
                __result = __state10(text, __tokens, __sym0, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Copy, __loc2)) => {
                let __sym0 = (__loc1, (__tok), __loc2);
                __result = __state11(text, __tokens, __sym0, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Create, __loc2)) => {
                let __sym0 = (__loc1, (__tok), __loc2);
                __result = __state12(text, __tokens, __sym0, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Delete, __loc2)) => {
                let __sym0 = (__loc1, (__tok), __loc2);
                __result = __state13(text, __tokens, __sym0, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Desc, __loc2)) => {
                let __sym0 = (__loc1, (__tok), __loc2);
                __result = __state14(text, __tokens, __sym0, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Drop, __loc2)) => {
                let __sym0 = (__loc1, (__tok), __loc2);
                __result = __state15(text, __tokens, __sym0, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Insert, __loc2)) => {
                let __sym0 = (__loc1, (__tok), __loc2);
                __result = __state16(text, __tokens, __sym0, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Select, __loc2)) => {
                let __sym0 = (__loc1, (__tok), __loc2);
                __result = __state17(text, __tokens, __sym0, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Show, __loc2)) => {
                let __sym0 = (__loc1, (__tok), __loc2);
                __result = __state18(text, __tokens, __sym0, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Update, __loc2)) => {
                let __sym0 = (__loc1, (__tok), __loc2);
                __result = __state19(text, __tokens, __sym0, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Use, __loc2)) => {
                let __sym0 = (__loc1, (__tok), __loc2);
                __result = __state20(text, __tokens, __sym0, ::std::marker::PhantomData::<(&())>)?;
            }
            None => {
                let __start: usize = ::std::default::Default::default();
                let __end = __lookahead.as_ref().map(|o| o.0.clone()).unwrap_or_else(|| __start.clone());
                let __nt = super::__action259::<>(text, &__start, &__end);
                let __nt = __Nonterminal::Sql((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
            }
            _ => {
                let __expected = vec![
                    r###""alter""###.to_string(),
                    r###""copy""###.to_string(),
                    r###""create""###.to_string(),
                    r###""delete""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""insert""###.to_string(),
                    r###""select""###.to_string(),
                    r###""show""###.to_string(),
                    r###""update""###.to_string(),
                    r###""use""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = Default::default();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::AlterStmt(__sym0) => {
                    __result = __state1(text, __tokens, __lookahead, __sym0, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::CopyStmt(__sym0) => {
                    __result = __state2(text, __tokens, __lookahead, __sym0, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::DatabaseStmt(__sym0) => {
                    __result = __state3(text, __tokens, __lookahead, __sym0, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::IndexStmt(__sym0) => {
                    __result = __state4(text, __tokens, __lookahead, __sym0, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Sql(__sym0) => {
                    __result = __state5(text, __tokens, __lookahead, __sym0, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Stmt(__sym0) => {
                    __result = __state6(text, __tokens, __lookahead, __sym0, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Stmt_2b(__sym0) => {
                    __result = __state7(text, __tokens, __lookahead, __sym0, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::SystemStmt(__sym0) => {
                    __result = __state8(text, __tokens, __lookahead, __sym0, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::TableStmt(__sym0) => {
                    __result = __state9(text, __tokens, __lookahead, __sym0, ::std::marker::PhantomData::<(&())>)?;
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state1<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, AlterStmt, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, __tok @ Tok::Semi, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state21(text, __tokens, __sym0, __sym1, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"";""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state2<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, CopyStmt, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, __tok @ Tok::Semi, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state22(text, __tokens, __sym0, __sym1, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"";""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state3<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, DatabaseStmt, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, __tok @ Tok::Semi, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state23(text, __tokens, __sym0, __sym1, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"";""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state4<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, IndexStmt, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, __tok @ Tok::Semi, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state24(text, __tokens, __sym0, __sym1, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"";""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state5<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Sql, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            None => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action0::<>(text, __sym0);
                let __nt = __Nonterminal::____Sql((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state6<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Stmt, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((_, Tok::Alter, _)) |
            Some((_, Tok::Copy, _)) |
            Some((_, Tok::Create, _)) |
            Some((_, Tok::Delete, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Insert, _)) |
            Some((_, Tok::Select, _)) |
            Some((_, Tok::Show, _)) |
            Some((_, Tok::Update, _)) |
            Some((_, Tok::Use, _)) |
            None => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action164::<>(text, __sym0);
                let __nt = __Nonterminal::Stmt_2b((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""alter""###.to_string(),
                    r###""copy""###.to_string(),
                    r###""create""###.to_string(),
                    r###""delete""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""insert""###.to_string(),
                    r###""select""###.to_string(),
                    r###""show""###.to_string(),
                    r###""update""###.to_string(),
                    r###""use""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state7<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, ::std::vec::Vec<Stmt>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, __tok @ Tok::Alter, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state10(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Copy, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state11(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Create, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state12(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Delete, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state13(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Desc, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state14(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Drop, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state15(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Insert, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state16(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Select, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state17(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Show, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state18(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Update, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state19(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Use, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state20(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            None => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action260::<>(text, __sym0);
                let __nt = __Nonterminal::Sql((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""alter""###.to_string(),
                    r###""copy""###.to_string(),
                    r###""create""###.to_string(),
                    r###""delete""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""insert""###.to_string(),
                    r###""select""###.to_string(),
                    r###""show""###.to_string(),
                    r###""update""###.to_string(),
                    r###""use""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::AlterStmt(__sym1) => {
                    __result = __state1(text, __tokens, __lookahead, __sym1, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::CopyStmt(__sym1) => {
                    __result = __state2(text, __tokens, __lookahead, __sym1, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::DatabaseStmt(__sym1) => {
                    __result = __state3(text, __tokens, __lookahead, __sym1, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::IndexStmt(__sym1) => {
                    __result = __state4(text, __tokens, __lookahead, __sym1, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Stmt(__sym1) => {
                    __result = __state25(text, __tokens, __lookahead, __sym0, __sym1, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                __Nonterminal::SystemStmt(__sym1) => {
                    __result = __state8(text, __tokens, __lookahead, __sym1, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::TableStmt(__sym1) => {
                    __result = __state9(text, __tokens, __lookahead, __sym1, ::std::marker::PhantomData::<(&())>)?;
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state8<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, SystemStmt, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, __tok @ Tok::Semi, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state26(text, __tokens, __sym0, __sym1, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"";""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state9<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, TableStmt, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, __tok @ Tok::Semi, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state27(text, __tokens, __sym0, __sym1, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"";""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state10<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, __tok @ Tok::Table, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state28(text, __tokens, __sym0, __sym1, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""table""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state11<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, Tok::Id(__tok0), __loc2)) => {
                let __sym1 = (__loc1, (__tok0), __loc2);
                __result = __state32(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Abort, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state33(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Action, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state34(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::After, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state35(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Analyze, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state36(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Asc, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state37(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Attach, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state38(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Before, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state39(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Begin, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state40(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::By, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state41(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cascade, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state42(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Conflict, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state43(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cross, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state44(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Deferred, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state45(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Desc, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state46(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Detach, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state47(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Each, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state48(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::End, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state49(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Exclusive, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state50(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Explain, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state51(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Fail, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state52(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::For, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state53(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::If, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state54(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Ignore, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state55(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Immediate, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state56(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Indexed, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state57(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Initially, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state58(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Inner, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state59(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Instead, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state60(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Key, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state61(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Left, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state62(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Natural, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state63(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::No, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state64(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Of, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state65(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Offset, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state66(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Outer, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state67(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Plan, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state68(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Pragma, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state69(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Query, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state70(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Recursive, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state71(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Reindex, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state72(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Release, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state73(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rename, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state74(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Replace, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state75(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Restrict, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state76(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Right, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state77(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rollback, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state78(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Row, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state79(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Savepoint, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state80(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Temp, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state81(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Trigger, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state82(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Vacuum, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state83(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::View, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state84(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Virtual, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state85(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Without, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state86(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Id(__sym1) => {
                    __result = __state29(text, __tokens, __lookahead, __sym1, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Name(__sym1) => {
                    __result = __state30(text, __tokens, __lookahead, __sym1, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::TableName(__sym1) => {
                    __result = __state31(text, __tokens, __lookahead, __sym0, __sym1, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state12<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, __tok @ Tok::Database, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state87(text, __tokens, __sym0, __sym1, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            Some((__loc1, __tok @ Tok::Index, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state88(text, __tokens, __sym0, __sym1, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            Some((__loc1, __tok @ Tok::Table, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state89(text, __tokens, __sym0, __sym1, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""database""###.to_string(),
                    r###""index""###.to_string(),
                    r###""table""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state13<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, __tok @ Tok::From, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state90(text, __tokens, __sym0, __sym1, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""from""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state14<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, Tok::Id(__tok0), __loc2)) => {
                let __sym1 = (__loc1, (__tok0), __loc2);
                __result = __state32(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Abort, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state33(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Action, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state34(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::After, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state35(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Analyze, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state36(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Asc, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state37(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Attach, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state38(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Before, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state39(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Begin, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state40(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::By, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state41(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cascade, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state42(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Conflict, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state43(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cross, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state44(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Deferred, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state45(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Desc, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state46(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Detach, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state47(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Each, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state48(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::End, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state49(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Exclusive, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state50(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Explain, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state51(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Fail, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state52(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::For, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state53(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::If, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state54(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Ignore, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state55(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Immediate, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state56(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Indexed, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state57(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Initially, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state58(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Inner, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state59(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Instead, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state60(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Key, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state61(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Left, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state62(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Natural, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state63(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::No, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state64(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Of, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state65(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Offset, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state66(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Outer, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state67(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Plan, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state68(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Pragma, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state69(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Query, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state70(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Recursive, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state71(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Reindex, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state72(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Release, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state73(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rename, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state74(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Replace, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state75(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Restrict, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state76(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Right, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state77(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rollback, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state78(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Row, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state79(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Savepoint, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state80(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Temp, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state81(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Trigger, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state82(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Vacuum, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state83(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::View, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state84(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Virtual, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state85(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Without, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state86(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Id(__sym1) => {
                    __result = __state29(text, __tokens, __lookahead, __sym1, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Name(__sym1) => {
                    __result = __state30(text, __tokens, __lookahead, __sym1, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::TableName(__sym1) => {
                    __result = __state91(text, __tokens, __lookahead, __sym0, __sym1, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state15<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, __tok @ Tok::Database, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state92(text, __tokens, __sym0, __sym1, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            Some((__loc1, __tok @ Tok::Index, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state93(text, __tokens, __sym0, __sym1, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            Some((__loc1, __tok @ Tok::Table, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state94(text, __tokens, __sym0, __sym1, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""database""###.to_string(),
                    r###""index""###.to_string(),
                    r###""table""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state16<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, __tok @ Tok::Into, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state95(text, __tokens, __sym0, __sym1, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""into""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state17<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, __tok @ Tok::Star, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state103(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, Tok::Id(__tok0), __loc2)) => {
                let __sym1 = (__loc1, (__tok0), __loc2);
                __result = __state32(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Abort, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state33(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Action, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state34(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::After, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state35(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Analyze, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state36(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Asc, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state37(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Attach, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state38(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Before, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state39(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Begin, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state40(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::By, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state41(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cascade, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state42(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Conflict, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state43(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cross, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state44(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Deferred, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state45(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Desc, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state46(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Detach, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state47(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Each, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state48(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::End, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state49(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Exclusive, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state50(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Explain, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state51(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Fail, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state52(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::For, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state53(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::If, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state54(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Ignore, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state55(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Immediate, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state56(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Indexed, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state57(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Initially, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state58(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Inner, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state59(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Instead, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state60(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Key, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state61(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Left, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state62(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Natural, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state63(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::No, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state64(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Of, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state65(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Offset, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state66(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Outer, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state67(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Plan, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state68(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Pragma, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state69(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Query, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state70(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Recursive, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state71(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Reindex, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state72(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Release, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state73(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rename, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state74(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Replace, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state75(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Restrict, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state76(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Right, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state77(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rollback, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state78(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Row, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state79(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Savepoint, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state80(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Temp, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state81(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Trigger, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state82(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Vacuum, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state83(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::View, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state84(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Virtual, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state85(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Without, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state86(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            _ => {
                let __expected = vec![
                    r###""*""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cColumn_3e_20_22_2c_22_29_2b(__sym1) => {
                    __result = __state96(text, __tokens, __lookahead, __sym1, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::ColName(__sym1) => {
                    __result = __state97(text, __tokens, __lookahead, __sym1, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Column(__sym1) => {
                    __result = __state98(text, __tokens, __lookahead, __sym1, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::CommaList_3cColumn_3e(__sym1) => {
                    __result = __state99(text, __tokens, __lookahead, __sym1, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Id(__sym1) => {
                    __result = __state29(text, __tokens, __lookahead, __sym1, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Name(__sym1) => {
                    __result = __state100(text, __tokens, __lookahead, __sym1, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Selector(__sym1) => {
                    __result = __state101(text, __tokens, __lookahead, __sym0, __sym1, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                __Nonterminal::TableName(__sym1) => {
                    __result = __state102(text, __tokens, __lookahead, __sym1, ::std::marker::PhantomData::<(&())>)?;
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state18<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, __tok @ Tok::Databases, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state104(text, __tokens, __sym0, __sym1, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            Some((__loc1, __tok @ Tok::Tables, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state105(text, __tokens, __sym0, __sym1, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""databases""###.to_string(),
                    r###""tables""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state19<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, Tok::Id(__tok0), __loc2)) => {
                let __sym1 = (__loc1, (__tok0), __loc2);
                __result = __state32(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Abort, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state33(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Action, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state34(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::After, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state35(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Analyze, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state36(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Asc, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state37(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Attach, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state38(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Before, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state39(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Begin, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state40(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::By, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state41(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cascade, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state42(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Conflict, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state43(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cross, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state44(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Deferred, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state45(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Desc, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state46(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Detach, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state47(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Each, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state48(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::End, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state49(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Exclusive, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state50(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Explain, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state51(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Fail, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state52(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::For, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state53(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::If, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state54(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Ignore, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state55(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Immediate, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state56(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Indexed, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state57(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Initially, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state58(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Inner, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state59(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Instead, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state60(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Key, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state61(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Left, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state62(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Natural, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state63(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::No, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state64(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Of, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state65(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Offset, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state66(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Outer, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state67(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Plan, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state68(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Pragma, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state69(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Query, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state70(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Recursive, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state71(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Reindex, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state72(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Release, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state73(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rename, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state74(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Replace, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state75(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Restrict, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state76(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Right, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state77(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rollback, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state78(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Row, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state79(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Savepoint, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state80(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Temp, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state81(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Trigger, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state82(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Vacuum, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state83(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::View, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state84(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Virtual, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state85(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Without, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state86(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Id(__sym1) => {
                    __result = __state29(text, __tokens, __lookahead, __sym1, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Name(__sym1) => {
                    __result = __state30(text, __tokens, __lookahead, __sym1, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::TableName(__sym1) => {
                    __result = __state106(text, __tokens, __lookahead, __sym0, __sym1, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state20<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, Tok::Id(__tok0), __loc2)) => {
                let __sym1 = (__loc1, (__tok0), __loc2);
                __result = __state32(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Abort, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state33(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Action, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state34(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::After, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state35(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Analyze, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state36(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Asc, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state37(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Attach, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state38(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Before, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state39(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Begin, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state40(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::By, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state41(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cascade, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state42(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Conflict, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state43(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cross, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state44(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Deferred, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state45(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Desc, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state46(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Detach, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state47(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Each, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state48(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::End, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state49(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Exclusive, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state50(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Explain, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state51(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Fail, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state52(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::For, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state53(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::If, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state54(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Ignore, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state55(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Immediate, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state56(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Indexed, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state57(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Initially, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state58(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Inner, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state59(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Instead, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state60(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Key, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state61(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Left, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state62(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Natural, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state63(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::No, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state64(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Of, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state65(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Offset, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state66(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Outer, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state67(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Plan, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state68(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Pragma, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state69(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Query, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state70(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Recursive, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state71(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Reindex, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state72(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Release, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state73(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rename, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state74(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Replace, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state75(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Restrict, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state76(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Right, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state77(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rollback, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state78(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Row, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state79(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Savepoint, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state80(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Temp, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state81(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Trigger, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state82(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Vacuum, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state83(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::View, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state84(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Virtual, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state85(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Without, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state86(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::DatabaseName(__sym1) => {
                    __result = __state107(text, __tokens, __lookahead, __sym0, __sym1, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                __Nonterminal::Id(__sym1) => {
                    __result = __state29(text, __tokens, __lookahead, __sym1, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Name(__sym1) => {
                    __result = __state108(text, __tokens, __lookahead, __sym1, ::std::marker::PhantomData::<(&())>)?;
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state21<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, AlterStmt, usize),
        __sym1: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::Alter, _)) |
            Some((_, Tok::Copy, _)) |
            Some((_, Tok::Create, _)) |
            Some((_, Tok::Delete, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Insert, _)) |
            Some((_, Tok::Select, _)) |
            Some((_, Tok::Show, _)) |
            Some((_, Tok::Update, _)) |
            Some((_, Tok::Use, _)) |
            None => {
                let __start = __sym0.0.clone();
                let __end = __sym1.2.clone();
                let __nt = super::__action6::<>(text, __sym0, __sym1);
                let __nt = __Nonterminal::Stmt((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""alter""###.to_string(),
                    r###""copy""###.to_string(),
                    r###""create""###.to_string(),
                    r###""delete""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""insert""###.to_string(),
                    r###""select""###.to_string(),
                    r###""show""###.to_string(),
                    r###""update""###.to_string(),
                    r###""use""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym1.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state22<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, CopyStmt, usize),
        __sym1: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::Alter, _)) |
            Some((_, Tok::Copy, _)) |
            Some((_, Tok::Create, _)) |
            Some((_, Tok::Delete, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Insert, _)) |
            Some((_, Tok::Select, _)) |
            Some((_, Tok::Show, _)) |
            Some((_, Tok::Update, _)) |
            Some((_, Tok::Use, _)) |
            None => {
                let __start = __sym0.0.clone();
                let __end = __sym1.2.clone();
                let __nt = super::__action7::<>(text, __sym0, __sym1);
                let __nt = __Nonterminal::Stmt((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""alter""###.to_string(),
                    r###""copy""###.to_string(),
                    r###""create""###.to_string(),
                    r###""delete""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""insert""###.to_string(),
                    r###""select""###.to_string(),
                    r###""show""###.to_string(),
                    r###""update""###.to_string(),
                    r###""use""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym1.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state23<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, DatabaseStmt, usize),
        __sym1: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::Alter, _)) |
            Some((_, Tok::Copy, _)) |
            Some((_, Tok::Create, _)) |
            Some((_, Tok::Delete, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Insert, _)) |
            Some((_, Tok::Select, _)) |
            Some((_, Tok::Show, _)) |
            Some((_, Tok::Update, _)) |
            Some((_, Tok::Use, _)) |
            None => {
                let __start = __sym0.0.clone();
                let __end = __sym1.2.clone();
                let __nt = super::__action3::<>(text, __sym0, __sym1);
                let __nt = __Nonterminal::Stmt((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""alter""###.to_string(),
                    r###""copy""###.to_string(),
                    r###""create""###.to_string(),
                    r###""delete""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""insert""###.to_string(),
                    r###""select""###.to_string(),
                    r###""show""###.to_string(),
                    r###""update""###.to_string(),
                    r###""use""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym1.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state24<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, IndexStmt, usize),
        __sym1: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::Alter, _)) |
            Some((_, Tok::Copy, _)) |
            Some((_, Tok::Create, _)) |
            Some((_, Tok::Delete, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Insert, _)) |
            Some((_, Tok::Select, _)) |
            Some((_, Tok::Show, _)) |
            Some((_, Tok::Update, _)) |
            Some((_, Tok::Use, _)) |
            None => {
                let __start = __sym0.0.clone();
                let __end = __sym1.2.clone();
                let __nt = super::__action5::<>(text, __sym0, __sym1);
                let __nt = __Nonterminal::Stmt((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""alter""###.to_string(),
                    r###""copy""###.to_string(),
                    r###""create""###.to_string(),
                    r###""delete""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""insert""###.to_string(),
                    r###""select""###.to_string(),
                    r###""show""###.to_string(),
                    r###""update""###.to_string(),
                    r###""use""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym1.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state25<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, ::std::vec::Vec<Stmt>, usize),
        __sym1: (usize, Stmt, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((_, Tok::Alter, _)) |
            Some((_, Tok::Copy, _)) |
            Some((_, Tok::Create, _)) |
            Some((_, Tok::Delete, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Insert, _)) |
            Some((_, Tok::Select, _)) |
            Some((_, Tok::Show, _)) |
            Some((_, Tok::Update, _)) |
            Some((_, Tok::Use, _)) |
            None => {
                let __start = __sym0.0.clone();
                let __end = __sym1.2.clone();
                let __nt = super::__action165::<>(text, __sym0, __sym1);
                let __nt = __Nonterminal::Stmt_2b((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""alter""###.to_string(),
                    r###""copy""###.to_string(),
                    r###""create""###.to_string(),
                    r###""delete""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""insert""###.to_string(),
                    r###""select""###.to_string(),
                    r###""show""###.to_string(),
                    r###""update""###.to_string(),
                    r###""use""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym1.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state26<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, SystemStmt, usize),
        __sym1: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::Alter, _)) |
            Some((_, Tok::Copy, _)) |
            Some((_, Tok::Create, _)) |
            Some((_, Tok::Delete, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Insert, _)) |
            Some((_, Tok::Select, _)) |
            Some((_, Tok::Show, _)) |
            Some((_, Tok::Update, _)) |
            Some((_, Tok::Use, _)) |
            None => {
                let __start = __sym0.0.clone();
                let __end = __sym1.2.clone();
                let __nt = super::__action2::<>(text, __sym0, __sym1);
                let __nt = __Nonterminal::Stmt((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""alter""###.to_string(),
                    r###""copy""###.to_string(),
                    r###""create""###.to_string(),
                    r###""delete""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""insert""###.to_string(),
                    r###""select""###.to_string(),
                    r###""show""###.to_string(),
                    r###""update""###.to_string(),
                    r###""use""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym1.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state27<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, TableStmt, usize),
        __sym1: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::Alter, _)) |
            Some((_, Tok::Copy, _)) |
            Some((_, Tok::Create, _)) |
            Some((_, Tok::Delete, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Insert, _)) |
            Some((_, Tok::Select, _)) |
            Some((_, Tok::Show, _)) |
            Some((_, Tok::Update, _)) |
            Some((_, Tok::Use, _)) |
            None => {
                let __start = __sym0.0.clone();
                let __end = __sym1.2.clone();
                let __nt = super::__action4::<>(text, __sym0, __sym1);
                let __nt = __Nonterminal::Stmt((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""alter""###.to_string(),
                    r###""copy""###.to_string(),
                    r###""create""###.to_string(),
                    r###""delete""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""insert""###.to_string(),
                    r###""select""###.to_string(),
                    r###""show""###.to_string(),
                    r###""update""###.to_string(),
                    r###""use""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym1.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state28<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, Tok::Id(__tok0), __loc2)) => {
                let __sym2 = (__loc1, (__tok0), __loc2);
                __result = __state32(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Abort, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state33(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Action, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state34(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::After, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state35(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Analyze, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state36(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Asc, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state37(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Attach, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state38(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Before, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state39(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Begin, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state40(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::By, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state41(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cascade, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state42(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Conflict, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state43(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cross, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state44(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Deferred, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state45(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Desc, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state46(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Detach, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state47(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Each, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state48(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::End, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state49(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Exclusive, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state50(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Explain, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state51(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Fail, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state52(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::For, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state53(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::If, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state54(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Ignore, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state55(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Immediate, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state56(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Indexed, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state57(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Initially, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state58(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Inner, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state59(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Instead, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state60(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Key, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state61(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Left, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state62(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Natural, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state63(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::No, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state64(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Of, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state65(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Offset, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state66(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Outer, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state67(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Plan, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state68(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Pragma, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state69(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Query, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state70(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Recursive, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state71(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Reindex, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state72(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Release, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state73(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rename, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state74(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Replace, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state75(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Restrict, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state76(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Right, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state77(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rollback, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state78(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Row, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state79(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Savepoint, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state80(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Temp, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state81(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Trigger, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state82(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Vacuum, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state83(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::View, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state84(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Virtual, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state85(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Without, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state86(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym1.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Id(__sym2) => {
                    __result = __state29(text, __tokens, __lookahead, __sym2, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Name(__sym2) => {
                    __result = __state30(text, __tokens, __lookahead, __sym2, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::TableName(__sym2) => {
                    __result = __state109(text, __tokens, __lookahead, __sym0, __sym1, __sym2, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state29<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Name, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Dot, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::Add, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::BigInt, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Change, _)) |
            Some((_, Tok::Char, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Date, _)) |
            Some((_, Tok::Decimal, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::FloatType, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::Foreign, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Int, _)) |
            Some((_, Tok::Integerr, _)) |
            Some((_, Tok::Is, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Numeric, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::On, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Primary, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Set, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::Values, _)) |
            Some((_, Tok::Varchar, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Where, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action129::<>(text, __sym0);
                let __nt = __Nonterminal::Name((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"".""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""add""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""and""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""bigint""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""change""###.to_string(),
                    r###""char""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""date""###.to_string(),
                    r###""decimal""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""float""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""from""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""int""###.to_string(),
                    r###""integer""###.to_string(),
                    r###""is""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""numeric""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""on""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""set""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""values""###.to_string(),
                    r###""varchar""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""where""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state30<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Name, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::Add, _)) |
            Some((_, Tok::Change, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Set, _)) |
            Some((_, Tok::Values, _)) |
            Some((_, Tok::Where, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action16::<>(text, __sym0);
                let __nt = __Nonterminal::TableName((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                    r###"",""###.to_string(),
                    r###"";""###.to_string(),
                    r###""add""###.to_string(),
                    r###""change""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""from""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""set""###.to_string(),
                    r###""values""###.to_string(),
                    r###""where""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state31<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Name, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, __tok @ Tok::From, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state110(text, __tokens, __sym0, __sym1, __sym2, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""from""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym1.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state32<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, &'input str, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Dot, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::Add, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::BigInt, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Change, _)) |
            Some((_, Tok::Char, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Date, _)) |
            Some((_, Tok::Decimal, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::FloatType, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::Foreign, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Int, _)) |
            Some((_, Tok::Integerr, _)) |
            Some((_, Tok::Is, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Numeric, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::On, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Primary, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Set, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::Values, _)) |
            Some((_, Tok::Varchar, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Where, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action79::<>(text, __sym0);
                let __nt = __Nonterminal::Id((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"".""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""add""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""and""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""bigint""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""change""###.to_string(),
                    r###""char""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""date""###.to_string(),
                    r###""decimal""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""float""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""from""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""int""###.to_string(),
                    r###""integer""###.to_string(),
                    r###""is""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""numeric""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""on""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""set""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""values""###.to_string(),
                    r###""varchar""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""where""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state33<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Dot, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::Add, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::BigInt, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Change, _)) |
            Some((_, Tok::Char, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Date, _)) |
            Some((_, Tok::Decimal, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::FloatType, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::Foreign, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Int, _)) |
            Some((_, Tok::Integerr, _)) |
            Some((_, Tok::Is, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Numeric, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::On, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Primary, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Set, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::Values, _)) |
            Some((_, Tok::Varchar, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Where, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action81::<>(text, __sym0);
                let __nt = __Nonterminal::Id((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"".""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""add""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""and""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""bigint""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""change""###.to_string(),
                    r###""char""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""date""###.to_string(),
                    r###""decimal""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""float""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""from""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""int""###.to_string(),
                    r###""integer""###.to_string(),
                    r###""is""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""numeric""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""on""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""set""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""values""###.to_string(),
                    r###""varchar""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""where""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state34<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Dot, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::Add, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::BigInt, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Change, _)) |
            Some((_, Tok::Char, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Date, _)) |
            Some((_, Tok::Decimal, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::FloatType, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::Foreign, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Int, _)) |
            Some((_, Tok::Integerr, _)) |
            Some((_, Tok::Is, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Numeric, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::On, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Primary, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Set, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::Values, _)) |
            Some((_, Tok::Varchar, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Where, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action82::<>(text, __sym0);
                let __nt = __Nonterminal::Id((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"".""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""add""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""and""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""bigint""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""change""###.to_string(),
                    r###""char""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""date""###.to_string(),
                    r###""decimal""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""float""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""from""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""int""###.to_string(),
                    r###""integer""###.to_string(),
                    r###""is""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""numeric""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""on""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""set""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""values""###.to_string(),
                    r###""varchar""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""where""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state35<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Dot, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::Add, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::BigInt, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Change, _)) |
            Some((_, Tok::Char, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Date, _)) |
            Some((_, Tok::Decimal, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::FloatType, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::Foreign, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Int, _)) |
            Some((_, Tok::Integerr, _)) |
            Some((_, Tok::Is, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Numeric, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::On, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Primary, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Set, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::Values, _)) |
            Some((_, Tok::Varchar, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Where, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action83::<>(text, __sym0);
                let __nt = __Nonterminal::Id((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"".""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""add""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""and""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""bigint""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""change""###.to_string(),
                    r###""char""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""date""###.to_string(),
                    r###""decimal""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""float""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""from""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""int""###.to_string(),
                    r###""integer""###.to_string(),
                    r###""is""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""numeric""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""on""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""set""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""values""###.to_string(),
                    r###""varchar""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""where""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state36<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Dot, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::Add, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::BigInt, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Change, _)) |
            Some((_, Tok::Char, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Date, _)) |
            Some((_, Tok::Decimal, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::FloatType, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::Foreign, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Int, _)) |
            Some((_, Tok::Integerr, _)) |
            Some((_, Tok::Is, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Numeric, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::On, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Primary, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Set, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::Values, _)) |
            Some((_, Tok::Varchar, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Where, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action84::<>(text, __sym0);
                let __nt = __Nonterminal::Id((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"".""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""add""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""and""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""bigint""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""change""###.to_string(),
                    r###""char""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""date""###.to_string(),
                    r###""decimal""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""float""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""from""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""int""###.to_string(),
                    r###""integer""###.to_string(),
                    r###""is""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""numeric""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""on""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""set""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""values""###.to_string(),
                    r###""varchar""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""where""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state37<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Dot, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::Add, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::BigInt, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Change, _)) |
            Some((_, Tok::Char, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Date, _)) |
            Some((_, Tok::Decimal, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::FloatType, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::Foreign, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Int, _)) |
            Some((_, Tok::Integerr, _)) |
            Some((_, Tok::Is, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Numeric, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::On, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Primary, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Set, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::Values, _)) |
            Some((_, Tok::Varchar, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Where, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action85::<>(text, __sym0);
                let __nt = __Nonterminal::Id((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"".""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""add""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""and""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""bigint""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""change""###.to_string(),
                    r###""char""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""date""###.to_string(),
                    r###""decimal""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""float""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""from""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""int""###.to_string(),
                    r###""integer""###.to_string(),
                    r###""is""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""numeric""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""on""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""set""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""values""###.to_string(),
                    r###""varchar""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""where""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state38<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Dot, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::Add, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::BigInt, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Change, _)) |
            Some((_, Tok::Char, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Date, _)) |
            Some((_, Tok::Decimal, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::FloatType, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::Foreign, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Int, _)) |
            Some((_, Tok::Integerr, _)) |
            Some((_, Tok::Is, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Numeric, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::On, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Primary, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Set, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::Values, _)) |
            Some((_, Tok::Varchar, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Where, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action86::<>(text, __sym0);
                let __nt = __Nonterminal::Id((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"".""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""add""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""and""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""bigint""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""change""###.to_string(),
                    r###""char""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""date""###.to_string(),
                    r###""decimal""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""float""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""from""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""int""###.to_string(),
                    r###""integer""###.to_string(),
                    r###""is""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""numeric""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""on""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""set""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""values""###.to_string(),
                    r###""varchar""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""where""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state39<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Dot, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::Add, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::BigInt, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Change, _)) |
            Some((_, Tok::Char, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Date, _)) |
            Some((_, Tok::Decimal, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::FloatType, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::Foreign, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Int, _)) |
            Some((_, Tok::Integerr, _)) |
            Some((_, Tok::Is, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Numeric, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::On, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Primary, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Set, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::Values, _)) |
            Some((_, Tok::Varchar, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Where, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action87::<>(text, __sym0);
                let __nt = __Nonterminal::Id((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"".""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""add""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""and""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""bigint""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""change""###.to_string(),
                    r###""char""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""date""###.to_string(),
                    r###""decimal""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""float""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""from""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""int""###.to_string(),
                    r###""integer""###.to_string(),
                    r###""is""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""numeric""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""on""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""set""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""values""###.to_string(),
                    r###""varchar""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""where""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state40<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Dot, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::Add, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::BigInt, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Change, _)) |
            Some((_, Tok::Char, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Date, _)) |
            Some((_, Tok::Decimal, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::FloatType, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::Foreign, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Int, _)) |
            Some((_, Tok::Integerr, _)) |
            Some((_, Tok::Is, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Numeric, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::On, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Primary, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Set, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::Values, _)) |
            Some((_, Tok::Varchar, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Where, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action88::<>(text, __sym0);
                let __nt = __Nonterminal::Id((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"".""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""add""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""and""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""bigint""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""change""###.to_string(),
                    r###""char""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""date""###.to_string(),
                    r###""decimal""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""float""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""from""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""int""###.to_string(),
                    r###""integer""###.to_string(),
                    r###""is""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""numeric""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""on""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""set""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""values""###.to_string(),
                    r###""varchar""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""where""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state41<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Dot, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::Add, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::BigInt, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Change, _)) |
            Some((_, Tok::Char, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Date, _)) |
            Some((_, Tok::Decimal, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::FloatType, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::Foreign, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Int, _)) |
            Some((_, Tok::Integerr, _)) |
            Some((_, Tok::Is, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Numeric, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::On, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Primary, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Set, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::Values, _)) |
            Some((_, Tok::Varchar, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Where, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action89::<>(text, __sym0);
                let __nt = __Nonterminal::Id((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"".""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""add""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""and""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""bigint""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""change""###.to_string(),
                    r###""char""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""date""###.to_string(),
                    r###""decimal""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""float""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""from""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""int""###.to_string(),
                    r###""integer""###.to_string(),
                    r###""is""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""numeric""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""on""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""set""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""values""###.to_string(),
                    r###""varchar""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""where""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state42<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Dot, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::Add, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::BigInt, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Change, _)) |
            Some((_, Tok::Char, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Date, _)) |
            Some((_, Tok::Decimal, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::FloatType, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::Foreign, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Int, _)) |
            Some((_, Tok::Integerr, _)) |
            Some((_, Tok::Is, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Numeric, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::On, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Primary, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Set, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::Values, _)) |
            Some((_, Tok::Varchar, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Where, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action90::<>(text, __sym0);
                let __nt = __Nonterminal::Id((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"".""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""add""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""and""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""bigint""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""change""###.to_string(),
                    r###""char""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""date""###.to_string(),
                    r###""decimal""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""float""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""from""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""int""###.to_string(),
                    r###""integer""###.to_string(),
                    r###""is""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""numeric""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""on""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""set""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""values""###.to_string(),
                    r###""varchar""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""where""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state43<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Dot, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::Add, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::BigInt, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Change, _)) |
            Some((_, Tok::Char, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Date, _)) |
            Some((_, Tok::Decimal, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::FloatType, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::Foreign, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Int, _)) |
            Some((_, Tok::Integerr, _)) |
            Some((_, Tok::Is, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Numeric, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::On, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Primary, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Set, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::Values, _)) |
            Some((_, Tok::Varchar, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Where, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action91::<>(text, __sym0);
                let __nt = __Nonterminal::Id((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"".""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""add""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""and""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""bigint""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""change""###.to_string(),
                    r###""char""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""date""###.to_string(),
                    r###""decimal""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""float""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""from""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""int""###.to_string(),
                    r###""integer""###.to_string(),
                    r###""is""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""numeric""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""on""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""set""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""values""###.to_string(),
                    r###""varchar""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""where""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state44<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Dot, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::Add, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::BigInt, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Change, _)) |
            Some((_, Tok::Char, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Date, _)) |
            Some((_, Tok::Decimal, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::FloatType, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::Foreign, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Int, _)) |
            Some((_, Tok::Integerr, _)) |
            Some((_, Tok::Is, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Numeric, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::On, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Primary, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Set, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::Values, _)) |
            Some((_, Tok::Varchar, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Where, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action130::<>(text, __sym0);
                let __nt = __Nonterminal::Name((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"".""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""add""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""and""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""bigint""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""change""###.to_string(),
                    r###""char""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""date""###.to_string(),
                    r###""decimal""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""float""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""from""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""int""###.to_string(),
                    r###""integer""###.to_string(),
                    r###""is""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""numeric""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""on""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""set""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""values""###.to_string(),
                    r###""varchar""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""where""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state45<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Dot, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::Add, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::BigInt, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Change, _)) |
            Some((_, Tok::Char, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Date, _)) |
            Some((_, Tok::Decimal, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::FloatType, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::Foreign, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Int, _)) |
            Some((_, Tok::Integerr, _)) |
            Some((_, Tok::Is, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Numeric, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::On, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Primary, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Set, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::Values, _)) |
            Some((_, Tok::Varchar, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Where, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action92::<>(text, __sym0);
                let __nt = __Nonterminal::Id((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"".""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""add""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""and""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""bigint""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""change""###.to_string(),
                    r###""char""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""date""###.to_string(),
                    r###""decimal""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""float""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""from""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""int""###.to_string(),
                    r###""integer""###.to_string(),
                    r###""is""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""numeric""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""on""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""set""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""values""###.to_string(),
                    r###""varchar""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""where""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state46<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Dot, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::Add, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::BigInt, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Change, _)) |
            Some((_, Tok::Char, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Date, _)) |
            Some((_, Tok::Decimal, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::FloatType, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::Foreign, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Int, _)) |
            Some((_, Tok::Integerr, _)) |
            Some((_, Tok::Is, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Numeric, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::On, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Primary, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Set, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::Values, _)) |
            Some((_, Tok::Varchar, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Where, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action93::<>(text, __sym0);
                let __nt = __Nonterminal::Id((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"".""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""add""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""and""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""bigint""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""change""###.to_string(),
                    r###""char""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""date""###.to_string(),
                    r###""decimal""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""float""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""from""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""int""###.to_string(),
                    r###""integer""###.to_string(),
                    r###""is""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""numeric""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""on""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""set""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""values""###.to_string(),
                    r###""varchar""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""where""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state47<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Dot, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::Add, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::BigInt, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Change, _)) |
            Some((_, Tok::Char, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Date, _)) |
            Some((_, Tok::Decimal, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::FloatType, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::Foreign, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Int, _)) |
            Some((_, Tok::Integerr, _)) |
            Some((_, Tok::Is, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Numeric, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::On, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Primary, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Set, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::Values, _)) |
            Some((_, Tok::Varchar, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Where, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action94::<>(text, __sym0);
                let __nt = __Nonterminal::Id((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"".""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""add""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""and""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""bigint""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""change""###.to_string(),
                    r###""char""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""date""###.to_string(),
                    r###""decimal""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""float""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""from""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""int""###.to_string(),
                    r###""integer""###.to_string(),
                    r###""is""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""numeric""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""on""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""set""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""values""###.to_string(),
                    r###""varchar""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""where""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state48<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Dot, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::Add, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::BigInt, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Change, _)) |
            Some((_, Tok::Char, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Date, _)) |
            Some((_, Tok::Decimal, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::FloatType, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::Foreign, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Int, _)) |
            Some((_, Tok::Integerr, _)) |
            Some((_, Tok::Is, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Numeric, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::On, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Primary, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Set, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::Values, _)) |
            Some((_, Tok::Varchar, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Where, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action95::<>(text, __sym0);
                let __nt = __Nonterminal::Id((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"".""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""add""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""and""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""bigint""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""change""###.to_string(),
                    r###""char""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""date""###.to_string(),
                    r###""decimal""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""float""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""from""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""int""###.to_string(),
                    r###""integer""###.to_string(),
                    r###""is""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""numeric""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""on""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""set""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""values""###.to_string(),
                    r###""varchar""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""where""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state49<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Dot, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::Add, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::BigInt, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Change, _)) |
            Some((_, Tok::Char, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Date, _)) |
            Some((_, Tok::Decimal, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::FloatType, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::Foreign, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Int, _)) |
            Some((_, Tok::Integerr, _)) |
            Some((_, Tok::Is, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Numeric, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::On, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Primary, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Set, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::Values, _)) |
            Some((_, Tok::Varchar, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Where, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action96::<>(text, __sym0);
                let __nt = __Nonterminal::Id((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"".""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""add""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""and""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""bigint""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""change""###.to_string(),
                    r###""char""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""date""###.to_string(),
                    r###""decimal""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""float""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""from""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""int""###.to_string(),
                    r###""integer""###.to_string(),
                    r###""is""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""numeric""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""on""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""set""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""values""###.to_string(),
                    r###""varchar""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""where""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state50<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Dot, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::Add, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::BigInt, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Change, _)) |
            Some((_, Tok::Char, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Date, _)) |
            Some((_, Tok::Decimal, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::FloatType, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::Foreign, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Int, _)) |
            Some((_, Tok::Integerr, _)) |
            Some((_, Tok::Is, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Numeric, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::On, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Primary, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Set, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::Values, _)) |
            Some((_, Tok::Varchar, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Where, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action97::<>(text, __sym0);
                let __nt = __Nonterminal::Id((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"".""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""add""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""and""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""bigint""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""change""###.to_string(),
                    r###""char""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""date""###.to_string(),
                    r###""decimal""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""float""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""from""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""int""###.to_string(),
                    r###""integer""###.to_string(),
                    r###""is""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""numeric""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""on""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""set""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""values""###.to_string(),
                    r###""varchar""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""where""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state51<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Dot, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::Add, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::BigInt, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Change, _)) |
            Some((_, Tok::Char, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Date, _)) |
            Some((_, Tok::Decimal, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::FloatType, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::Foreign, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Int, _)) |
            Some((_, Tok::Integerr, _)) |
            Some((_, Tok::Is, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Numeric, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::On, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Primary, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Set, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::Values, _)) |
            Some((_, Tok::Varchar, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Where, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action98::<>(text, __sym0);
                let __nt = __Nonterminal::Id((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"".""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""add""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""and""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""bigint""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""change""###.to_string(),
                    r###""char""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""date""###.to_string(),
                    r###""decimal""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""float""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""from""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""int""###.to_string(),
                    r###""integer""###.to_string(),
                    r###""is""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""numeric""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""on""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""set""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""values""###.to_string(),
                    r###""varchar""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""where""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state52<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Dot, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::Add, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::BigInt, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Change, _)) |
            Some((_, Tok::Char, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Date, _)) |
            Some((_, Tok::Decimal, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::FloatType, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::Foreign, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Int, _)) |
            Some((_, Tok::Integerr, _)) |
            Some((_, Tok::Is, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Numeric, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::On, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Primary, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Set, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::Values, _)) |
            Some((_, Tok::Varchar, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Where, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action99::<>(text, __sym0);
                let __nt = __Nonterminal::Id((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"".""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""add""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""and""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""bigint""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""change""###.to_string(),
                    r###""char""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""date""###.to_string(),
                    r###""decimal""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""float""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""from""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""int""###.to_string(),
                    r###""integer""###.to_string(),
                    r###""is""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""numeric""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""on""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""set""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""values""###.to_string(),
                    r###""varchar""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""where""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state53<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Dot, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::Add, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::BigInt, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Change, _)) |
            Some((_, Tok::Char, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Date, _)) |
            Some((_, Tok::Decimal, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::FloatType, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::Foreign, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Int, _)) |
            Some((_, Tok::Integerr, _)) |
            Some((_, Tok::Is, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Numeric, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::On, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Primary, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Set, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::Values, _)) |
            Some((_, Tok::Varchar, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Where, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action100::<>(text, __sym0);
                let __nt = __Nonterminal::Id((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"".""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""add""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""and""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""bigint""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""change""###.to_string(),
                    r###""char""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""date""###.to_string(),
                    r###""decimal""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""float""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""from""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""int""###.to_string(),
                    r###""integer""###.to_string(),
                    r###""is""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""numeric""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""on""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""set""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""values""###.to_string(),
                    r###""varchar""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""where""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state54<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Dot, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::Add, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::BigInt, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Change, _)) |
            Some((_, Tok::Char, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Date, _)) |
            Some((_, Tok::Decimal, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::FloatType, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::Foreign, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Int, _)) |
            Some((_, Tok::Integerr, _)) |
            Some((_, Tok::Is, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Numeric, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::On, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Primary, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Set, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::Values, _)) |
            Some((_, Tok::Varchar, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Where, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action127::<>(text, __sym0);
                let __nt = __Nonterminal::Id((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"".""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""add""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""and""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""bigint""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""change""###.to_string(),
                    r###""char""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""date""###.to_string(),
                    r###""decimal""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""float""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""from""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""int""###.to_string(),
                    r###""integer""###.to_string(),
                    r###""is""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""numeric""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""on""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""set""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""values""###.to_string(),
                    r###""varchar""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""where""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state55<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Dot, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::Add, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::BigInt, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Change, _)) |
            Some((_, Tok::Char, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Date, _)) |
            Some((_, Tok::Decimal, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::FloatType, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::Foreign, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Int, _)) |
            Some((_, Tok::Integerr, _)) |
            Some((_, Tok::Is, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Numeric, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::On, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Primary, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Set, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::Values, _)) |
            Some((_, Tok::Varchar, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Where, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action101::<>(text, __sym0);
                let __nt = __Nonterminal::Id((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"".""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""add""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""and""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""bigint""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""change""###.to_string(),
                    r###""char""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""date""###.to_string(),
                    r###""decimal""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""float""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""from""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""int""###.to_string(),
                    r###""integer""###.to_string(),
                    r###""is""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""numeric""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""on""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""set""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""values""###.to_string(),
                    r###""varchar""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""where""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state56<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Dot, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::Add, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::BigInt, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Change, _)) |
            Some((_, Tok::Char, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Date, _)) |
            Some((_, Tok::Decimal, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::FloatType, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::Foreign, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Int, _)) |
            Some((_, Tok::Integerr, _)) |
            Some((_, Tok::Is, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Numeric, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::On, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Primary, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Set, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::Values, _)) |
            Some((_, Tok::Varchar, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Where, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action102::<>(text, __sym0);
                let __nt = __Nonterminal::Id((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"".""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""add""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""and""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""bigint""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""change""###.to_string(),
                    r###""char""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""date""###.to_string(),
                    r###""decimal""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""float""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""from""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""int""###.to_string(),
                    r###""integer""###.to_string(),
                    r###""is""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""numeric""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""on""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""set""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""values""###.to_string(),
                    r###""varchar""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""where""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state57<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Dot, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::Add, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::BigInt, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Change, _)) |
            Some((_, Tok::Char, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Date, _)) |
            Some((_, Tok::Decimal, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::FloatType, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::Foreign, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Int, _)) |
            Some((_, Tok::Integerr, _)) |
            Some((_, Tok::Is, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Numeric, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::On, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Primary, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Set, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::Values, _)) |
            Some((_, Tok::Varchar, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Where, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action80::<>(text, __sym0);
                let __nt = __Nonterminal::Id((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"".""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""add""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""and""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""bigint""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""change""###.to_string(),
                    r###""char""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""date""###.to_string(),
                    r###""decimal""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""float""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""from""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""int""###.to_string(),
                    r###""integer""###.to_string(),
                    r###""is""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""numeric""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""on""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""set""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""values""###.to_string(),
                    r###""varchar""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""where""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state58<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Dot, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::Add, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::BigInt, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Change, _)) |
            Some((_, Tok::Char, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Date, _)) |
            Some((_, Tok::Decimal, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::FloatType, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::Foreign, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Int, _)) |
            Some((_, Tok::Integerr, _)) |
            Some((_, Tok::Is, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Numeric, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::On, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Primary, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Set, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::Values, _)) |
            Some((_, Tok::Varchar, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Where, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action103::<>(text, __sym0);
                let __nt = __Nonterminal::Id((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"".""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""add""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""and""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""bigint""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""change""###.to_string(),
                    r###""char""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""date""###.to_string(),
                    r###""decimal""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""float""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""from""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""int""###.to_string(),
                    r###""integer""###.to_string(),
                    r###""is""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""numeric""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""on""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""set""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""values""###.to_string(),
                    r###""varchar""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""where""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state59<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Dot, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::Add, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::BigInt, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Change, _)) |
            Some((_, Tok::Char, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Date, _)) |
            Some((_, Tok::Decimal, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::FloatType, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::Foreign, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Int, _)) |
            Some((_, Tok::Integerr, _)) |
            Some((_, Tok::Is, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Numeric, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::On, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Primary, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Set, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::Values, _)) |
            Some((_, Tok::Varchar, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Where, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action131::<>(text, __sym0);
                let __nt = __Nonterminal::Name((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"".""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""add""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""and""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""bigint""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""change""###.to_string(),
                    r###""char""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""date""###.to_string(),
                    r###""decimal""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""float""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""from""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""int""###.to_string(),
                    r###""integer""###.to_string(),
                    r###""is""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""numeric""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""on""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""set""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""values""###.to_string(),
                    r###""varchar""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""where""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state60<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Dot, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::Add, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::BigInt, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Change, _)) |
            Some((_, Tok::Char, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Date, _)) |
            Some((_, Tok::Decimal, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::FloatType, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::Foreign, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Int, _)) |
            Some((_, Tok::Integerr, _)) |
            Some((_, Tok::Is, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Numeric, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::On, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Primary, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Set, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::Values, _)) |
            Some((_, Tok::Varchar, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Where, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action104::<>(text, __sym0);
                let __nt = __Nonterminal::Id((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"".""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""add""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""and""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""bigint""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""change""###.to_string(),
                    r###""char""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""date""###.to_string(),
                    r###""decimal""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""float""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""from""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""int""###.to_string(),
                    r###""integer""###.to_string(),
                    r###""is""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""numeric""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""on""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""set""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""values""###.to_string(),
                    r###""varchar""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""where""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state61<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Dot, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::Add, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::BigInt, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Change, _)) |
            Some((_, Tok::Char, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Date, _)) |
            Some((_, Tok::Decimal, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::FloatType, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::Foreign, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Int, _)) |
            Some((_, Tok::Integerr, _)) |
            Some((_, Tok::Is, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Numeric, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::On, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Primary, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Set, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::Values, _)) |
            Some((_, Tok::Varchar, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Where, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action108::<>(text, __sym0);
                let __nt = __Nonterminal::Id((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"".""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""add""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""and""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""bigint""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""change""###.to_string(),
                    r###""char""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""date""###.to_string(),
                    r###""decimal""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""float""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""from""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""int""###.to_string(),
                    r###""integer""###.to_string(),
                    r###""is""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""numeric""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""on""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""set""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""values""###.to_string(),
                    r###""varchar""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""where""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state62<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Dot, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::Add, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::BigInt, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Change, _)) |
            Some((_, Tok::Char, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Date, _)) |
            Some((_, Tok::Decimal, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::FloatType, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::Foreign, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Int, _)) |
            Some((_, Tok::Integerr, _)) |
            Some((_, Tok::Is, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Numeric, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::On, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Primary, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Set, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::Values, _)) |
            Some((_, Tok::Varchar, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Where, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action132::<>(text, __sym0);
                let __nt = __Nonterminal::Name((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"".""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""add""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""and""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""bigint""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""change""###.to_string(),
                    r###""char""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""date""###.to_string(),
                    r###""decimal""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""float""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""from""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""int""###.to_string(),
                    r###""integer""###.to_string(),
                    r###""is""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""numeric""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""on""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""set""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""values""###.to_string(),
                    r###""varchar""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""where""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state63<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Dot, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::Add, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::BigInt, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Change, _)) |
            Some((_, Tok::Char, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Date, _)) |
            Some((_, Tok::Decimal, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::FloatType, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::Foreign, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Int, _)) |
            Some((_, Tok::Integerr, _)) |
            Some((_, Tok::Is, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Numeric, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::On, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Primary, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Set, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::Values, _)) |
            Some((_, Tok::Varchar, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Where, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action133::<>(text, __sym0);
                let __nt = __Nonterminal::Name((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"".""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""add""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""and""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""bigint""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""change""###.to_string(),
                    r###""char""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""date""###.to_string(),
                    r###""decimal""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""float""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""from""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""int""###.to_string(),
                    r###""integer""###.to_string(),
                    r###""is""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""numeric""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""on""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""set""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""values""###.to_string(),
                    r###""varchar""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""where""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state64<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Dot, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::Add, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::BigInt, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Change, _)) |
            Some((_, Tok::Char, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Date, _)) |
            Some((_, Tok::Decimal, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::FloatType, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::Foreign, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Int, _)) |
            Some((_, Tok::Integerr, _)) |
            Some((_, Tok::Is, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Numeric, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::On, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Primary, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Set, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::Values, _)) |
            Some((_, Tok::Varchar, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Where, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action105::<>(text, __sym0);
                let __nt = __Nonterminal::Id((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"".""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""add""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""and""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""bigint""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""change""###.to_string(),
                    r###""char""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""date""###.to_string(),
                    r###""decimal""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""float""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""from""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""int""###.to_string(),
                    r###""integer""###.to_string(),
                    r###""is""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""numeric""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""on""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""set""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""values""###.to_string(),
                    r###""varchar""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""where""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state65<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Dot, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::Add, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::BigInt, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Change, _)) |
            Some((_, Tok::Char, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Date, _)) |
            Some((_, Tok::Decimal, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::FloatType, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::Foreign, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Int, _)) |
            Some((_, Tok::Integerr, _)) |
            Some((_, Tok::Is, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Numeric, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::On, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Primary, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Set, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::Values, _)) |
            Some((_, Tok::Varchar, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Where, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action109::<>(text, __sym0);
                let __nt = __Nonterminal::Id((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"".""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""add""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""and""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""bigint""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""change""###.to_string(),
                    r###""char""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""date""###.to_string(),
                    r###""decimal""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""float""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""from""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""int""###.to_string(),
                    r###""integer""###.to_string(),
                    r###""is""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""numeric""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""on""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""set""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""values""###.to_string(),
                    r###""varchar""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""where""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state66<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Dot, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::Add, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::BigInt, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Change, _)) |
            Some((_, Tok::Char, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Date, _)) |
            Some((_, Tok::Decimal, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::FloatType, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::Foreign, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Int, _)) |
            Some((_, Tok::Integerr, _)) |
            Some((_, Tok::Is, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Numeric, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::On, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Primary, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Set, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::Values, _)) |
            Some((_, Tok::Varchar, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Where, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action110::<>(text, __sym0);
                let __nt = __Nonterminal::Id((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"".""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""add""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""and""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""bigint""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""change""###.to_string(),
                    r###""char""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""date""###.to_string(),
                    r###""decimal""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""float""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""from""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""int""###.to_string(),
                    r###""integer""###.to_string(),
                    r###""is""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""numeric""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""on""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""set""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""values""###.to_string(),
                    r###""varchar""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""where""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state67<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Dot, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::Add, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::BigInt, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Change, _)) |
            Some((_, Tok::Char, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Date, _)) |
            Some((_, Tok::Decimal, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::FloatType, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::Foreign, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Int, _)) |
            Some((_, Tok::Integerr, _)) |
            Some((_, Tok::Is, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Numeric, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::On, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Primary, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Set, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::Values, _)) |
            Some((_, Tok::Varchar, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Where, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action134::<>(text, __sym0);
                let __nt = __Nonterminal::Name((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"".""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""add""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""and""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""bigint""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""change""###.to_string(),
                    r###""char""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""date""###.to_string(),
                    r###""decimal""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""float""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""from""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""int""###.to_string(),
                    r###""integer""###.to_string(),
                    r###""is""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""numeric""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""on""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""set""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""values""###.to_string(),
                    r###""varchar""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""where""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state68<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Dot, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::Add, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::BigInt, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Change, _)) |
            Some((_, Tok::Char, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Date, _)) |
            Some((_, Tok::Decimal, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::FloatType, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::Foreign, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Int, _)) |
            Some((_, Tok::Integerr, _)) |
            Some((_, Tok::Is, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Numeric, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::On, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Primary, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Set, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::Values, _)) |
            Some((_, Tok::Varchar, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Where, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action106::<>(text, __sym0);
                let __nt = __Nonterminal::Id((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"".""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""add""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""and""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""bigint""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""change""###.to_string(),
                    r###""char""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""date""###.to_string(),
                    r###""decimal""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""float""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""from""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""int""###.to_string(),
                    r###""integer""###.to_string(),
                    r###""is""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""numeric""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""on""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""set""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""values""###.to_string(),
                    r###""varchar""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""where""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state69<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Dot, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::Add, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::BigInt, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Change, _)) |
            Some((_, Tok::Char, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Date, _)) |
            Some((_, Tok::Decimal, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::FloatType, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::Foreign, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Int, _)) |
            Some((_, Tok::Integerr, _)) |
            Some((_, Tok::Is, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Numeric, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::On, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Primary, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Set, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::Values, _)) |
            Some((_, Tok::Varchar, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Where, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action111::<>(text, __sym0);
                let __nt = __Nonterminal::Id((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"".""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""add""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""and""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""bigint""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""change""###.to_string(),
                    r###""char""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""date""###.to_string(),
                    r###""decimal""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""float""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""from""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""int""###.to_string(),
                    r###""integer""###.to_string(),
                    r###""is""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""numeric""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""on""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""set""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""values""###.to_string(),
                    r###""varchar""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""where""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state70<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Dot, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::Add, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::BigInt, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Change, _)) |
            Some((_, Tok::Char, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Date, _)) |
            Some((_, Tok::Decimal, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::FloatType, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::Foreign, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Int, _)) |
            Some((_, Tok::Integerr, _)) |
            Some((_, Tok::Is, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Numeric, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::On, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Primary, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Set, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::Values, _)) |
            Some((_, Tok::Varchar, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Where, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action107::<>(text, __sym0);
                let __nt = __Nonterminal::Id((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"".""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""add""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""and""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""bigint""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""change""###.to_string(),
                    r###""char""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""date""###.to_string(),
                    r###""decimal""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""float""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""from""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""int""###.to_string(),
                    r###""integer""###.to_string(),
                    r###""is""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""numeric""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""on""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""set""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""values""###.to_string(),
                    r###""varchar""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""where""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state71<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Dot, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::Add, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::BigInt, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Change, _)) |
            Some((_, Tok::Char, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Date, _)) |
            Some((_, Tok::Decimal, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::FloatType, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::Foreign, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Int, _)) |
            Some((_, Tok::Integerr, _)) |
            Some((_, Tok::Is, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Numeric, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::On, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Primary, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Set, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::Values, _)) |
            Some((_, Tok::Varchar, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Where, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action112::<>(text, __sym0);
                let __nt = __Nonterminal::Id((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"".""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""add""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""and""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""bigint""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""change""###.to_string(),
                    r###""char""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""date""###.to_string(),
                    r###""decimal""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""float""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""from""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""int""###.to_string(),
                    r###""integer""###.to_string(),
                    r###""is""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""numeric""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""on""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""set""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""values""###.to_string(),
                    r###""varchar""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""where""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state72<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Dot, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::Add, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::BigInt, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Change, _)) |
            Some((_, Tok::Char, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Date, _)) |
            Some((_, Tok::Decimal, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::FloatType, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::Foreign, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Int, _)) |
            Some((_, Tok::Integerr, _)) |
            Some((_, Tok::Is, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Numeric, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::On, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Primary, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Set, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::Values, _)) |
            Some((_, Tok::Varchar, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Where, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action125::<>(text, __sym0);
                let __nt = __Nonterminal::Id((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"".""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""add""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""and""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""bigint""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""change""###.to_string(),
                    r###""char""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""date""###.to_string(),
                    r###""decimal""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""float""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""from""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""int""###.to_string(),
                    r###""integer""###.to_string(),
                    r###""is""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""numeric""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""on""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""set""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""values""###.to_string(),
                    r###""varchar""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""where""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state73<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Dot, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::Add, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::BigInt, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Change, _)) |
            Some((_, Tok::Char, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Date, _)) |
            Some((_, Tok::Decimal, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::FloatType, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::Foreign, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Int, _)) |
            Some((_, Tok::Integerr, _)) |
            Some((_, Tok::Is, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Numeric, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::On, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Primary, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Set, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::Values, _)) |
            Some((_, Tok::Varchar, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Where, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action113::<>(text, __sym0);
                let __nt = __Nonterminal::Id((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"".""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""add""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""and""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""bigint""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""change""###.to_string(),
                    r###""char""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""date""###.to_string(),
                    r###""decimal""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""float""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""from""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""int""###.to_string(),
                    r###""integer""###.to_string(),
                    r###""is""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""numeric""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""on""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""set""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""values""###.to_string(),
                    r###""varchar""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""where""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state74<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Dot, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::Add, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::BigInt, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Change, _)) |
            Some((_, Tok::Char, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Date, _)) |
            Some((_, Tok::Decimal, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::FloatType, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::Foreign, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Int, _)) |
            Some((_, Tok::Integerr, _)) |
            Some((_, Tok::Is, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Numeric, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::On, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Primary, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Set, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::Values, _)) |
            Some((_, Tok::Varchar, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Where, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action126::<>(text, __sym0);
                let __nt = __Nonterminal::Id((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"".""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""add""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""and""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""bigint""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""change""###.to_string(),
                    r###""char""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""date""###.to_string(),
                    r###""decimal""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""float""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""from""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""int""###.to_string(),
                    r###""integer""###.to_string(),
                    r###""is""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""numeric""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""on""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""set""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""values""###.to_string(),
                    r###""varchar""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""where""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state75<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Dot, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::Add, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::BigInt, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Change, _)) |
            Some((_, Tok::Char, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Date, _)) |
            Some((_, Tok::Decimal, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::FloatType, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::Foreign, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Int, _)) |
            Some((_, Tok::Integerr, _)) |
            Some((_, Tok::Is, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Numeric, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::On, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Primary, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Set, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::Values, _)) |
            Some((_, Tok::Varchar, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Where, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action114::<>(text, __sym0);
                let __nt = __Nonterminal::Id((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"".""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""add""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""and""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""bigint""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""change""###.to_string(),
                    r###""char""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""date""###.to_string(),
                    r###""decimal""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""float""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""from""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""int""###.to_string(),
                    r###""integer""###.to_string(),
                    r###""is""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""numeric""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""on""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""set""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""values""###.to_string(),
                    r###""varchar""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""where""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state76<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Dot, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::Add, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::BigInt, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Change, _)) |
            Some((_, Tok::Char, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Date, _)) |
            Some((_, Tok::Decimal, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::FloatType, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::Foreign, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Int, _)) |
            Some((_, Tok::Integerr, _)) |
            Some((_, Tok::Is, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Numeric, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::On, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Primary, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Set, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::Values, _)) |
            Some((_, Tok::Varchar, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Where, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action115::<>(text, __sym0);
                let __nt = __Nonterminal::Id((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"".""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""add""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""and""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""bigint""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""change""###.to_string(),
                    r###""char""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""date""###.to_string(),
                    r###""decimal""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""float""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""from""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""int""###.to_string(),
                    r###""integer""###.to_string(),
                    r###""is""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""numeric""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""on""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""set""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""values""###.to_string(),
                    r###""varchar""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""where""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state77<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Dot, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::Add, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::BigInt, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Change, _)) |
            Some((_, Tok::Char, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Date, _)) |
            Some((_, Tok::Decimal, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::FloatType, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::Foreign, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Int, _)) |
            Some((_, Tok::Integerr, _)) |
            Some((_, Tok::Is, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Numeric, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::On, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Primary, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Set, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::Values, _)) |
            Some((_, Tok::Varchar, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Where, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action135::<>(text, __sym0);
                let __nt = __Nonterminal::Name((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"".""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""add""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""and""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""bigint""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""change""###.to_string(),
                    r###""char""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""date""###.to_string(),
                    r###""decimal""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""float""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""from""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""int""###.to_string(),
                    r###""integer""###.to_string(),
                    r###""is""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""numeric""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""on""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""set""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""values""###.to_string(),
                    r###""varchar""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""where""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state78<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Dot, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::Add, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::BigInt, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Change, _)) |
            Some((_, Tok::Char, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Date, _)) |
            Some((_, Tok::Decimal, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::FloatType, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::Foreign, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Int, _)) |
            Some((_, Tok::Integerr, _)) |
            Some((_, Tok::Is, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Numeric, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::On, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Primary, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Set, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::Values, _)) |
            Some((_, Tok::Varchar, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Where, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action117::<>(text, __sym0);
                let __nt = __Nonterminal::Id((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"".""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""add""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""and""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""bigint""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""change""###.to_string(),
                    r###""char""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""date""###.to_string(),
                    r###""decimal""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""float""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""from""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""int""###.to_string(),
                    r###""integer""###.to_string(),
                    r###""is""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""numeric""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""on""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""set""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""values""###.to_string(),
                    r###""varchar""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""where""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state79<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Dot, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::Add, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::BigInt, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Change, _)) |
            Some((_, Tok::Char, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Date, _)) |
            Some((_, Tok::Decimal, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::FloatType, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::Foreign, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Int, _)) |
            Some((_, Tok::Integerr, _)) |
            Some((_, Tok::Is, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Numeric, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::On, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Primary, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Set, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::Values, _)) |
            Some((_, Tok::Varchar, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Where, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action116::<>(text, __sym0);
                let __nt = __Nonterminal::Id((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"".""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""add""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""and""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""bigint""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""change""###.to_string(),
                    r###""char""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""date""###.to_string(),
                    r###""decimal""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""float""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""from""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""int""###.to_string(),
                    r###""integer""###.to_string(),
                    r###""is""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""numeric""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""on""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""set""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""values""###.to_string(),
                    r###""varchar""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""where""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state80<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Dot, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::Add, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::BigInt, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Change, _)) |
            Some((_, Tok::Char, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Date, _)) |
            Some((_, Tok::Decimal, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::FloatType, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::Foreign, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Int, _)) |
            Some((_, Tok::Integerr, _)) |
            Some((_, Tok::Is, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Numeric, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::On, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Primary, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Set, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::Values, _)) |
            Some((_, Tok::Varchar, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Where, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action118::<>(text, __sym0);
                let __nt = __Nonterminal::Id((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"".""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""add""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""and""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""bigint""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""change""###.to_string(),
                    r###""char""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""date""###.to_string(),
                    r###""decimal""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""float""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""from""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""int""###.to_string(),
                    r###""integer""###.to_string(),
                    r###""is""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""numeric""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""on""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""set""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""values""###.to_string(),
                    r###""varchar""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""where""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state81<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Dot, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::Add, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::BigInt, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Change, _)) |
            Some((_, Tok::Char, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Date, _)) |
            Some((_, Tok::Decimal, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::FloatType, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::Foreign, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Int, _)) |
            Some((_, Tok::Integerr, _)) |
            Some((_, Tok::Is, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Numeric, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::On, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Primary, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Set, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::Values, _)) |
            Some((_, Tok::Varchar, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Where, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action119::<>(text, __sym0);
                let __nt = __Nonterminal::Id((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"".""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""add""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""and""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""bigint""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""change""###.to_string(),
                    r###""char""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""date""###.to_string(),
                    r###""decimal""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""float""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""from""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""int""###.to_string(),
                    r###""integer""###.to_string(),
                    r###""is""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""numeric""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""on""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""set""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""values""###.to_string(),
                    r###""varchar""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""where""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state82<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Dot, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::Add, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::BigInt, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Change, _)) |
            Some((_, Tok::Char, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Date, _)) |
            Some((_, Tok::Decimal, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::FloatType, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::Foreign, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Int, _)) |
            Some((_, Tok::Integerr, _)) |
            Some((_, Tok::Is, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Numeric, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::On, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Primary, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Set, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::Values, _)) |
            Some((_, Tok::Varchar, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Where, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action120::<>(text, __sym0);
                let __nt = __Nonterminal::Id((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"".""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""add""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""and""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""bigint""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""change""###.to_string(),
                    r###""char""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""date""###.to_string(),
                    r###""decimal""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""float""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""from""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""int""###.to_string(),
                    r###""integer""###.to_string(),
                    r###""is""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""numeric""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""on""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""set""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""values""###.to_string(),
                    r###""varchar""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""where""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state83<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Dot, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::Add, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::BigInt, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Change, _)) |
            Some((_, Tok::Char, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Date, _)) |
            Some((_, Tok::Decimal, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::FloatType, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::Foreign, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Int, _)) |
            Some((_, Tok::Integerr, _)) |
            Some((_, Tok::Is, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Numeric, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::On, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Primary, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Set, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::Values, _)) |
            Some((_, Tok::Varchar, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Where, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action121::<>(text, __sym0);
                let __nt = __Nonterminal::Id((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"".""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""add""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""and""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""bigint""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""change""###.to_string(),
                    r###""char""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""date""###.to_string(),
                    r###""decimal""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""float""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""from""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""int""###.to_string(),
                    r###""integer""###.to_string(),
                    r###""is""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""numeric""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""on""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""set""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""values""###.to_string(),
                    r###""varchar""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""where""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state84<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Dot, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::Add, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::BigInt, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Change, _)) |
            Some((_, Tok::Char, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Date, _)) |
            Some((_, Tok::Decimal, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::FloatType, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::Foreign, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Int, _)) |
            Some((_, Tok::Integerr, _)) |
            Some((_, Tok::Is, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Numeric, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::On, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Primary, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Set, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::Values, _)) |
            Some((_, Tok::Varchar, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Where, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action122::<>(text, __sym0);
                let __nt = __Nonterminal::Id((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"".""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""add""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""and""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""bigint""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""change""###.to_string(),
                    r###""char""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""date""###.to_string(),
                    r###""decimal""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""float""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""from""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""int""###.to_string(),
                    r###""integer""###.to_string(),
                    r###""is""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""numeric""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""on""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""set""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""values""###.to_string(),
                    r###""varchar""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""where""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state85<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Dot, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::Add, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::BigInt, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Change, _)) |
            Some((_, Tok::Char, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Date, _)) |
            Some((_, Tok::Decimal, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::FloatType, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::Foreign, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Int, _)) |
            Some((_, Tok::Integerr, _)) |
            Some((_, Tok::Is, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Numeric, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::On, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Primary, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Set, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::Values, _)) |
            Some((_, Tok::Varchar, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Where, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action123::<>(text, __sym0);
                let __nt = __Nonterminal::Id((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"".""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""add""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""and""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""bigint""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""change""###.to_string(),
                    r###""char""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""date""###.to_string(),
                    r###""decimal""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""float""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""from""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""int""###.to_string(),
                    r###""integer""###.to_string(),
                    r###""is""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""numeric""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""on""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""set""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""values""###.to_string(),
                    r###""varchar""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""where""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state86<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Dot, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::Add, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::BigInt, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Change, _)) |
            Some((_, Tok::Char, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Date, _)) |
            Some((_, Tok::Decimal, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Drop, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::FloatType, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::Foreign, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Int, _)) |
            Some((_, Tok::Integerr, _)) |
            Some((_, Tok::Is, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Numeric, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::On, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Primary, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Set, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::Values, _)) |
            Some((_, Tok::Varchar, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Where, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action124::<>(text, __sym0);
                let __nt = __Nonterminal::Id((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"".""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""add""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""and""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""bigint""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""change""###.to_string(),
                    r###""char""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""date""###.to_string(),
                    r###""decimal""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""float""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""from""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""int""###.to_string(),
                    r###""integer""###.to_string(),
                    r###""is""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""numeric""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""on""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""set""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""values""###.to_string(),
                    r###""varchar""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""where""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state87<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, Tok::Id(__tok0), __loc2)) => {
                let __sym2 = (__loc1, (__tok0), __loc2);
                __result = __state32(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Abort, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state33(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Action, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state34(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::After, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state35(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Analyze, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state36(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Asc, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state37(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Attach, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state38(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Before, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state39(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Begin, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state40(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::By, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state41(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cascade, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state42(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Conflict, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state43(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cross, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state44(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Deferred, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state45(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Desc, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state46(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Detach, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state47(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Each, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state48(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::End, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state49(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Exclusive, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state50(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Explain, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state51(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Fail, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state52(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::For, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state53(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::If, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state54(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Ignore, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state55(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Immediate, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state56(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Indexed, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state57(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Initially, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state58(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Inner, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state59(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Instead, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state60(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Key, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state61(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Left, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state62(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Natural, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state63(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::No, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state64(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Of, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state65(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Offset, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state66(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Outer, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state67(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Plan, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state68(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Pragma, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state69(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Query, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state70(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Recursive, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state71(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Reindex, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state72(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Release, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state73(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rename, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state74(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Replace, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state75(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Restrict, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state76(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Right, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state77(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rollback, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state78(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Row, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state79(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Savepoint, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state80(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Temp, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state81(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Trigger, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state82(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Vacuum, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state83(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::View, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state84(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Virtual, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state85(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Without, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state86(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym1.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::DatabaseName(__sym2) => {
                    __result = __state111(text, __tokens, __lookahead, __sym0, __sym1, __sym2, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                __Nonterminal::Id(__sym2) => {
                    __result = __state29(text, __tokens, __lookahead, __sym2, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Name(__sym2) => {
                    __result = __state108(text, __tokens, __lookahead, __sym2, ::std::marker::PhantomData::<(&())>)?;
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state88<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, Tok::Id(__tok0), __loc2)) => {
                let __sym2 = (__loc1, (__tok0), __loc2);
                __result = __state32(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Abort, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state33(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Action, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state34(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::After, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state35(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Analyze, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state36(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Asc, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state37(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Attach, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state38(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Before, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state39(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Begin, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state40(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::By, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state41(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cascade, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state42(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Conflict, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state43(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cross, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state44(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Deferred, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state45(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Desc, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state46(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Detach, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state47(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Each, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state48(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::End, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state49(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Exclusive, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state50(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Explain, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state51(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Fail, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state52(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::For, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state53(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::If, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state54(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Ignore, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state55(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Immediate, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state56(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Indexed, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state57(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Initially, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state58(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Inner, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state59(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Instead, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state60(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Key, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state61(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Left, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state62(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Natural, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state63(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::No, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state64(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Of, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state65(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Offset, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state66(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Outer, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state67(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Plan, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state68(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Pragma, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state69(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Query, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state70(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Recursive, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state71(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Reindex, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state72(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Release, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state73(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rename, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state74(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Replace, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state75(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Restrict, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state76(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Right, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state77(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rollback, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state78(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Row, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state79(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Savepoint, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state80(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Temp, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state81(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Trigger, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state82(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Vacuum, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state83(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::View, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state84(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Virtual, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state85(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Without, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state86(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym1.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Id(__sym2) => {
                    __result = __state29(text, __tokens, __lookahead, __sym2, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::IndexName(__sym2) => {
                    __result = __state112(text, __tokens, __lookahead, __sym0, __sym1, __sym2, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                __Nonterminal::Name(__sym2) => {
                    __result = __state113(text, __tokens, __lookahead, __sym2, ::std::marker::PhantomData::<(&())>)?;
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state89<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, Tok::Id(__tok0), __loc2)) => {
                let __sym2 = (__loc1, (__tok0), __loc2);
                __result = __state32(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Abort, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state33(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Action, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state34(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::After, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state35(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Analyze, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state36(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Asc, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state37(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Attach, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state38(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Before, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state39(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Begin, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state40(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::By, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state41(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cascade, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state42(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Conflict, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state43(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cross, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state44(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Deferred, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state45(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Desc, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state46(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Detach, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state47(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Each, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state48(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::End, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state49(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Exclusive, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state50(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Explain, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state51(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Fail, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state52(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::For, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state53(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::If, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state54(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Ignore, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state55(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Immediate, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state56(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Indexed, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state57(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Initially, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state58(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Inner, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state59(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Instead, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state60(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Key, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state61(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Left, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state62(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Natural, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state63(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::No, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state64(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Of, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state65(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Offset, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state66(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Outer, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state67(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Plan, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state68(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Pragma, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state69(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Query, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state70(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Recursive, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state71(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Reindex, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state72(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Release, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state73(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rename, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state74(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Replace, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state75(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Restrict, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state76(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Right, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state77(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rollback, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state78(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Row, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state79(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Savepoint, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state80(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Temp, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state81(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Trigger, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state82(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Vacuum, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state83(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::View, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state84(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Virtual, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state85(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Without, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state86(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym1.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Id(__sym2) => {
                    __result = __state29(text, __tokens, __lookahead, __sym2, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Name(__sym2) => {
                    __result = __state30(text, __tokens, __lookahead, __sym2, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::TableName(__sym2) => {
                    __result = __state114(text, __tokens, __lookahead, __sym0, __sym1, __sym2, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state90<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, Tok::Id(__tok0), __loc2)) => {
                let __sym2 = (__loc1, (__tok0), __loc2);
                __result = __state32(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Abort, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state33(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Action, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state34(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::After, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state35(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Analyze, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state36(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Asc, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state37(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Attach, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state38(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Before, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state39(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Begin, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state40(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::By, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state41(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cascade, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state42(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Conflict, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state43(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cross, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state44(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Deferred, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state45(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Desc, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state46(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Detach, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state47(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Each, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state48(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::End, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state49(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Exclusive, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state50(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Explain, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state51(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Fail, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state52(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::For, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state53(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::If, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state54(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Ignore, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state55(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Immediate, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state56(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Indexed, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state57(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Initially, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state58(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Inner, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state59(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Instead, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state60(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Key, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state61(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Left, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state62(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Natural, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state63(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::No, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state64(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Of, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state65(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Offset, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state66(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Outer, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state67(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Plan, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state68(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Pragma, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state69(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Query, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state70(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Recursive, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state71(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Reindex, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state72(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Release, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state73(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rename, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state74(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Replace, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state75(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Restrict, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state76(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Right, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state77(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rollback, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state78(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Row, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state79(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Savepoint, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state80(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Temp, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state81(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Trigger, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state82(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Vacuum, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state83(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::View, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state84(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Virtual, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state85(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Without, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state86(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym1.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Id(__sym2) => {
                    __result = __state29(text, __tokens, __lookahead, __sym2, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Name(__sym2) => {
                    __result = __state30(text, __tokens, __lookahead, __sym2, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::TableName(__sym2) => {
                    __result = __state115(text, __tokens, __lookahead, __sym0, __sym1, __sym2, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state91<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Name, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((_, Tok::Semi, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym1.2.clone();
                let __nt = super::__action19::<>(text, __sym0, __sym1);
                let __nt = __Nonterminal::TableStmt((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"";""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym1.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state92<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, Tok::Id(__tok0), __loc2)) => {
                let __sym2 = (__loc1, (__tok0), __loc2);
                __result = __state32(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Abort, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state33(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Action, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state34(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::After, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state35(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Analyze, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state36(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Asc, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state37(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Attach, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state38(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Before, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state39(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Begin, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state40(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::By, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state41(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cascade, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state42(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Conflict, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state43(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cross, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state44(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Deferred, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state45(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Desc, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state46(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Detach, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state47(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Each, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state48(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::End, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state49(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Exclusive, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state50(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Explain, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state51(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Fail, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state52(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::For, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state53(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::If, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state54(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Ignore, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state55(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Immediate, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state56(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Indexed, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state57(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Initially, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state58(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Inner, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state59(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Instead, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state60(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Key, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state61(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Left, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state62(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Natural, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state63(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::No, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state64(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Of, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state65(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Offset, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state66(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Outer, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state67(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Plan, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state68(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Pragma, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state69(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Query, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state70(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Recursive, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state71(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Reindex, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state72(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Release, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state73(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rename, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state74(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Replace, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state75(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Restrict, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state76(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Right, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state77(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rollback, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state78(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Row, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state79(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Savepoint, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state80(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Temp, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state81(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Trigger, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state82(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Vacuum, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state83(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::View, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state84(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Virtual, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state85(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Without, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state86(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym1.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::DatabaseName(__sym2) => {
                    __result = __state116(text, __tokens, __lookahead, __sym0, __sym1, __sym2, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                __Nonterminal::Id(__sym2) => {
                    __result = __state29(text, __tokens, __lookahead, __sym2, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Name(__sym2) => {
                    __result = __state108(text, __tokens, __lookahead, __sym2, ::std::marker::PhantomData::<(&())>)?;
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state93<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, Tok::Id(__tok0), __loc2)) => {
                let __sym2 = (__loc1, (__tok0), __loc2);
                __result = __state32(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Abort, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state33(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Action, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state34(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::After, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state35(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Analyze, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state36(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Asc, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state37(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Attach, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state38(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Before, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state39(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Begin, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state40(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::By, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state41(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cascade, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state42(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Conflict, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state43(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cross, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state44(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Deferred, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state45(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Desc, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state46(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Detach, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state47(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Each, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state48(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::End, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state49(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Exclusive, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state50(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Explain, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state51(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Fail, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state52(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::For, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state53(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::If, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state54(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Ignore, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state55(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Immediate, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state56(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Indexed, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state57(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Initially, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state58(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Inner, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state59(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Instead, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state60(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Key, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state61(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Left, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state62(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Natural, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state63(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::No, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state64(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Of, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state65(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Offset, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state66(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Outer, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state67(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Plan, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state68(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Pragma, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state69(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Query, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state70(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Recursive, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state71(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Reindex, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state72(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Release, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state73(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rename, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state74(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Replace, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state75(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Restrict, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state76(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Right, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state77(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rollback, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state78(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Row, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state79(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Savepoint, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state80(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Temp, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state81(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Trigger, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state82(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Vacuum, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state83(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::View, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state84(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Virtual, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state85(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Without, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state86(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym1.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Id(__sym2) => {
                    __result = __state29(text, __tokens, __lookahead, __sym2, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::IndexName(__sym2) => {
                    __result = __state117(text, __tokens, __lookahead, __sym0, __sym1, __sym2, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                __Nonterminal::Name(__sym2) => {
                    __result = __state113(text, __tokens, __lookahead, __sym2, ::std::marker::PhantomData::<(&())>)?;
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state94<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, Tok::Id(__tok0), __loc2)) => {
                let __sym2 = (__loc1, (__tok0), __loc2);
                __result = __state32(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Abort, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state33(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Action, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state34(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::After, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state35(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Analyze, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state36(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Asc, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state37(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Attach, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state38(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Before, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state39(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Begin, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state40(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::By, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state41(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cascade, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state42(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Conflict, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state43(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cross, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state44(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Deferred, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state45(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Desc, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state46(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Detach, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state47(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Each, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state48(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::End, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state49(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Exclusive, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state50(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Explain, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state51(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Fail, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state52(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::For, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state53(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::If, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state54(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Ignore, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state55(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Immediate, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state56(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Indexed, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state57(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Initially, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state58(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Inner, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state59(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Instead, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state60(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Key, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state61(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Left, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state62(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Natural, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state63(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::No, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state64(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Of, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state65(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Offset, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state66(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Outer, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state67(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Plan, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state68(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Pragma, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state69(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Query, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state70(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Recursive, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state71(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Reindex, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state72(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Release, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state73(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rename, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state74(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Replace, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state75(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Restrict, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state76(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Right, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state77(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rollback, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state78(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Row, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state79(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Savepoint, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state80(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Temp, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state81(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Trigger, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state82(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Vacuum, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state83(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::View, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state84(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Virtual, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state85(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Without, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state86(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym1.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Id(__sym2) => {
                    __result = __state29(text, __tokens, __lookahead, __sym2, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Name(__sym2) => {
                    __result = __state30(text, __tokens, __lookahead, __sym2, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::TableName(__sym2) => {
                    __result = __state118(text, __tokens, __lookahead, __sym0, __sym1, __sym2, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state95<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, Tok::Id(__tok0), __loc2)) => {
                let __sym2 = (__loc1, (__tok0), __loc2);
                __result = __state32(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Abort, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state33(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Action, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state34(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::After, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state35(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Analyze, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state36(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Asc, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state37(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Attach, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state38(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Before, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state39(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Begin, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state40(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::By, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state41(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cascade, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state42(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Conflict, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state43(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cross, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state44(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Deferred, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state45(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Desc, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state46(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Detach, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state47(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Each, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state48(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::End, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state49(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Exclusive, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state50(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Explain, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state51(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Fail, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state52(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::For, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state53(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::If, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state54(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Ignore, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state55(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Immediate, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state56(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Indexed, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state57(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Initially, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state58(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Inner, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state59(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Instead, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state60(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Key, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state61(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Left, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state62(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Natural, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state63(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::No, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state64(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Of, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state65(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Offset, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state66(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Outer, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state67(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Plan, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state68(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Pragma, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state69(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Query, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state70(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Recursive, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state71(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Reindex, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state72(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Release, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state73(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rename, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state74(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Replace, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state75(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Restrict, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state76(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Right, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state77(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rollback, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state78(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Row, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state79(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Savepoint, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state80(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Temp, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state81(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Trigger, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state82(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Vacuum, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state83(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::View, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state84(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Virtual, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state85(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Without, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state86(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym1.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Id(__sym2) => {
                    __result = __state29(text, __tokens, __lookahead, __sym2, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Name(__sym2) => {
                    __result = __state30(text, __tokens, __lookahead, __sym2, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::TableName(__sym2) => {
                    __result = __state119(text, __tokens, __lookahead, __sym0, __sym1, __sym2, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state96<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, ::std::vec::Vec<Column>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, Tok::Id(__tok0), __loc2)) => {
                let __sym1 = (__loc1, (__tok0), __loc2);
                __result = __state32(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Abort, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state33(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Action, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state34(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::After, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state35(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Analyze, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state36(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Asc, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state37(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Attach, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state38(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Before, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state39(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Begin, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state40(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::By, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state41(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cascade, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state42(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Conflict, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state43(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cross, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state44(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Deferred, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state45(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Desc, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state46(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Detach, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state47(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Each, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state48(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::End, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state49(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Exclusive, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state50(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Explain, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state51(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Fail, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state52(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::For, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state53(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::If, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state54(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Ignore, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state55(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Immediate, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state56(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Indexed, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state57(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Initially, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state58(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Inner, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state59(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Instead, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state60(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Key, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state61(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Left, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state62(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Natural, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state63(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::No, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state64(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Of, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state65(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Offset, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state66(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Outer, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state67(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Plan, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state68(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Pragma, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state69(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Query, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state70(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Recursive, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state71(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Reindex, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state72(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Release, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state73(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rename, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state74(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Replace, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state75(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Restrict, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state76(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Right, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state77(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rollback, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state78(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Row, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state79(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Savepoint, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state80(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Temp, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state81(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Trigger, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state82(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Vacuum, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state83(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::View, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state84(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Virtual, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state85(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Without, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state86(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::ColName(__sym1) => {
                    __result = __state97(text, __tokens, __lookahead, __sym1, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Column(__sym1) => {
                    __result = __state120(text, __tokens, __lookahead, __sym0, __sym1, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                __Nonterminal::Id(__sym1) => {
                    __result = __state29(text, __tokens, __lookahead, __sym1, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Name(__sym1) => {
                    __result = __state100(text, __tokens, __lookahead, __sym1, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::TableName(__sym1) => {
                    __result = __state102(text, __tokens, __lookahead, __sym1, ::std::marker::PhantomData::<(&())>)?;
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state97<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Name, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::Is, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action246::<>(text, __sym0);
                let __nt = __Nonterminal::Column((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"",""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""and""###.to_string(),
                    r###""from""###.to_string(),
                    r###""is""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state98<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Column, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, __tok @ Tok::Comma, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state121(text, __tokens, __sym0, __sym1, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            Some((_, Tok::From, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action230::<>(text, __sym0);
                let __nt = __Nonterminal::CommaList_3cColumn_3e((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"",""###.to_string(),
                    r###""from""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state99<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Vec<Column>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((_, Tok::From, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action43::<>(text, __sym0);
                let __nt = __Nonterminal::Selector((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""from""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state100<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Name, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::Is, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action39::<>(text, __sym0);
                let __nt = __Nonterminal::ColName((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            Some((_, Tok::Dot, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action16::<>(text, __sym0);
                let __nt = __Nonterminal::TableName((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"",""###.to_string(),
                    r###"".""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""and""###.to_string(),
                    r###""from""###.to_string(),
                    r###""is""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state101<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Selector, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, __tok @ Tok::From, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state122(text, __tokens, __sym0, __sym1, __sym2, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""from""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym1.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state102<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Name, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, __tok @ Tok::Dot, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state123(text, __tokens, __sym0, __sym1, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"".""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state103<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::From, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action42::<>(text, __sym0);
                let __nt = __Nonterminal::Selector((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""from""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state104<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::Semi, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym1.2.clone();
                let __nt = super::__action10::<>(text, __sym0, __sym1);
                let __nt = __Nonterminal::SystemStmt((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"";""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym1.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state105<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::Semi, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym1.2.clone();
                let __nt = super::__action15::<>(text, __sym0, __sym1);
                let __nt = __Nonterminal::DatabaseStmt((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"";""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym1.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state106<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Name, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, __tok @ Tok::Set, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state124(text, __tokens, __sym0, __sym1, __sym2, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""set""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym1.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state107<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Name, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((_, Tok::Semi, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym1.2.clone();
                let __nt = super::__action14::<>(text, __sym0, __sym1);
                let __nt = __Nonterminal::DatabaseStmt((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"";""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym1.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state108<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Name, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((_, Tok::Semi, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action11::<>(text, __sym0);
                let __nt = __Nonterminal::DatabaseName((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"";""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state109<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, __tok @ Tok::Add, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state125(text, __tokens, __sym0, __sym1, __sym2, __sym3, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            Some((__loc1, __tok @ Tok::Change, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state126(text, __tokens, __sym0, __sym1, __sym2, __sym3, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            Some((__loc1, __tok @ Tok::Drop, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state127(text, __tokens, __sym0, __sym1, __sym2, __sym3, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            Some((__loc1, __tok @ Tok::Rename, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state128(text, __tokens, __sym0, __sym1, __sym2, __sym3, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""add""###.to_string(),
                    r###""change""###.to_string(),
                    r###""drop""###.to_string(),
                    r###""rename""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym2.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state110<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Name, usize),
        __sym2: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, Tok::Id(__tok0), __loc2)) => {
                let __sym3 = (__loc1, (__tok0), __loc2);
                __result = __state32(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Abort, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state33(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Action, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state34(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::After, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state35(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Analyze, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state36(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Asc, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state37(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Attach, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state38(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Before, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state39(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Begin, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state40(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::By, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state41(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cascade, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state42(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Conflict, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state43(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cross, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state44(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Deferred, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state45(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Desc, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state46(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Detach, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state47(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Each, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state48(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::End, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state49(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Exclusive, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state50(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Explain, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state51(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Fail, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state52(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::For, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state53(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::If, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state54(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Ignore, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state55(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Immediate, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state56(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Indexed, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state57(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Initially, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state58(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Inner, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state59(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Instead, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state60(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Key, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state61(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Left, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state62(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Natural, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state63(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::No, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state64(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Of, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state65(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Offset, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state66(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Outer, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state67(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Plan, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state68(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Pragma, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state69(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Query, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state70(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Recursive, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state71(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Reindex, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state72(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Release, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state73(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rename, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state74(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Replace, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state75(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Restrict, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state76(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Right, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state77(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rollback, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state78(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Row, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state79(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Savepoint, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state80(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Temp, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state81(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Trigger, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state82(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Vacuum, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state83(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::View, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state84(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Virtual, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state85(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Without, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state86(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym2.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Id(__sym3) => {
                    __result = __state29(text, __tokens, __lookahead, __sym3, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Name(__sym3) => {
                    __result = __state129(text, __tokens, __lookahead, __sym3, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::PathName(__sym3) => {
                    __result = __state130(text, __tokens, __lookahead, __sym0, __sym1, __sym2, __sym3, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state111<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((_, Tok::Semi, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym2.2.clone();
                let __nt = super::__action12::<>(text, __sym0, __sym1, __sym2);
                let __nt = __Nonterminal::DatabaseStmt((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"";""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym2.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state112<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, __tok @ Tok::On, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state131(text, __tokens, __sym0, __sym1, __sym2, __sym3, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""on""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym2.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state113<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Name, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::On, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action24::<>(text, __sym0);
                let __nt = __Nonterminal::IndexName((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                    r###"";""###.to_string(),
                    r###""on""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state114<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, __tok @ Tok::LeftParen, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state132(text, __tokens, __sym0, __sym1, __sym2, __sym3, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym2.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state115<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, __tok @ Tok::Where, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state133(text, __tokens, __sym0, __sym1, __sym2, __sym3, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            Some((_, Tok::Semi, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym2.2.clone();
                let __nt = super::__action219::<>(text, __sym0, __sym1, __sym2);
                let __nt = __Nonterminal::TableStmt((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"";""###.to_string(),
                    r###""where""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym2.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state116<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((_, Tok::Semi, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym2.2.clone();
                let __nt = super::__action13::<>(text, __sym0, __sym1, __sym2);
                let __nt = __Nonterminal::DatabaseStmt((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"";""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym2.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state117<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, __tok @ Tok::On, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state134(text, __tokens, __sym0, __sym1, __sym2, __sym3, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""on""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym2.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state118<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((_, Tok::Semi, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym2.2.clone();
                let __nt = super::__action18::<>(text, __sym0, __sym1, __sym2);
                let __nt = __Nonterminal::TableStmt((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"";""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym2.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state119<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, __tok @ Tok::Values, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state135(text, __tokens, __sym0, __sym1, __sym2, __sym3, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""values""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym2.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state120<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, ::std::vec::Vec<Column>, usize),
        __sym1: (usize, Column, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, __tok @ Tok::Comma, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state136(text, __tokens, __sym0, __sym1, __sym2, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            Some((_, Tok::From, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym1.2.clone();
                let __nt = super::__action231::<>(text, __sym0, __sym1);
                let __nt = __Nonterminal::CommaList_3cColumn_3e((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"",""###.to_string(),
                    r###""from""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym1.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state121<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Column, usize),
        __sym1: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym1.2.clone();
                let __nt = super::__action228::<>(text, __sym0, __sym1);
                let __nt = __Nonterminal::_28_3cColumn_3e_20_22_2c_22_29_2b((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym1.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state122<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Selector, usize),
        __sym2: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, Tok::Id(__tok0), __loc2)) => {
                let __sym3 = (__loc1, (__tok0), __loc2);
                __result = __state32(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Abort, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state33(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Action, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state34(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::After, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state35(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Analyze, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state36(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Asc, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state37(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Attach, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state38(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Before, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state39(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Begin, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state40(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::By, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state41(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cascade, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state42(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Conflict, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state43(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cross, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state44(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Deferred, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state45(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Desc, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state46(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Detach, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state47(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Each, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state48(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::End, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state49(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Exclusive, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state50(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Explain, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state51(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Fail, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state52(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::For, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state53(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::If, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state54(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Ignore, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state55(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Immediate, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state56(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Indexed, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state57(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Initially, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state58(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Inner, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state59(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Instead, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state60(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Key, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state61(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Left, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state62(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Natural, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state63(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::No, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state64(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Of, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state65(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Offset, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state66(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Outer, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state67(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Plan, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state68(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Pragma, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state69(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Query, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state70(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Recursive, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state71(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Reindex, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state72(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Release, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state73(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rename, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state74(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Replace, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state75(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Restrict, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state76(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Right, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state77(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rollback, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state78(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Row, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state79(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Savepoint, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state80(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Temp, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state81(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Trigger, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state82(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Vacuum, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state83(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::View, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state84(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Virtual, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state85(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Without, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state86(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym2.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cTableName_3e_20_22_2c_22_29_2b(__sym3) => {
                    __result = __state137(text, __tokens, __lookahead, __sym3, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::CommaList_3cTableName_3e(__sym3) => {
                    __result = __state138(text, __tokens, __lookahead, __sym0, __sym1, __sym2, __sym3, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                __Nonterminal::Id(__sym3) => {
                    __result = __state29(text, __tokens, __lookahead, __sym3, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Name(__sym3) => {
                    __result = __state30(text, __tokens, __lookahead, __sym3, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::TableName(__sym3) => {
                    __result = __state139(text, __tokens, __lookahead, __sym3, ::std::marker::PhantomData::<(&())>)?;
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state123<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Name, usize),
        __sym1: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, Tok::Id(__tok0), __loc2)) => {
                let __sym2 = (__loc1, (__tok0), __loc2);
                __result = __state32(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Abort, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state33(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Action, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state34(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::After, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state35(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Analyze, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state36(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Asc, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state37(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Attach, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state38(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Before, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state39(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Begin, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state40(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::By, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state41(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cascade, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state42(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Conflict, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state43(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cross, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state44(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Deferred, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state45(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Desc, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state46(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Detach, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state47(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Each, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state48(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::End, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state49(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Exclusive, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state50(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Explain, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state51(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Fail, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state52(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::For, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state53(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::If, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state54(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Ignore, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state55(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Immediate, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state56(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Indexed, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state57(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Initially, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state58(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Inner, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state59(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Instead, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state60(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Key, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state61(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Left, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state62(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Natural, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state63(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::No, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state64(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Of, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state65(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Offset, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state66(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Outer, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state67(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Plan, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state68(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Pragma, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state69(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Query, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state70(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Recursive, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state71(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Reindex, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state72(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Release, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state73(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rename, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state74(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Replace, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state75(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Restrict, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state76(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Right, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state77(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rollback, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state78(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Row, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state79(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Savepoint, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state80(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Temp, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state81(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Trigger, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state82(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Vacuum, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state83(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::View, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state84(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Virtual, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state85(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Without, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state86(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym1.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::ColName(__sym2) => {
                    __result = __state140(text, __tokens, __lookahead, __sym0, __sym1, __sym2, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                __Nonterminal::Id(__sym2) => {
                    __result = __state29(text, __tokens, __lookahead, __sym2, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Name(__sym2) => {
                    __result = __state141(text, __tokens, __lookahead, __sym2, ::std::marker::PhantomData::<(&())>)?;
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state124<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Name, usize),
        __sym2: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, Tok::Id(__tok0), __loc2)) => {
                let __sym3 = (__loc1, (__tok0), __loc2);
                __result = __state32(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Abort, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state33(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Action, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state34(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::After, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state35(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Analyze, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state36(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Asc, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state37(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Attach, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state38(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Before, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state39(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Begin, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state40(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::By, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state41(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cascade, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state42(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Conflict, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state43(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cross, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state44(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Deferred, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state45(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Desc, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state46(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Detach, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state47(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Each, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state48(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::End, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state49(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Exclusive, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state50(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Explain, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state51(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Fail, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state52(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::For, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state53(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::If, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state54(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Ignore, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state55(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Immediate, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state56(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Indexed, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state57(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Initially, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state58(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Inner, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state59(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Instead, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state60(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Key, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state61(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Left, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state62(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Natural, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state63(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::No, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state64(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Of, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state65(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Offset, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state66(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Outer, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state67(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Plan, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state68(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Pragma, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state69(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Query, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state70(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Recursive, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state71(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Reindex, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state72(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Release, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state73(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rename, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state74(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Replace, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state75(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Restrict, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state76(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Right, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state77(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rollback, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state78(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Row, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state79(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Savepoint, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state80(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Temp, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state81(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Trigger, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state82(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Vacuum, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state83(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::View, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state84(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Virtual, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state85(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Without, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state86(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym2.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cSetClause_3e_20_22_2c_22_29_2b(__sym3) => {
                    __result = __state142(text, __tokens, __lookahead, __sym3, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::ColName(__sym3) => {
                    __result = __state143(text, __tokens, __lookahead, __sym3, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::CommaList_3cSetClause_3e(__sym3) => {
                    __result = __state144(text, __tokens, __lookahead, __sym0, __sym1, __sym2, __sym3, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                __Nonterminal::Id(__sym3) => {
                    __result = __state29(text, __tokens, __lookahead, __sym3, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Name(__sym3) => {
                    __result = __state141(text, __tokens, __lookahead, __sym3, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::SetClause(__sym3) => {
                    __result = __state145(text, __tokens, __lookahead, __sym3, ::std::marker::PhantomData::<(&())>)?;
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state125<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        __sym3: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, Tok::Id(__tok0), __loc2)) => {
                let __sym4 = (__loc1, (__tok0), __loc2);
                __result = __state32(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Abort, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state33(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Action, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state34(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::After, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state35(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Analyze, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state36(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Asc, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state37(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Attach, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state38(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Before, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state39(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Begin, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state40(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::By, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state41(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cascade, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state42(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Conflict, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state43(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Constraint, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state148(text, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            Some((__loc1, __tok @ Tok::Cross, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state44(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Deferred, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state45(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Desc, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state46(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Detach, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state47(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Each, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state48(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::End, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state49(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Exclusive, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state50(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Explain, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state51(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Fail, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state52(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::For, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state53(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::If, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state54(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Ignore, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state55(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Immediate, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state56(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Index, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state149(text, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            Some((__loc1, __tok @ Tok::Indexed, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state57(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Initially, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state58(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Inner, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state59(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Instead, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state60(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Key, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state61(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Left, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state62(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Natural, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state63(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::No, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state64(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Of, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state65(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Offset, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state66(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Outer, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state67(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Plan, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state68(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Pragma, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state69(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Primary, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state150(text, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            Some((__loc1, __tok @ Tok::Query, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state70(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Recursive, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state71(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Reindex, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state72(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Release, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state73(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rename, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state74(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Replace, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state75(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Restrict, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state76(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Right, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state77(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rollback, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state78(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Row, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state79(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Savepoint, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state80(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Temp, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state81(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Trigger, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state82(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Vacuum, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state83(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::View, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state84(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Virtual, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state85(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Without, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state86(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""constraint""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""index""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym3.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::ColName(__sym4) => {
                    __result = __state146(text, __tokens, __lookahead, __sym4, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::ColumnField(__sym4) => {
                    __result = __state147(text, __tokens, __lookahead, __sym0, __sym1, __sym2, __sym3, __sym4, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                __Nonterminal::Id(__sym4) => {
                    __result = __state29(text, __tokens, __lookahead, __sym4, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Name(__sym4) => {
                    __result = __state141(text, __tokens, __lookahead, __sym4, ::std::marker::PhantomData::<(&())>)?;
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state126<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        __sym3: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, Tok::Id(__tok0), __loc2)) => {
                let __sym4 = (__loc1, (__tok0), __loc2);
                __result = __state32(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Abort, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state33(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Action, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state34(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::After, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state35(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Analyze, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state36(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Asc, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state37(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Attach, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state38(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Before, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state39(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Begin, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state40(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::By, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state41(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cascade, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state42(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Conflict, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state43(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cross, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state44(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Deferred, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state45(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Desc, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state46(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Detach, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state47(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Each, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state48(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::End, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state49(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Exclusive, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state50(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Explain, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state51(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Fail, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state52(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::For, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state53(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::If, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state54(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Ignore, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state55(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Immediate, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state56(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Indexed, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state57(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Initially, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state58(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Inner, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state59(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Instead, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state60(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Key, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state61(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Left, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state62(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Natural, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state63(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::No, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state64(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Of, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state65(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Offset, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state66(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Outer, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state67(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Plan, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state68(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Pragma, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state69(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Query, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state70(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Recursive, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state71(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Reindex, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state72(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Release, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state73(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rename, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state74(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Replace, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state75(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Restrict, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state76(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Right, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state77(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rollback, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state78(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Row, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state79(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Savepoint, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state80(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Temp, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state81(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Trigger, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state82(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Vacuum, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state83(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::View, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state84(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Virtual, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state85(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Without, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state86(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym3.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::ColName(__sym4) => {
                    __result = __state151(text, __tokens, __lookahead, __sym0, __sym1, __sym2, __sym3, __sym4, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                __Nonterminal::Id(__sym4) => {
                    __result = __state29(text, __tokens, __lookahead, __sym4, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Name(__sym4) => {
                    __result = __state141(text, __tokens, __lookahead, __sym4, ::std::marker::PhantomData::<(&())>)?;
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state127<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        __sym3: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, Tok::Id(__tok0), __loc2)) => {
                let __sym4 = (__loc1, (__tok0), __loc2);
                __result = __state32(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Abort, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state33(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Action, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state34(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::After, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state35(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Analyze, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state36(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Asc, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state37(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Attach, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state38(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Before, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state39(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Begin, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state40(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::By, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state41(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cascade, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state42(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Conflict, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state43(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cross, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state44(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Deferred, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state45(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Desc, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state46(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Detach, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state47(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Each, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state48(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::End, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state49(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Exclusive, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state50(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Explain, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state51(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Fail, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state52(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::For, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state53(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Foreign, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state153(text, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            Some((__loc1, __tok @ Tok::If, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state54(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Ignore, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state55(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Immediate, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state56(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Index, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state154(text, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            Some((__loc1, __tok @ Tok::Indexed, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state57(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Initially, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state58(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Inner, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state59(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Instead, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state60(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Key, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state61(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Left, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state62(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Natural, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state63(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::No, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state64(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Of, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state65(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Offset, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state66(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Outer, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state67(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Plan, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state68(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Pragma, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state69(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Primary, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state155(text, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            Some((__loc1, __tok @ Tok::Query, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state70(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Recursive, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state71(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Reindex, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state72(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Release, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state73(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rename, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state74(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Replace, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state75(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Restrict, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state76(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Right, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state77(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rollback, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state78(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Row, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state79(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Savepoint, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state80(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Temp, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state81(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Trigger, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state82(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Vacuum, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state83(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::View, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state84(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Virtual, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state85(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Without, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state86(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""index""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym3.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::ColName(__sym4) => {
                    __result = __state152(text, __tokens, __lookahead, __sym0, __sym1, __sym2, __sym3, __sym4, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                __Nonterminal::Id(__sym4) => {
                    __result = __state29(text, __tokens, __lookahead, __sym4, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Name(__sym4) => {
                    __result = __state141(text, __tokens, __lookahead, __sym4, ::std::marker::PhantomData::<(&())>)?;
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state128<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        __sym3: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, __tok @ Tok::To, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state156(text, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""to""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym3.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state129<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Name, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((_, Tok::Semi, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action8::<>(text, __sym0);
                let __nt = __Nonterminal::PathName((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"";""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state130<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Name, usize),
        __sym2: (usize, Tok<'input>, usize),
        __sym3: (usize, Name, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((_, Tok::Semi, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym3.2.clone();
                let __nt = super::__action9::<>(text, __sym0, __sym1, __sym2, __sym3);
                let __nt = __Nonterminal::CopyStmt((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"";""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym3.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state131<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        __sym3: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, Tok::Id(__tok0), __loc2)) => {
                let __sym4 = (__loc1, (__tok0), __loc2);
                __result = __state32(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Abort, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state33(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Action, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state34(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::After, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state35(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Analyze, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state36(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Asc, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state37(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Attach, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state38(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Before, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state39(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Begin, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state40(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::By, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state41(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cascade, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state42(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Conflict, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state43(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cross, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state44(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Deferred, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state45(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Desc, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state46(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Detach, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state47(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Each, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state48(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::End, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state49(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Exclusive, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state50(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Explain, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state51(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Fail, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state52(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::For, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state53(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::If, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state54(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Ignore, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state55(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Immediate, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state56(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Indexed, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state57(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Initially, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state58(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Inner, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state59(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Instead, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state60(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Key, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state61(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Left, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state62(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Natural, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state63(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::No, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state64(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Of, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state65(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Offset, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state66(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Outer, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state67(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Plan, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state68(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Pragma, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state69(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Query, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state70(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Recursive, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state71(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Reindex, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state72(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Release, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state73(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rename, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state74(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Replace, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state75(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Restrict, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state76(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Right, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state77(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rollback, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state78(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Row, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state79(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Savepoint, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state80(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Temp, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state81(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Trigger, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state82(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Vacuum, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state83(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::View, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state84(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Virtual, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state85(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Without, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state86(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym3.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Id(__sym4) => {
                    __result = __state29(text, __tokens, __lookahead, __sym4, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Name(__sym4) => {
                    __result = __state30(text, __tokens, __lookahead, __sym4, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::TableName(__sym4) => {
                    __result = __state157(text, __tokens, __lookahead, __sym0, __sym1, __sym2, __sym3, __sym4, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state132<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        __sym3: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, Tok::Id(__tok0), __loc2)) => {
                let __sym4 = (__loc1, (__tok0), __loc2);
                __result = __state32(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Abort, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state33(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Action, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state34(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::After, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state35(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Analyze, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state36(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Asc, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state37(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Attach, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state38(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Before, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state39(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Begin, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state40(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::By, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state41(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cascade, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state42(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Conflict, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state43(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cross, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state44(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Deferred, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state45(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Desc, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state46(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Detach, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state47(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Each, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state48(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::End, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state49(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Exclusive, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state50(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Explain, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state51(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Fail, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state52(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::For, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state53(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Foreign, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state164(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::If, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state54(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Ignore, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state55(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Immediate, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state56(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Indexed, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state57(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Initially, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state58(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Inner, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state59(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Instead, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state60(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Key, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state61(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Left, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state62(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Natural, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state63(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::No, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state64(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Of, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state65(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Offset, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state66(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Outer, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state67(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Plan, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state68(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Pragma, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state69(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Primary, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state165(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Query, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state70(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Recursive, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state71(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Reindex, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state72(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Release, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state73(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rename, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state74(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Replace, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state75(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Restrict, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state76(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Right, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state77(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rollback, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state78(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Row, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state79(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Savepoint, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state80(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Temp, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state81(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Trigger, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state82(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Vacuum, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state83(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::View, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state84(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Virtual, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state85(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Without, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state86(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym3.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cField_3e_20_22_2c_22_29_2b(__sym4) => {
                    __result = __state158(text, __tokens, __lookahead, __sym4, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::ColName(__sym4) => {
                    __result = __state146(text, __tokens, __lookahead, __sym4, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::ColumnField(__sym4) => {
                    __result = __state159(text, __tokens, __lookahead, __sym4, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::CommaList_3cField_3e(__sym4) => {
                    __result = __state160(text, __tokens, __lookahead, __sym0, __sym1, __sym2, __sym3, __sym4, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                __Nonterminal::Field(__sym4) => {
                    __result = __state161(text, __tokens, __lookahead, __sym4, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::ForeignKeyField(__sym4) => {
                    __result = __state162(text, __tokens, __lookahead, __sym4, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Id(__sym4) => {
                    __result = __state29(text, __tokens, __lookahead, __sym4, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Name(__sym4) => {
                    __result = __state141(text, __tokens, __lookahead, __sym4, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::PrimaryKeyField(__sym4) => {
                    __result = __state163(text, __tokens, __lookahead, __sym4, ::std::marker::PhantomData::<(&())>)?;
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state133<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        __sym3: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, Tok::Id(__tok0), __loc2)) => {
                let __sym4 = (__loc1, (__tok0), __loc2);
                __result = __state32(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Abort, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state33(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Action, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state34(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::After, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state35(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Analyze, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state36(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Asc, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state37(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Attach, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state38(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Before, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state39(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Begin, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state40(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::By, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state41(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cascade, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state42(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Conflict, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state43(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cross, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state44(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Deferred, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state45(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Desc, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state46(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Detach, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state47(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Each, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state48(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::End, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state49(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Exclusive, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state50(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Explain, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state51(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Fail, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state52(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::For, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state53(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::If, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state54(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Ignore, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state55(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Immediate, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state56(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Indexed, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state57(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Initially, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state58(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Inner, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state59(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Instead, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state60(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Key, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state61(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Left, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state62(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Natural, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state63(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::No, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state64(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Of, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state65(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Offset, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state66(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Outer, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state67(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Plan, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state68(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Pragma, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state69(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Query, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state70(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Recursive, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state71(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Reindex, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state72(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Release, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state73(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rename, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state74(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Replace, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state75(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Restrict, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state76(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Right, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state77(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rollback, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state78(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Row, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state79(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Savepoint, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state80(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Temp, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state81(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Trigger, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state82(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Vacuum, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state83(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::View, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state84(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Virtual, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state85(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Without, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state86(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym3.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cWhereClause_3e_20_22and_22_29_2b(__sym4) => {
                    __result = __state166(text, __tokens, __lookahead, __sym4, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::ColName(__sym4) => {
                    __result = __state97(text, __tokens, __lookahead, __sym4, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Column(__sym4) => {
                    __result = __state167(text, __tokens, __lookahead, __sym4, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Id(__sym4) => {
                    __result = __state29(text, __tokens, __lookahead, __sym4, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Name(__sym4) => {
                    __result = __state100(text, __tokens, __lookahead, __sym4, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::TableName(__sym4) => {
                    __result = __state102(text, __tokens, __lookahead, __sym4, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::WhereClause(__sym4) => {
                    __result = __state168(text, __tokens, __lookahead, __sym4, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::WhereClauseList(__sym4) => {
                    __result = __state169(text, __tokens, __lookahead, __sym0, __sym1, __sym2, __sym3, __sym4, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state134<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        __sym3: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, Tok::Id(__tok0), __loc2)) => {
                let __sym4 = (__loc1, (__tok0), __loc2);
                __result = __state32(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Abort, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state33(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Action, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state34(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::After, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state35(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Analyze, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state36(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Asc, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state37(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Attach, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state38(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Before, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state39(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Begin, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state40(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::By, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state41(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cascade, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state42(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Conflict, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state43(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cross, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state44(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Deferred, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state45(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Desc, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state46(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Detach, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state47(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Each, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state48(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::End, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state49(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Exclusive, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state50(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Explain, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state51(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Fail, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state52(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::For, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state53(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::If, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state54(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Ignore, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state55(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Immediate, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state56(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Indexed, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state57(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Initially, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state58(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Inner, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state59(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Instead, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state60(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Key, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state61(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Left, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state62(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Natural, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state63(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::No, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state64(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Of, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state65(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Offset, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state66(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Outer, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state67(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Plan, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state68(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Pragma, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state69(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Query, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state70(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Recursive, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state71(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Reindex, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state72(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Release, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state73(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rename, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state74(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Replace, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state75(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Restrict, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state76(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Right, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state77(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rollback, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state78(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Row, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state79(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Savepoint, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state80(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Temp, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state81(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Trigger, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state82(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Vacuum, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state83(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::View, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state84(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Virtual, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state85(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Without, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state86(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym3.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Id(__sym4) => {
                    __result = __state29(text, __tokens, __lookahead, __sym4, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Name(__sym4) => {
                    __result = __state30(text, __tokens, __lookahead, __sym4, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::TableName(__sym4) => {
                    __result = __state170(text, __tokens, __lookahead, __sym0, __sym1, __sym2, __sym3, __sym4, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state135<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        __sym3: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, __tok @ Tok::LeftParen, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state174(text, __tokens, __sym4, ::std::marker::PhantomData::<(&())>)?;
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym3.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cValueList_3e_20_22_2c_22_29_2b(__sym4) => {
                    __result = __state171(text, __tokens, __lookahead, __sym4, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::CommaList_3cValueList_3e(__sym4) => {
                    __result = __state172(text, __tokens, __lookahead, __sym0, __sym1, __sym2, __sym3, __sym4, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                __Nonterminal::ValueList(__sym4) => {
                    __result = __state173(text, __tokens, __lookahead, __sym4, ::std::marker::PhantomData::<(&())>)?;
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state136<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, ::std::vec::Vec<Column>, usize),
        __sym1: (usize, Column, usize),
        __sym2: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym2.2.clone();
                let __nt = super::__action229::<>(text, __sym0, __sym1, __sym2);
                let __nt = __Nonterminal::_28_3cColumn_3e_20_22_2c_22_29_2b((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym2.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state137<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, ::std::vec::Vec<Name>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, Tok::Id(__tok0), __loc2)) => {
                let __sym1 = (__loc1, (__tok0), __loc2);
                __result = __state32(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Abort, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state33(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Action, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state34(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::After, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state35(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Analyze, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state36(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Asc, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state37(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Attach, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state38(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Before, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state39(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Begin, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state40(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::By, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state41(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cascade, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state42(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Conflict, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state43(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cross, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state44(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Deferred, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state45(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Desc, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state46(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Detach, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state47(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Each, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state48(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::End, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state49(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Exclusive, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state50(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Explain, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state51(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Fail, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state52(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::For, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state53(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::If, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state54(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Ignore, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state55(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Immediate, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state56(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Indexed, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state57(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Initially, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state58(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Inner, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state59(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Instead, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state60(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Key, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state61(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Left, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state62(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Natural, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state63(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::No, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state64(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Of, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state65(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Offset, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state66(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Outer, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state67(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Plan, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state68(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Pragma, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state69(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Query, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state70(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Recursive, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state71(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Reindex, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state72(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Release, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state73(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rename, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state74(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Replace, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state75(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Restrict, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state76(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Right, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state77(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rollback, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state78(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Row, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state79(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Savepoint, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state80(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Temp, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state81(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Trigger, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state82(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Vacuum, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state83(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::View, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state84(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Virtual, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state85(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Without, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state86(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Id(__sym1) => {
                    __result = __state29(text, __tokens, __lookahead, __sym1, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Name(__sym1) => {
                    __result = __state30(text, __tokens, __lookahead, __sym1, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::TableName(__sym1) => {
                    __result = __state175(text, __tokens, __lookahead, __sym0, __sym1, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state138<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Selector, usize),
        __sym2: (usize, Tok<'input>, usize),
        __sym3: (usize, Vec<Name>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, __tok @ Tok::Where, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state176(text, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            Some((_, Tok::Semi, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym3.2.clone();
                let __nt = super::__action223::<>(text, __sym0, __sym1, __sym2, __sym3);
                let __nt = __Nonterminal::TableStmt((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"";""###.to_string(),
                    r###""where""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym3.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state139<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Name, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, __tok @ Tok::Comma, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state177(text, __tokens, __sym0, __sym1, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::Where, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action242::<>(text, __sym0);
                let __nt = __Nonterminal::CommaList_3cTableName_3e((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"",""###.to_string(),
                    r###"";""###.to_string(),
                    r###""where""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state140<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Name, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::Is, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym2.2.clone();
                let __nt = super::__action245::<>(text, __sym0, __sym1, __sym2);
                let __nt = __Nonterminal::Column((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"",""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""and""###.to_string(),
                    r###""from""###.to_string(),
                    r###""is""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym2.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state141<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Name, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LessEquals, _)) |
            Some((_, Tok::NotEquals, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::GreaterEquals, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::BigInt, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Char, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Date, _)) |
            Some((_, Tok::Decimal, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::FloatType, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::From, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Int, _)) |
            Some((_, Tok::Integerr, _)) |
            Some((_, Tok::Is, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Numeric, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::Varchar, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action39::<>(text, __sym0);
                let __nt = __Nonterminal::ColName((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"";""###.to_string(),
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""and""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""bigint""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""char""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""date""###.to_string(),
                    r###""decimal""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""float""###.to_string(),
                    r###""for""###.to_string(),
                    r###""from""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""int""###.to_string(),
                    r###""integer""###.to_string(),
                    r###""is""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""numeric""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""varchar""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state142<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, ::std::vec::Vec<SetClause>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, Tok::Id(__tok0), __loc2)) => {
                let __sym1 = (__loc1, (__tok0), __loc2);
                __result = __state32(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Abort, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state33(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Action, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state34(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::After, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state35(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Analyze, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state36(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Asc, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state37(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Attach, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state38(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Before, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state39(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Begin, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state40(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::By, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state41(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cascade, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state42(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Conflict, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state43(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cross, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state44(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Deferred, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state45(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Desc, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state46(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Detach, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state47(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Each, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state48(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::End, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state49(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Exclusive, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state50(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Explain, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state51(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Fail, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state52(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::For, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state53(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::If, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state54(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Ignore, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state55(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Immediate, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state56(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Indexed, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state57(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Initially, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state58(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Inner, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state59(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Instead, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state60(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Key, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state61(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Left, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state62(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Natural, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state63(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::No, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state64(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Of, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state65(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Offset, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state66(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Outer, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state67(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Plan, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state68(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Pragma, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state69(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Query, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state70(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Recursive, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state71(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Reindex, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state72(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Release, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state73(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rename, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state74(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Replace, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state75(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Restrict, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state76(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Right, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state77(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rollback, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state78(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Row, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state79(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Savepoint, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state80(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Temp, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state81(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Trigger, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state82(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Vacuum, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state83(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::View, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state84(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Virtual, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state85(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Without, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state86(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::ColName(__sym1) => {
                    __result = __state143(text, __tokens, __lookahead, __sym1, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Id(__sym1) => {
                    __result = __state29(text, __tokens, __lookahead, __sym1, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Name(__sym1) => {
                    __result = __state141(text, __tokens, __lookahead, __sym1, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::SetClause(__sym1) => {
                    __result = __state178(text, __tokens, __lookahead, __sym0, __sym1, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state143<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Name, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, __tok @ Tok::Equals, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state179(text, __tokens, __sym0, __sym1, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""=""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state144<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Name, usize),
        __sym2: (usize, Tok<'input>, usize),
        __sym3: (usize, Vec<SetClause>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, __tok @ Tok::Where, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state180(text, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            Some((_, Tok::Semi, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym3.2.clone();
                let __nt = super::__action221::<>(text, __sym0, __sym1, __sym2, __sym3);
                let __nt = __Nonterminal::TableStmt((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"";""###.to_string(),
                    r###""where""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym3.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state145<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, SetClause, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, __tok @ Tok::Comma, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state181(text, __tokens, __sym0, __sym1, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::Where, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action238::<>(text, __sym0);
                let __nt = __Nonterminal::CommaList_3cSetClause_3e((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"",""###.to_string(),
                    r###"";""###.to_string(),
                    r###""where""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state146<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Name, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, __tok @ Tok::BigInt, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state183(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Char, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state184(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Date, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state185(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Decimal, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state186(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::FloatType, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state187(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Int, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state188(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Integerr, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state189(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Numeric, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state190(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Varchar, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state191(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            _ => {
                let __expected = vec![
                    r###""bigint""###.to_string(),
                    r###""char""###.to_string(),
                    r###""date""###.to_string(),
                    r###""decimal""###.to_string(),
                    r###""float""###.to_string(),
                    r###""int""###.to_string(),
                    r###""integer""###.to_string(),
                    r###""numeric""###.to_string(),
                    r###""varchar""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Type(__sym1) => {
                    __result = __state182(text, __tokens, __lookahead, __sym0, __sym1, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state147<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        __sym3: (usize, Tok<'input>, usize),
        __sym4: (usize, Field, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((_, Tok::Semi, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym4.2.clone();
                let __nt = super::__action29::<>(text, __sym0, __sym1, __sym2, __sym3, __sym4);
                let __nt = __Nonterminal::AlterStmt((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"";""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym4.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state148<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        __sym3: (usize, Tok<'input>, usize),
        __sym4: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, Tok::Id(__tok0), __loc2)) => {
                let __sym5 = (__loc1, (__tok0), __loc2);
                __result = __state32(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Abort, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state33(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Action, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state34(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::After, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state35(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Analyze, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state36(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Asc, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state37(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Attach, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state38(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Before, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state39(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Begin, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state40(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::By, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state41(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cascade, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state42(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Conflict, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state43(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cross, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state44(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Deferred, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state45(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Desc, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state46(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Detach, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state47(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Each, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state48(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::End, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state49(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Exclusive, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state50(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Explain, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state51(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Fail, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state52(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::For, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state53(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::If, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state54(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Ignore, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state55(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Immediate, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state56(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Indexed, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state57(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Initially, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state58(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Inner, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state59(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Instead, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state60(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Key, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state61(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Left, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state62(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Natural, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state63(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::No, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state64(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Of, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state65(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Offset, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state66(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Outer, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state67(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Plan, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state68(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Pragma, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state69(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Query, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state70(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Recursive, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state71(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Reindex, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state72(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Release, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state73(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rename, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state74(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Replace, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state75(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Restrict, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state76(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Right, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state77(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rollback, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state78(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Row, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state79(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Savepoint, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state80(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Temp, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state81(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Trigger, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state82(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Vacuum, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state83(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::View, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state84(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Virtual, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state85(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Without, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state86(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym4.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Id(__sym5) => {
                    __result = __state29(text, __tokens, __lookahead, __sym5, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Name(__sym5) => {
                    __result = __state192(text, __tokens, __lookahead, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state149<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        __sym3: (usize, Tok<'input>, usize),
        __sym4: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, Tok::Id(__tok0), __loc2)) => {
                let __sym5 = (__loc1, (__tok0), __loc2);
                __result = __state32(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Abort, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state33(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Action, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state34(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::After, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state35(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Analyze, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state36(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Asc, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state37(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Attach, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state38(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Before, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state39(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Begin, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state40(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::By, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state41(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cascade, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state42(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Conflict, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state43(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cross, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state44(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Deferred, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state45(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Desc, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state46(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Detach, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state47(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Each, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state48(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::End, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state49(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Exclusive, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state50(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Explain, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state51(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Fail, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state52(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::For, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state53(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::If, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state54(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Ignore, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state55(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Immediate, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state56(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Indexed, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state57(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Initially, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state58(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Inner, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state59(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Instead, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state60(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Key, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state61(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Left, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state62(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Natural, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state63(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::No, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state64(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Of, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state65(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Offset, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state66(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Outer, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state67(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Plan, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state68(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Pragma, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state69(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Query, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state70(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Recursive, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state71(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Reindex, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state72(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Release, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state73(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rename, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state74(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Replace, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state75(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Restrict, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state76(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Right, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state77(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rollback, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state78(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Row, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state79(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Savepoint, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state80(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Temp, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state81(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Trigger, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state82(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Vacuum, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state83(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::View, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state84(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Virtual, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state85(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Without, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state86(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym4.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Id(__sym5) => {
                    __result = __state29(text, __tokens, __lookahead, __sym5, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::IndexName(__sym5) => {
                    __result = __state193(text, __tokens, __lookahead, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                __Nonterminal::Name(__sym5) => {
                    __result = __state113(text, __tokens, __lookahead, __sym5, ::std::marker::PhantomData::<(&())>)?;
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state150<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        __sym3: (usize, Tok<'input>, usize),
        __sym4: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, __tok @ Tok::Key, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state194(text, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""key""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym4.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state151<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        __sym3: (usize, Tok<'input>, usize),
        __sym4: (usize, Name, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, Tok::Id(__tok0), __loc2)) => {
                let __sym5 = (__loc1, (__tok0), __loc2);
                __result = __state32(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Abort, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state33(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Action, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state34(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::After, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state35(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Analyze, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state36(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Asc, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state37(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Attach, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state38(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Before, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state39(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Begin, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state40(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::By, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state41(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cascade, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state42(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Conflict, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state43(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cross, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state44(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Deferred, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state45(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Desc, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state46(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Detach, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state47(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Each, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state48(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::End, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state49(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Exclusive, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state50(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Explain, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state51(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Fail, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state52(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::For, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state53(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::If, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state54(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Ignore, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state55(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Immediate, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state56(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Indexed, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state57(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Initially, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state58(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Inner, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state59(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Instead, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state60(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Key, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state61(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Left, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state62(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Natural, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state63(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::No, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state64(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Of, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state65(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Offset, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state66(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Outer, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state67(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Plan, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state68(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Pragma, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state69(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Query, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state70(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Recursive, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state71(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Reindex, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state72(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Release, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state73(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rename, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state74(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Replace, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state75(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Restrict, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state76(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Right, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state77(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rollback, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state78(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Row, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state79(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Savepoint, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state80(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Temp, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state81(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Trigger, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state82(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Vacuum, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state83(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::View, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state84(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Virtual, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state85(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Without, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state86(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym4.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::ColName(__sym5) => {
                    __result = __state146(text, __tokens, __lookahead, __sym5, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::ColumnField(__sym5) => {
                    __result = __state195(text, __tokens, __lookahead, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                __Nonterminal::Id(__sym5) => {
                    __result = __state29(text, __tokens, __lookahead, __sym5, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Name(__sym5) => {
                    __result = __state141(text, __tokens, __lookahead, __sym5, ::std::marker::PhantomData::<(&())>)?;
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state152<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        __sym3: (usize, Tok<'input>, usize),
        __sym4: (usize, Name, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((_, Tok::Semi, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym4.2.clone();
                let __nt = super::__action30::<>(text, __sym0, __sym1, __sym2, __sym3, __sym4);
                let __nt = __Nonterminal::AlterStmt((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"";""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym4.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state153<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        __sym3: (usize, Tok<'input>, usize),
        __sym4: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, __tok @ Tok::Key, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state196(text, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""key""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym4.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state154<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        __sym3: (usize, Tok<'input>, usize),
        __sym4: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, Tok::Id(__tok0), __loc2)) => {
                let __sym5 = (__loc1, (__tok0), __loc2);
                __result = __state32(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Abort, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state33(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Action, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state34(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::After, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state35(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Analyze, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state36(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Asc, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state37(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Attach, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state38(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Before, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state39(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Begin, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state40(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::By, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state41(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cascade, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state42(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Conflict, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state43(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cross, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state44(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Deferred, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state45(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Desc, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state46(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Detach, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state47(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Each, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state48(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::End, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state49(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Exclusive, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state50(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Explain, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state51(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Fail, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state52(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::For, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state53(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::If, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state54(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Ignore, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state55(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Immediate, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state56(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Indexed, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state57(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Initially, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state58(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Inner, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state59(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Instead, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state60(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Key, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state61(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Left, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state62(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Natural, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state63(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::No, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state64(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Of, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state65(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Offset, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state66(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Outer, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state67(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Plan, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state68(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Pragma, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state69(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Query, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state70(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Recursive, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state71(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Reindex, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state72(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Release, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state73(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rename, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state74(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Replace, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state75(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Restrict, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state76(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Right, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state77(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rollback, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state78(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Row, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state79(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Savepoint, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state80(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Temp, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state81(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Trigger, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state82(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Vacuum, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state83(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::View, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state84(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Virtual, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state85(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Without, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state86(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym4.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Id(__sym5) => {
                    __result = __state29(text, __tokens, __lookahead, __sym5, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::IndexName(__sym5) => {
                    __result = __state197(text, __tokens, __lookahead, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                __Nonterminal::Name(__sym5) => {
                    __result = __state113(text, __tokens, __lookahead, __sym5, ::std::marker::PhantomData::<(&())>)?;
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state155<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        __sym3: (usize, Tok<'input>, usize),
        __sym4: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, __tok @ Tok::Key, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state198(text, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""key""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym4.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state156<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        __sym3: (usize, Tok<'input>, usize),
        __sym4: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, Tok::Id(__tok0), __loc2)) => {
                let __sym5 = (__loc1, (__tok0), __loc2);
                __result = __state32(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Abort, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state33(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Action, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state34(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::After, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state35(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Analyze, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state36(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Asc, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state37(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Attach, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state38(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Before, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state39(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Begin, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state40(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::By, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state41(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cascade, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state42(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Conflict, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state43(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cross, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state44(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Deferred, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state45(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Desc, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state46(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Detach, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state47(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Each, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state48(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::End, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state49(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Exclusive, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state50(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Explain, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state51(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Fail, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state52(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::For, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state53(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::If, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state54(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Ignore, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state55(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Immediate, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state56(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Indexed, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state57(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Initially, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state58(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Inner, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state59(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Instead, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state60(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Key, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state61(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Left, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state62(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Natural, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state63(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::No, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state64(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Of, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state65(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Offset, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state66(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Outer, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state67(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Plan, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state68(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Pragma, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state69(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Query, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state70(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Recursive, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state71(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Reindex, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state72(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Release, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state73(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rename, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state74(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Replace, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state75(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Restrict, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state76(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Right, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state77(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rollback, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state78(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Row, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state79(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Savepoint, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state80(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Temp, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state81(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Trigger, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state82(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Vacuum, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state83(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::View, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state84(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Virtual, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state85(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Without, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state86(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym4.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Id(__sym5) => {
                    __result = __state29(text, __tokens, __lookahead, __sym5, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Name(__sym5) => {
                    __result = __state30(text, __tokens, __lookahead, __sym5, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::TableName(__sym5) => {
                    __result = __state199(text, __tokens, __lookahead, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state157<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        __sym3: (usize, Tok<'input>, usize),
        __sym4: (usize, Name, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, __tok @ Tok::LeftParen, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state200(text, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym4.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state158<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, ::std::vec::Vec<Field>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, Tok::Id(__tok0), __loc2)) => {
                let __sym1 = (__loc1, (__tok0), __loc2);
                __result = __state32(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Abort, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state33(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Action, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state34(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::After, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state35(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Analyze, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state36(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Asc, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state37(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Attach, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state38(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Before, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state39(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Begin, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state40(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::By, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state41(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cascade, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state42(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Conflict, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state43(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cross, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state44(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Deferred, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state45(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Desc, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state46(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Detach, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state47(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Each, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state48(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::End, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state49(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Exclusive, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state50(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Explain, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state51(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Fail, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state52(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::For, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state53(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Foreign, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state164(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::If, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state54(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Ignore, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state55(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Immediate, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state56(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Indexed, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state57(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Initially, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state58(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Inner, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state59(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Instead, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state60(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Key, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state61(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Left, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state62(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Natural, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state63(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::No, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state64(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Of, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state65(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Offset, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state66(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Outer, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state67(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Plan, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state68(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Pragma, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state69(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Primary, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state165(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Query, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state70(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Recursive, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state71(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Reindex, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state72(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Release, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state73(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rename, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state74(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Replace, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state75(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Restrict, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state76(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Right, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state77(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rollback, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state78(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Row, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state79(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Savepoint, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state80(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Temp, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state81(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Trigger, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state82(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Vacuum, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state83(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::View, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state84(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Virtual, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state85(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Without, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state86(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::ColName(__sym1) => {
                    __result = __state146(text, __tokens, __lookahead, __sym1, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::ColumnField(__sym1) => {
                    __result = __state159(text, __tokens, __lookahead, __sym1, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Field(__sym1) => {
                    __result = __state201(text, __tokens, __lookahead, __sym0, __sym1, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                __Nonterminal::ForeignKeyField(__sym1) => {
                    __result = __state162(text, __tokens, __lookahead, __sym1, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Id(__sym1) => {
                    __result = __state29(text, __tokens, __lookahead, __sym1, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Name(__sym1) => {
                    __result = __state141(text, __tokens, __lookahead, __sym1, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::PrimaryKeyField(__sym1) => {
                    __result = __state163(text, __tokens, __lookahead, __sym1, ::std::marker::PhantomData::<(&())>)?;
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state159<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Field, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action58::<>(text, __sym0);
                let __nt = __Nonterminal::Field((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state160<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        __sym3: (usize, Tok<'input>, usize),
        __sym4: (usize, Vec<Field>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, __tok @ Tok::RightParen, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state202(text, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"")""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym4.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state161<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Field, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, __tok @ Tok::Comma, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state203(text, __tokens, __sym0, __sym1, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            Some((_, Tok::RightParen, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action234::<>(text, __sym0);
                let __nt = __Nonterminal::CommaList_3cField_3e((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state162<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Field, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action60::<>(text, __sym0);
                let __nt = __Nonterminal::Field((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state163<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Field, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action59::<>(text, __sym0);
                let __nt = __Nonterminal::Field((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state164<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, __tok @ Tok::Key, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state204(text, __tokens, __sym0, __sym1, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""key""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state165<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, __tok @ Tok::Key, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state205(text, __tokens, __sym0, __sym1, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""key""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state166<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, ::std::vec::Vec<WhereClause>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, Tok::Id(__tok0), __loc2)) => {
                let __sym1 = (__loc1, (__tok0), __loc2);
                __result = __state32(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Abort, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state33(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Action, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state34(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::After, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state35(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Analyze, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state36(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Asc, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state37(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Attach, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state38(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Before, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state39(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Begin, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state40(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::By, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state41(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cascade, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state42(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Conflict, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state43(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cross, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state44(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Deferred, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state45(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Desc, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state46(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Detach, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state47(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Each, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state48(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::End, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state49(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Exclusive, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state50(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Explain, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state51(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Fail, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state52(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::For, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state53(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::If, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state54(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Ignore, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state55(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Immediate, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state56(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Indexed, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state57(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Initially, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state58(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Inner, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state59(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Instead, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state60(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Key, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state61(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Left, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state62(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Natural, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state63(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::No, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state64(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Of, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state65(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Offset, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state66(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Outer, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state67(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Plan, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state68(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Pragma, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state69(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Query, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state70(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Recursive, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state71(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Reindex, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state72(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Release, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state73(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rename, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state74(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Replace, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state75(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Restrict, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state76(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Right, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state77(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rollback, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state78(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Row, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state79(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Savepoint, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state80(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Temp, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state81(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Trigger, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state82(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Vacuum, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state83(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::View, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state84(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Virtual, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state85(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Without, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state86(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::ColName(__sym1) => {
                    __result = __state97(text, __tokens, __lookahead, __sym1, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Column(__sym1) => {
                    __result = __state167(text, __tokens, __lookahead, __sym1, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Id(__sym1) => {
                    __result = __state29(text, __tokens, __lookahead, __sym1, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Name(__sym1) => {
                    __result = __state100(text, __tokens, __lookahead, __sym1, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::TableName(__sym1) => {
                    __result = __state102(text, __tokens, __lookahead, __sym1, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::WhereClause(__sym1) => {
                    __result = __state206(text, __tokens, __lookahead, __sym0, __sym1, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state167<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Column, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, __tok @ Tok::LessThan, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state208(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::LessEquals, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state209(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::NotEquals, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state210(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Equals, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state211(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::GreaterThan, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state212(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::GreaterEquals, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state213(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Is, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state214(text, __tokens, __sym0, __sym1, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""<""###.to_string(),
                    r###""<=""###.to_string(),
                    r###""<>""###.to_string(),
                    r###""=""###.to_string(),
                    r###"">""###.to_string(),
                    r###"">=""###.to_string(),
                    r###""is""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Op(__sym1) => {
                    __result = __state207(text, __tokens, __lookahead, __sym0, __sym1, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state168<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, WhereClause, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, __tok @ Tok::And, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state215(text, __tokens, __sym0, __sym1, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            Some((_, Tok::Semi, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action257::<>(text, __sym0);
                let __nt = __Nonterminal::WhereClauseList((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"";""###.to_string(),
                    r###""and""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state169<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        __sym3: (usize, Tok<'input>, usize),
        __sym4: (usize, Vec<WhereClause>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((_, Tok::Semi, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym4.2.clone();
                let __nt = super::__action218::<>(text, __sym0, __sym1, __sym2, __sym3, __sym4);
                let __nt = __Nonterminal::TableStmt((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"";""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym4.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state170<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        __sym3: (usize, Tok<'input>, usize),
        __sym4: (usize, Name, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((_, Tok::Semi, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym4.2.clone();
                let __nt = super::__action26::<>(text, __sym0, __sym1, __sym2, __sym3, __sym4);
                let __nt = __Nonterminal::IndexStmt((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"";""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym4.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state171<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, ::std::vec::Vec<Vec<Value>>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, __tok @ Tok::LeftParen, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state174(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::ValueList(__sym1) => {
                    __result = __state216(text, __tokens, __lookahead, __sym0, __sym1, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state172<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        __sym3: (usize, Tok<'input>, usize),
        __sym4: (usize, Vec<Vec<Value>>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((_, Tok::Semi, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym4.2.clone();
                let __nt = super::__action20::<>(text, __sym0, __sym1, __sym2, __sym3, __sym4);
                let __nt = __Nonterminal::TableStmt((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"";""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym4.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state173<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Vec<Value>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, __tok @ Tok::Comma, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state217(text, __tokens, __sym0, __sym1, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            Some((_, Tok::Semi, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action253::<>(text, __sym0);
                let __nt = __Nonterminal::CommaList_3cValueList_3e((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"",""###.to_string(),
                    r###"";""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state174<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, __tok @ Tok::Plus, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state221(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Minus, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state222(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, Tok::Float(__tok0), __loc2)) => {
                let __sym1 = (__loc1, (__tok0), __loc2);
                __result = __state223(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, Tok::Integer(__tok0), __loc2)) => {
                let __sym1 = (__loc1, (__tok0), __loc2);
                __result = __state224(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, Tok::StringLiteralDoubleQuote(__tok0), __loc2)) => {
                let __sym1 = (__loc1, (__tok0), __loc2);
                __result = __state225(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, Tok::StringLiteralSingleQuote(__tok0), __loc2)) => {
                let __sym1 = (__loc1, (__tok0), __loc2);
                __result = __state226(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Null, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state227(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            _ => {
                let __expected = vec![
                    r###""+""###.to_string(),
                    r###""-""###.to_string(),
                    r###""Float""###.to_string(),
                    r###""Integer""###.to_string(),
                    r###""StringLiteralDoubleQuote""###.to_string(),
                    r###""StringLiteralSingleQuote""###.to_string(),
                    r###""null""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cValue_3e_20_22_2c_22_29_2b(__sym1) => {
                    __result = __state218(text, __tokens, __lookahead, __sym1, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::CommaList_3cValue_3e(__sym1) => {
                    __result = __state219(text, __tokens, __lookahead, __sym0, __sym1, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                __Nonterminal::Value(__sym1) => {
                    __result = __state220(text, __tokens, __lookahead, __sym1, ::std::marker::PhantomData::<(&())>)?;
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state175<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, ::std::vec::Vec<Name>, usize),
        __sym1: (usize, Name, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, __tok @ Tok::Comma, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state228(text, __tokens, __sym0, __sym1, __sym2, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::Where, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym1.2.clone();
                let __nt = super::__action243::<>(text, __sym0, __sym1);
                let __nt = __Nonterminal::CommaList_3cTableName_3e((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"",""###.to_string(),
                    r###"";""###.to_string(),
                    r###""where""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym1.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state176<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Selector, usize),
        __sym2: (usize, Tok<'input>, usize),
        __sym3: (usize, Vec<Name>, usize),
        __sym4: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, Tok::Id(__tok0), __loc2)) => {
                let __sym5 = (__loc1, (__tok0), __loc2);
                __result = __state32(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Abort, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state33(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Action, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state34(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::After, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state35(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Analyze, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state36(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Asc, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state37(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Attach, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state38(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Before, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state39(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Begin, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state40(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::By, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state41(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cascade, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state42(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Conflict, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state43(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cross, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state44(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Deferred, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state45(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Desc, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state46(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Detach, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state47(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Each, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state48(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::End, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state49(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Exclusive, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state50(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Explain, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state51(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Fail, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state52(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::For, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state53(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::If, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state54(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Ignore, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state55(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Immediate, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state56(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Indexed, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state57(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Initially, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state58(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Inner, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state59(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Instead, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state60(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Key, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state61(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Left, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state62(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Natural, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state63(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::No, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state64(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Of, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state65(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Offset, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state66(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Outer, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state67(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Plan, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state68(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Pragma, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state69(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Query, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state70(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Recursive, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state71(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Reindex, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state72(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Release, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state73(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rename, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state74(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Replace, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state75(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Restrict, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state76(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Right, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state77(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rollback, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state78(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Row, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state79(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Savepoint, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state80(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Temp, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state81(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Trigger, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state82(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Vacuum, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state83(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::View, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state84(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Virtual, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state85(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Without, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state86(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym4.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cWhereClause_3e_20_22and_22_29_2b(__sym5) => {
                    __result = __state166(text, __tokens, __lookahead, __sym5, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::ColName(__sym5) => {
                    __result = __state97(text, __tokens, __lookahead, __sym5, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Column(__sym5) => {
                    __result = __state167(text, __tokens, __lookahead, __sym5, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Id(__sym5) => {
                    __result = __state29(text, __tokens, __lookahead, __sym5, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Name(__sym5) => {
                    __result = __state100(text, __tokens, __lookahead, __sym5, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::TableName(__sym5) => {
                    __result = __state102(text, __tokens, __lookahead, __sym5, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::WhereClause(__sym5) => {
                    __result = __state168(text, __tokens, __lookahead, __sym5, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::WhereClauseList(__sym5) => {
                    __result = __state229(text, __tokens, __lookahead, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state177<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Name, usize),
        __sym1: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym1.2.clone();
                let __nt = super::__action240::<>(text, __sym0, __sym1);
                let __nt = __Nonterminal::_28_3cTableName_3e_20_22_2c_22_29_2b((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym1.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state178<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, ::std::vec::Vec<SetClause>, usize),
        __sym1: (usize, SetClause, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, __tok @ Tok::Comma, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state230(text, __tokens, __sym0, __sym1, __sym2, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::Where, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym1.2.clone();
                let __nt = super::__action239::<>(text, __sym0, __sym1);
                let __nt = __Nonterminal::CommaList_3cSetClause_3e((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"",""###.to_string(),
                    r###"";""###.to_string(),
                    r###""where""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym1.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state179<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Name, usize),
        __sym1: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, __tok @ Tok::Plus, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state221(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Minus, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state222(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, Tok::Float(__tok0), __loc2)) => {
                let __sym2 = (__loc1, (__tok0), __loc2);
                __result = __state223(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, Tok::Integer(__tok0), __loc2)) => {
                let __sym2 = (__loc1, (__tok0), __loc2);
                __result = __state224(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, Tok::StringLiteralDoubleQuote(__tok0), __loc2)) => {
                let __sym2 = (__loc1, (__tok0), __loc2);
                __result = __state225(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, Tok::StringLiteralSingleQuote(__tok0), __loc2)) => {
                let __sym2 = (__loc1, (__tok0), __loc2);
                __result = __state226(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Null, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state227(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            _ => {
                let __expected = vec![
                    r###""+""###.to_string(),
                    r###""-""###.to_string(),
                    r###""Float""###.to_string(),
                    r###""Integer""###.to_string(),
                    r###""StringLiteralDoubleQuote""###.to_string(),
                    r###""StringLiteralSingleQuote""###.to_string(),
                    r###""null""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym1.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Value(__sym2) => {
                    __result = __state231(text, __tokens, __lookahead, __sym0, __sym1, __sym2, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state180<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Name, usize),
        __sym2: (usize, Tok<'input>, usize),
        __sym3: (usize, Vec<SetClause>, usize),
        __sym4: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, Tok::Id(__tok0), __loc2)) => {
                let __sym5 = (__loc1, (__tok0), __loc2);
                __result = __state32(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Abort, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state33(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Action, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state34(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::After, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state35(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Analyze, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state36(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Asc, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state37(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Attach, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state38(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Before, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state39(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Begin, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state40(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::By, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state41(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cascade, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state42(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Conflict, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state43(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cross, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state44(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Deferred, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state45(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Desc, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state46(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Detach, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state47(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Each, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state48(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::End, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state49(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Exclusive, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state50(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Explain, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state51(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Fail, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state52(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::For, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state53(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::If, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state54(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Ignore, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state55(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Immediate, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state56(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Indexed, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state57(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Initially, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state58(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Inner, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state59(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Instead, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state60(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Key, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state61(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Left, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state62(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Natural, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state63(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::No, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state64(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Of, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state65(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Offset, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state66(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Outer, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state67(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Plan, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state68(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Pragma, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state69(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Query, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state70(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Recursive, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state71(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Reindex, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state72(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Release, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state73(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rename, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state74(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Replace, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state75(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Restrict, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state76(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Right, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state77(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rollback, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state78(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Row, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state79(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Savepoint, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state80(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Temp, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state81(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Trigger, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state82(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Vacuum, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state83(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::View, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state84(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Virtual, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state85(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Without, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state86(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym4.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cWhereClause_3e_20_22and_22_29_2b(__sym5) => {
                    __result = __state166(text, __tokens, __lookahead, __sym5, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::ColName(__sym5) => {
                    __result = __state97(text, __tokens, __lookahead, __sym5, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Column(__sym5) => {
                    __result = __state167(text, __tokens, __lookahead, __sym5, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Id(__sym5) => {
                    __result = __state29(text, __tokens, __lookahead, __sym5, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Name(__sym5) => {
                    __result = __state100(text, __tokens, __lookahead, __sym5, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::TableName(__sym5) => {
                    __result = __state102(text, __tokens, __lookahead, __sym5, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::WhereClause(__sym5) => {
                    __result = __state168(text, __tokens, __lookahead, __sym5, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::WhereClauseList(__sym5) => {
                    __result = __state232(text, __tokens, __lookahead, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state181<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, SetClause, usize),
        __sym1: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym1.2.clone();
                let __nt = super::__action236::<>(text, __sym0, __sym1);
                let __nt = __Nonterminal::_28_3cSetClause_3e_20_22_2c_22_29_2b((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym1.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state182<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Name, usize),
        __sym1: (usize, Type, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, __tok @ Tok::Default, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state233(text, __tokens, __sym0, __sym1, __sym2, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            Some((__loc1, __tok @ Tok::Not, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state234(text, __tokens, __sym0, __sym1, __sym2, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym1.2.clone();
                let __nt = super::__action216::<>(text, __sym0, __sym1);
                let __nt = __Nonterminal::ColumnField((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"";""###.to_string(),
                    r###""default""###.to_string(),
                    r###""not""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym1.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state183<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::Default, _)) |
            Some((_, Tok::Not, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action71::<>(text, __sym0);
                let __nt = __Nonterminal::Type((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"";""###.to_string(),
                    r###""default""###.to_string(),
                    r###""not""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state184<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, __tok @ Tok::LeftParen, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state235(text, __tokens, __sym0, __sym1, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state185<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::Default, _)) |
            Some((_, Tok::Not, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action77::<>(text, __sym0);
                let __nt = __Nonterminal::Type((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"";""###.to_string(),
                    r###""default""###.to_string(),
                    r###""not""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state186<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::Default, _)) |
            Some((_, Tok::Not, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action76::<>(text, __sym0);
                let __nt = __Nonterminal::Type((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"";""###.to_string(),
                    r###""default""###.to_string(),
                    r###""not""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state187<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::Default, _)) |
            Some((_, Tok::Not, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action78::<>(text, __sym0);
                let __nt = __Nonterminal::Type((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"";""###.to_string(),
                    r###""default""###.to_string(),
                    r###""not""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state188<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, __tok @ Tok::LeftParen, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state236(text, __tokens, __sym0, __sym1, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::Default, _)) |
            Some((_, Tok::Not, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action70::<>(text, __sym0);
                let __nt = __Nonterminal::Type((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"";""###.to_string(),
                    r###""default""###.to_string(),
                    r###""not""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state189<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::Default, _)) |
            Some((_, Tok::Not, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action72::<>(text, __sym0);
                let __nt = __Nonterminal::Type((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"";""###.to_string(),
                    r###""default""###.to_string(),
                    r###""not""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state190<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, __tok @ Tok::LeftParen, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state237(text, __tokens, __sym0, __sym1, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state191<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, __tok @ Tok::LeftParen, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state238(text, __tokens, __sym0, __sym1, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state192<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        __sym3: (usize, Tok<'input>, usize),
        __sym4: (usize, Tok<'input>, usize),
        __sym5: (usize, Name, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, __tok @ Tok::Foreign, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state239(text, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            Some((__loc1, __tok @ Tok::Primary, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state240(text, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""foreign""###.to_string(),
                    r###""primary""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym5.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state193<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        __sym3: (usize, Tok<'input>, usize),
        __sym4: (usize, Tok<'input>, usize),
        __sym5: (usize, Name, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, __tok @ Tok::LeftParen, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state241(text, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym5.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state194<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        __sym3: (usize, Tok<'input>, usize),
        __sym4: (usize, Tok<'input>, usize),
        __sym5: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, __tok @ Tok::LeftParen, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state242(text, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym5.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state195<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        __sym3: (usize, Tok<'input>, usize),
        __sym4: (usize, Name, usize),
        __sym5: (usize, Field, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((_, Tok::Semi, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym5.2.clone();
                let __nt = super::__action31::<>(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5);
                let __nt = __Nonterminal::AlterStmt((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"";""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym5.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state196<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        __sym3: (usize, Tok<'input>, usize),
        __sym4: (usize, Tok<'input>, usize),
        __sym5: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, Tok::Id(__tok0), __loc2)) => {
                let __sym6 = (__loc1, (__tok0), __loc2);
                __result = __state32(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Abort, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state33(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Action, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state34(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::After, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state35(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Analyze, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state36(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Asc, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state37(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Attach, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state38(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Before, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state39(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Begin, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state40(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::By, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state41(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cascade, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state42(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Conflict, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state43(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cross, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state44(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Deferred, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state45(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Desc, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state46(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Detach, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state47(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Each, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state48(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::End, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state49(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Exclusive, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state50(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Explain, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state51(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Fail, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state52(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::For, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state53(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::If, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state54(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Ignore, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state55(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Immediate, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state56(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Indexed, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state57(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Initially, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state58(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Inner, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state59(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Instead, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state60(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Key, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state61(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Left, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state62(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Natural, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state63(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::No, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state64(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Of, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state65(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Offset, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state66(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Outer, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state67(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Plan, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state68(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Pragma, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state69(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Query, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state70(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Recursive, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state71(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Reindex, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state72(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Release, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state73(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rename, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state74(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Replace, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state75(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Restrict, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state76(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Right, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state77(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rollback, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state78(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Row, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state79(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Savepoint, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state80(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Temp, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state81(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Trigger, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state82(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Vacuum, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state83(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::View, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state84(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Virtual, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state85(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Without, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state86(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym5.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Id(__sym6) => {
                    __result = __state29(text, __tokens, __lookahead, __sym6, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Name(__sym6) => {
                    __result = __state243(text, __tokens, __lookahead, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state197<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        __sym3: (usize, Tok<'input>, usize),
        __sym4: (usize, Tok<'input>, usize),
        __sym5: (usize, Name, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((_, Tok::Semi, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym5.2.clone();
                let __nt = super::__action28::<>(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5);
                let __nt = __Nonterminal::IndexStmt((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"";""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym5.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state198<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        __sym3: (usize, Tok<'input>, usize),
        __sym4: (usize, Tok<'input>, usize),
        __sym5: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, Tok::Id(__tok0), __loc2)) => {
                let __sym6 = (__loc1, (__tok0), __loc2);
                __result = __state32(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Abort, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state33(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Action, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state34(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::After, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state35(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Analyze, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state36(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Asc, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state37(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Attach, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state38(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Before, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state39(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Begin, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state40(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::By, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state41(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cascade, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state42(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Conflict, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state43(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cross, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state44(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Deferred, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state45(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Desc, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state46(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Detach, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state47(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Each, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state48(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::End, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state49(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Exclusive, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state50(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Explain, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state51(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Fail, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state52(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::For, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state53(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::If, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state54(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Ignore, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state55(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Immediate, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state56(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Indexed, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state57(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Initially, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state58(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Inner, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state59(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Instead, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state60(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Key, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state61(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Left, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state62(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Natural, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state63(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::No, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state64(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Of, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state65(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Offset, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state66(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Outer, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state67(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Plan, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state68(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Pragma, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state69(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Query, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state70(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Recursive, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state71(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Reindex, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state72(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Release, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state73(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rename, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state74(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Replace, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state75(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Restrict, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state76(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Right, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state77(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rollback, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state78(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Row, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state79(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Savepoint, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state80(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Temp, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state81(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Trigger, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state82(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Vacuum, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state83(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::View, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state84(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Virtual, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state85(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Without, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state86(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((_, Tok::Semi, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym5.2.clone();
                let __nt = super::__action34::<>(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5);
                let __nt = __Nonterminal::AlterStmt((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"";""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym5.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Id(__sym6) => {
                    __result = __state29(text, __tokens, __lookahead, __sym6, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Name(__sym6) => {
                    __result = __state244(text, __tokens, __lookahead, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state199<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        __sym3: (usize, Tok<'input>, usize),
        __sym4: (usize, Tok<'input>, usize),
        __sym5: (usize, Name, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((_, Tok::Semi, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym5.2.clone();
                let __nt = super::__action32::<>(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5);
                let __nt = __Nonterminal::AlterStmt((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"";""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym5.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state200<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        __sym3: (usize, Tok<'input>, usize),
        __sym4: (usize, Name, usize),
        __sym5: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, Tok::Id(__tok0), __loc2)) => {
                let __sym6 = (__loc1, (__tok0), __loc2);
                __result = __state32(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Abort, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state33(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Action, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state34(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::After, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state35(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Analyze, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state36(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Asc, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state37(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Attach, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state38(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Before, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state39(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Begin, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state40(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::By, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state41(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cascade, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state42(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Conflict, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state43(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cross, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state44(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Deferred, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state45(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Desc, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state46(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Detach, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state47(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Each, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state48(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::End, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state49(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Exclusive, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state50(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Explain, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state51(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Fail, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state52(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::For, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state53(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::If, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state54(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Ignore, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state55(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Immediate, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state56(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Indexed, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state57(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Initially, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state58(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Inner, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state59(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Instead, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state60(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Key, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state61(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Left, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state62(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Natural, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state63(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::No, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state64(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Of, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state65(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Offset, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state66(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Outer, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state67(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Plan, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state68(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Pragma, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state69(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Query, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state70(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Recursive, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state71(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Reindex, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state72(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Release, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state73(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rename, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state74(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Replace, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state75(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Restrict, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state76(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Right, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state77(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rollback, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state78(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Row, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state79(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Savepoint, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state80(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Temp, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state81(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Trigger, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state82(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Vacuum, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state83(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::View, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state84(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Virtual, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state85(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Without, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state86(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym5.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cColName_3e_20_22_2c_22_29_2b(__sym6) => {
                    __result = __state245(text, __tokens, __lookahead, __sym6, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::ColName(__sym6) => {
                    __result = __state246(text, __tokens, __lookahead, __sym6, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::CommaList_3cColName_3e(__sym6) => {
                    __result = __state247(text, __tokens, __lookahead, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                __Nonterminal::Id(__sym6) => {
                    __result = __state29(text, __tokens, __lookahead, __sym6, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Name(__sym6) => {
                    __result = __state141(text, __tokens, __lookahead, __sym6, ::std::marker::PhantomData::<(&())>)?;
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state201<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, ::std::vec::Vec<Field>, usize),
        __sym1: (usize, Field, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, __tok @ Tok::Comma, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state248(text, __tokens, __sym0, __sym1, __sym2, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            Some((_, Tok::RightParen, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym1.2.clone();
                let __nt = super::__action235::<>(text, __sym0, __sym1);
                let __nt = __Nonterminal::CommaList_3cField_3e((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym1.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state202<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        __sym3: (usize, Tok<'input>, usize),
        __sym4: (usize, Vec<Field>, usize),
        __sym5: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::Semi, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym5.2.clone();
                let __nt = super::__action17::<>(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5);
                let __nt = __Nonterminal::TableStmt((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"";""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym5.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state203<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Field, usize),
        __sym1: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::Foreign, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Primary, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym1.2.clone();
                let __nt = super::__action232::<>(text, __sym0, __sym1);
                let __nt = __Nonterminal::_28_3cField_3e_20_22_2c_22_29_2b((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym1.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state204<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, __tok @ Tok::LeftParen, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state249(text, __tokens, __sym0, __sym1, __sym2, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym1.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state205<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, __tok @ Tok::LeftParen, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state250(text, __tokens, __sym0, __sym1, __sym2, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym1.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state206<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, ::std::vec::Vec<WhereClause>, usize),
        __sym1: (usize, WhereClause, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, __tok @ Tok::And, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state251(text, __tokens, __sym0, __sym1, __sym2, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            Some((_, Tok::Semi, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym1.2.clone();
                let __nt = super::__action258::<>(text, __sym0, __sym1);
                let __nt = __Nonterminal::WhereClauseList((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"";""###.to_string(),
                    r###""and""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym1.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state207<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Column, usize),
        __sym1: (usize, Op, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, __tok @ Tok::Plus, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state221(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Minus, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state222(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, Tok::Float(__tok0), __loc2)) => {
                let __sym2 = (__loc1, (__tok0), __loc2);
                __result = __state223(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, Tok::Id(__tok0), __loc2)) => {
                let __sym2 = (__loc1, (__tok0), __loc2);
                __result = __state32(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, Tok::Integer(__tok0), __loc2)) => {
                let __sym2 = (__loc1, (__tok0), __loc2);
                __result = __state224(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, Tok::StringLiteralDoubleQuote(__tok0), __loc2)) => {
                let __sym2 = (__loc1, (__tok0), __loc2);
                __result = __state225(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, Tok::StringLiteralSingleQuote(__tok0), __loc2)) => {
                let __sym2 = (__loc1, (__tok0), __loc2);
                __result = __state226(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Abort, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state33(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Action, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state34(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::After, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state35(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Analyze, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state36(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Asc, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state37(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Attach, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state38(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Before, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state39(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Begin, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state40(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::By, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state41(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cascade, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state42(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Conflict, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state43(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cross, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state44(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Deferred, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state45(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Desc, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state46(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Detach, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state47(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Each, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state48(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::End, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state49(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Exclusive, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state50(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Explain, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state51(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Fail, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state52(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::For, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state53(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::If, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state54(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Ignore, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state55(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Immediate, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state56(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Indexed, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state57(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Initially, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state58(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Inner, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state59(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Instead, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state60(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Key, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state61(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Left, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state62(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Natural, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state63(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::No, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state64(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Null, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state227(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Of, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state65(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Offset, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state66(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Outer, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state67(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Plan, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state68(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Pragma, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state69(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Query, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state70(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Recursive, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state71(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Reindex, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state72(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Release, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state73(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rename, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state74(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Replace, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state75(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Restrict, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state76(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Right, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state77(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rollback, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state78(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Row, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state79(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Savepoint, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state80(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Temp, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state81(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Trigger, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state82(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Vacuum, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state83(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::View, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state84(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Virtual, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state85(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Without, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state86(text, __tokens, __sym2, ::std::marker::PhantomData::<(&())>)?;
            }
            _ => {
                let __expected = vec![
                    r###""+""###.to_string(),
                    r###""-""###.to_string(),
                    r###""Float""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""Integer""###.to_string(),
                    r###""StringLiteralDoubleQuote""###.to_string(),
                    r###""StringLiteralSingleQuote""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""null""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym1.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::ColName(__sym2) => {
                    __result = __state97(text, __tokens, __lookahead, __sym2, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Column(__sym2) => {
                    __result = __state252(text, __tokens, __lookahead, __sym2, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Expr(__sym2) => {
                    __result = __state253(text, __tokens, __lookahead, __sym0, __sym1, __sym2, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                __Nonterminal::Id(__sym2) => {
                    __result = __state29(text, __tokens, __lookahead, __sym2, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Name(__sym2) => {
                    __result = __state100(text, __tokens, __lookahead, __sym2, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::TableName(__sym2) => {
                    __result = __state102(text, __tokens, __lookahead, __sym2, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Value(__sym2) => {
                    __result = __state254(text, __tokens, __lookahead, __sym2, ::std::marker::PhantomData::<(&())>)?;
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state208<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Minus, _)) |
            Some((_, Tok::Float(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Integer(_), _)) |
            Some((_, Tok::StringLiteralDoubleQuote(_), _)) |
            Some((_, Tok::StringLiteralSingleQuote(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Null, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action51::<>(text, __sym0);
                let __nt = __Nonterminal::Op((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""+""###.to_string(),
                    r###""-""###.to_string(),
                    r###""Float""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""Integer""###.to_string(),
                    r###""StringLiteralDoubleQuote""###.to_string(),
                    r###""StringLiteralSingleQuote""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""null""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state209<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Minus, _)) |
            Some((_, Tok::Float(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Integer(_), _)) |
            Some((_, Tok::StringLiteralDoubleQuote(_), _)) |
            Some((_, Tok::StringLiteralSingleQuote(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Null, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action49::<>(text, __sym0);
                let __nt = __Nonterminal::Op((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""+""###.to_string(),
                    r###""-""###.to_string(),
                    r###""Float""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""Integer""###.to_string(),
                    r###""StringLiteralDoubleQuote""###.to_string(),
                    r###""StringLiteralSingleQuote""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""null""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state210<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Minus, _)) |
            Some((_, Tok::Float(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Integer(_), _)) |
            Some((_, Tok::StringLiteralDoubleQuote(_), _)) |
            Some((_, Tok::StringLiteralSingleQuote(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Null, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action48::<>(text, __sym0);
                let __nt = __Nonterminal::Op((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""+""###.to_string(),
                    r###""-""###.to_string(),
                    r###""Float""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""Integer""###.to_string(),
                    r###""StringLiteralDoubleQuote""###.to_string(),
                    r###""StringLiteralSingleQuote""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""null""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state211<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Minus, _)) |
            Some((_, Tok::Float(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Integer(_), _)) |
            Some((_, Tok::StringLiteralDoubleQuote(_), _)) |
            Some((_, Tok::StringLiteralSingleQuote(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Null, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action47::<>(text, __sym0);
                let __nt = __Nonterminal::Op((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""+""###.to_string(),
                    r###""-""###.to_string(),
                    r###""Float""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""Integer""###.to_string(),
                    r###""StringLiteralDoubleQuote""###.to_string(),
                    r###""StringLiteralSingleQuote""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""null""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state212<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Minus, _)) |
            Some((_, Tok::Float(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Integer(_), _)) |
            Some((_, Tok::StringLiteralDoubleQuote(_), _)) |
            Some((_, Tok::StringLiteralSingleQuote(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Null, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action52::<>(text, __sym0);
                let __nt = __Nonterminal::Op((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""+""###.to_string(),
                    r###""-""###.to_string(),
                    r###""Float""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""Integer""###.to_string(),
                    r###""StringLiteralDoubleQuote""###.to_string(),
                    r###""StringLiteralSingleQuote""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""null""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state213<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Minus, _)) |
            Some((_, Tok::Float(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Integer(_), _)) |
            Some((_, Tok::StringLiteralDoubleQuote(_), _)) |
            Some((_, Tok::StringLiteralSingleQuote(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Null, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action50::<>(text, __sym0);
                let __nt = __Nonterminal::Op((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""+""###.to_string(),
                    r###""-""###.to_string(),
                    r###""Float""###.to_string(),
                    r###""Id""###.to_string(),
                    r###""Integer""###.to_string(),
                    r###""StringLiteralDoubleQuote""###.to_string(),
                    r###""StringLiteralSingleQuote""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""null""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state214<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Column, usize),
        __sym1: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, __tok @ Tok::Not, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state255(text, __tokens, __sym0, __sym1, __sym2, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            Some((__loc1, __tok @ Tok::Null, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state256(text, __tokens, __sym0, __sym1, __sym2, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""not""###.to_string(),
                    r###""null""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym1.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state215<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, WhereClause, usize),
        __sym1: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym1.2.clone();
                let __nt = super::__action255::<>(text, __sym0, __sym1);
                let __nt = __Nonterminal::_28_3cWhereClause_3e_20_22and_22_29_2b((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym1.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state216<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, ::std::vec::Vec<Vec<Value>>, usize),
        __sym1: (usize, Vec<Value>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, __tok @ Tok::Comma, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state257(text, __tokens, __sym0, __sym1, __sym2, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            Some((_, Tok::Semi, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym1.2.clone();
                let __nt = super::__action254::<>(text, __sym0, __sym1);
                let __nt = __Nonterminal::CommaList_3cValueList_3e((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"",""###.to_string(),
                    r###"";""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym1.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state217<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Vec<Value>, usize),
        __sym1: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::LeftParen, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym1.2.clone();
                let __nt = super::__action251::<>(text, __sym0, __sym1);
                let __nt = __Nonterminal::_28_3cValueList_3e_20_22_2c_22_29_2b((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym1.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state218<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, ::std::vec::Vec<Value>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, __tok @ Tok::Plus, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state221(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Minus, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state222(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, Tok::Float(__tok0), __loc2)) => {
                let __sym1 = (__loc1, (__tok0), __loc2);
                __result = __state223(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, Tok::Integer(__tok0), __loc2)) => {
                let __sym1 = (__loc1, (__tok0), __loc2);
                __result = __state224(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, Tok::StringLiteralDoubleQuote(__tok0), __loc2)) => {
                let __sym1 = (__loc1, (__tok0), __loc2);
                __result = __state225(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, Tok::StringLiteralSingleQuote(__tok0), __loc2)) => {
                let __sym1 = (__loc1, (__tok0), __loc2);
                __result = __state226(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Null, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state227(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            _ => {
                let __expected = vec![
                    r###""+""###.to_string(),
                    r###""-""###.to_string(),
                    r###""Float""###.to_string(),
                    r###""Integer""###.to_string(),
                    r###""StringLiteralDoubleQuote""###.to_string(),
                    r###""StringLiteralSingleQuote""###.to_string(),
                    r###""null""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Value(__sym1) => {
                    __result = __state258(text, __tokens, __lookahead, __sym0, __sym1, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state219<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Vec<Value>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, __tok @ Tok::RightParen, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state259(text, __tokens, __sym0, __sym1, __sym2, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"")""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym1.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state220<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Value, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, __tok @ Tok::Comma, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state260(text, __tokens, __sym0, __sym1, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            Some((_, Tok::RightParen, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action249::<>(text, __sym0);
                let __nt = __Nonterminal::CommaList_3cValue_3e((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state221<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, Tok::Float(__tok0), __loc2)) => {
                let __sym1 = (__loc1, (__tok0), __loc2);
                __result = __state261(text, __tokens, __sym0, __sym1, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            Some((__loc1, Tok::Integer(__tok0), __loc2)) => {
                let __sym1 = (__loc1, (__tok0), __loc2);
                __result = __state262(text, __tokens, __sym0, __sym1, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""Float""###.to_string(),
                    r###""Integer""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state222<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, Tok::Float(__tok0), __loc2)) => {
                let __sym1 = (__loc1, (__tok0), __loc2);
                __result = __state263(text, __tokens, __sym0, __sym1, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            Some((__loc1, Tok::Integer(__tok0), __loc2)) => {
                let __sym1 = (__loc1, (__tok0), __loc2);
                __result = __state264(text, __tokens, __sym0, __sym1, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""Float""###.to_string(),
                    r###""Integer""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state223<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, &'input str, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Where, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action206::<>(text, __sym0);
                let __nt = __Nonterminal::Value((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"";""###.to_string(),
                    r###""and""###.to_string(),
                    r###""where""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state224<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, &'input str, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Where, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action204::<>(text, __sym0);
                let __nt = __Nonterminal::Value((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"";""###.to_string(),
                    r###""and""###.to_string(),
                    r###""where""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state225<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, &'input str, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Where, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action63::<>(text, __sym0);
                let __nt = __Nonterminal::Value((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"";""###.to_string(),
                    r###""and""###.to_string(),
                    r###""where""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state226<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, &'input str, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Where, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action64::<>(text, __sym0);
                let __nt = __Nonterminal::Value((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"";""###.to_string(),
                    r###""and""###.to_string(),
                    r###""where""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state227<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Where, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action62::<>(text, __sym0);
                let __nt = __Nonterminal::Value((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"";""###.to_string(),
                    r###""and""###.to_string(),
                    r###""where""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state228<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, ::std::vec::Vec<Name>, usize),
        __sym1: (usize, Name, usize),
        __sym2: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym2.2.clone();
                let __nt = super::__action241::<>(text, __sym0, __sym1, __sym2);
                let __nt = __Nonterminal::_28_3cTableName_3e_20_22_2c_22_29_2b((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym2.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state229<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Selector, usize),
        __sym2: (usize, Tok<'input>, usize),
        __sym3: (usize, Vec<Name>, usize),
        __sym4: (usize, Tok<'input>, usize),
        __sym5: (usize, Vec<WhereClause>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((_, Tok::Semi, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym5.2.clone();
                let __nt = super::__action222::<>(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5);
                let __nt = __Nonterminal::TableStmt((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"";""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym5.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state230<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, ::std::vec::Vec<SetClause>, usize),
        __sym1: (usize, SetClause, usize),
        __sym2: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym2.2.clone();
                let __nt = super::__action237::<>(text, __sym0, __sym1, __sym2);
                let __nt = __Nonterminal::_28_3cSetClause_3e_20_22_2c_22_29_2b((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym2.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state231<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Name, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Value, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::Where, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym2.2.clone();
                let __nt = super::__action40::<>(text, __sym0, __sym1, __sym2);
                let __nt = __Nonterminal::SetClause((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"",""###.to_string(),
                    r###"";""###.to_string(),
                    r###""where""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym2.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state232<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Name, usize),
        __sym2: (usize, Tok<'input>, usize),
        __sym3: (usize, Vec<SetClause>, usize),
        __sym4: (usize, Tok<'input>, usize),
        __sym5: (usize, Vec<WhereClause>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((_, Tok::Semi, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym5.2.clone();
                let __nt = super::__action220::<>(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5);
                let __nt = __Nonterminal::TableStmt((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"";""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym5.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state233<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Name, usize),
        __sym1: (usize, Type, usize),
        __sym2: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, __tok @ Tok::Plus, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state221(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Minus, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state222(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, Tok::Float(__tok0), __loc2)) => {
                let __sym3 = (__loc1, (__tok0), __loc2);
                __result = __state223(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, Tok::Integer(__tok0), __loc2)) => {
                let __sym3 = (__loc1, (__tok0), __loc2);
                __result = __state224(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, Tok::StringLiteralDoubleQuote(__tok0), __loc2)) => {
                let __sym3 = (__loc1, (__tok0), __loc2);
                __result = __state225(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, Tok::StringLiteralSingleQuote(__tok0), __loc2)) => {
                let __sym3 = (__loc1, (__tok0), __loc2);
                __result = __state226(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Null, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state227(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            _ => {
                let __expected = vec![
                    r###""+""###.to_string(),
                    r###""-""###.to_string(),
                    r###""Float""###.to_string(),
                    r###""Integer""###.to_string(),
                    r###""StringLiteralDoubleQuote""###.to_string(),
                    r###""StringLiteralSingleQuote""###.to_string(),
                    r###""null""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym2.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Value(__sym3) => {
                    __result = __state265(text, __tokens, __lookahead, __sym0, __sym1, __sym2, __sym3, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state234<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Name, usize),
        __sym1: (usize, Type, usize),
        __sym2: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, __tok @ Tok::Null, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state266(text, __tokens, __sym0, __sym1, __sym2, __sym3, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""null""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym2.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state235<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, Tok::Integer(__tok0), __loc2)) => {
                let __sym2 = (__loc1, (__tok0), __loc2);
                __result = __state267(text, __tokens, __sym0, __sym1, __sym2, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""Integer""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym1.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state236<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, Tok::Integer(__tok0), __loc2)) => {
                let __sym2 = (__loc1, (__tok0), __loc2);
                __result = __state268(text, __tokens, __sym0, __sym1, __sym2, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""Integer""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym1.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state237<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, Tok::Integer(__tok0), __loc2)) => {
                let __sym2 = (__loc1, (__tok0), __loc2);
                __result = __state269(text, __tokens, __sym0, __sym1, __sym2, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""Integer""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym1.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state238<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, Tok::Integer(__tok0), __loc2)) => {
                let __sym2 = (__loc1, (__tok0), __loc2);
                __result = __state270(text, __tokens, __sym0, __sym1, __sym2, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""Integer""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym1.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state239<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        __sym3: (usize, Tok<'input>, usize),
        __sym4: (usize, Tok<'input>, usize),
        __sym5: (usize, Name, usize),
        __sym6: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, __tok @ Tok::Key, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state271(text, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""key""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym6.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state240<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        __sym3: (usize, Tok<'input>, usize),
        __sym4: (usize, Tok<'input>, usize),
        __sym5: (usize, Name, usize),
        __sym6: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, __tok @ Tok::Key, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state272(text, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""key""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym6.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state241<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        __sym3: (usize, Tok<'input>, usize),
        __sym4: (usize, Tok<'input>, usize),
        __sym5: (usize, Name, usize),
        __sym6: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, Tok::Id(__tok0), __loc2)) => {
                let __sym7 = (__loc1, (__tok0), __loc2);
                __result = __state32(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Abort, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state33(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Action, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state34(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::After, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state35(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Analyze, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state36(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Asc, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state37(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Attach, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state38(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Before, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state39(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Begin, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state40(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::By, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state41(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cascade, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state42(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Conflict, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state43(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cross, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state44(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Deferred, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state45(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Desc, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state46(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Detach, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state47(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Each, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state48(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::End, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state49(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Exclusive, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state50(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Explain, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state51(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Fail, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state52(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::For, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state53(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::If, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state54(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Ignore, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state55(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Immediate, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state56(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Indexed, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state57(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Initially, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state58(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Inner, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state59(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Instead, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state60(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Key, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state61(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Left, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state62(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Natural, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state63(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::No, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state64(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Of, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state65(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Offset, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state66(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Outer, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state67(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Plan, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state68(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Pragma, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state69(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Query, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state70(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Recursive, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state71(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Reindex, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state72(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Release, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state73(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rename, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state74(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Replace, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state75(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Restrict, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state76(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Right, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state77(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rollback, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state78(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Row, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state79(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Savepoint, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state80(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Temp, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state81(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Trigger, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state82(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Vacuum, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state83(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::View, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state84(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Virtual, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state85(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Without, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state86(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym6.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cColName_3e_20_22_2c_22_29_2b(__sym7) => {
                    __result = __state245(text, __tokens, __lookahead, __sym7, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::ColName(__sym7) => {
                    __result = __state246(text, __tokens, __lookahead, __sym7, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::CommaList_3cColName_3e(__sym7) => {
                    __result = __state273(text, __tokens, __lookahead, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                __Nonterminal::Id(__sym7) => {
                    __result = __state29(text, __tokens, __lookahead, __sym7, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Name(__sym7) => {
                    __result = __state141(text, __tokens, __lookahead, __sym7, ::std::marker::PhantomData::<(&())>)?;
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state242<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        __sym3: (usize, Tok<'input>, usize),
        __sym4: (usize, Tok<'input>, usize),
        __sym5: (usize, Tok<'input>, usize),
        __sym6: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, Tok::Id(__tok0), __loc2)) => {
                let __sym7 = (__loc1, (__tok0), __loc2);
                __result = __state32(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Abort, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state33(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Action, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state34(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::After, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state35(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Analyze, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state36(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Asc, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state37(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Attach, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state38(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Before, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state39(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Begin, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state40(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::By, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state41(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cascade, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state42(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Conflict, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state43(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cross, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state44(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Deferred, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state45(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Desc, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state46(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Detach, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state47(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Each, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state48(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::End, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state49(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Exclusive, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state50(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Explain, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state51(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Fail, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state52(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::For, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state53(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::If, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state54(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Ignore, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state55(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Immediate, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state56(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Indexed, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state57(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Initially, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state58(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Inner, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state59(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Instead, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state60(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Key, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state61(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Left, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state62(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Natural, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state63(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::No, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state64(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Of, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state65(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Offset, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state66(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Outer, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state67(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Plan, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state68(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Pragma, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state69(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Query, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state70(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Recursive, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state71(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Reindex, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state72(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Release, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state73(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rename, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state74(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Replace, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state75(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Restrict, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state76(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Right, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state77(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rollback, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state78(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Row, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state79(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Savepoint, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state80(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Temp, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state81(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Trigger, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state82(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Vacuum, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state83(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::View, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state84(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Virtual, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state85(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Without, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state86(text, __tokens, __sym7, ::std::marker::PhantomData::<(&())>)?;
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym6.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cColName_3e_20_22_2c_22_29_2b(__sym7) => {
                    __result = __state245(text, __tokens, __lookahead, __sym7, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::ColName(__sym7) => {
                    __result = __state246(text, __tokens, __lookahead, __sym7, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::CommaList_3cColName_3e(__sym7) => {
                    __result = __state274(text, __tokens, __lookahead, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                __Nonterminal::Id(__sym7) => {
                    __result = __state29(text, __tokens, __lookahead, __sym7, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Name(__sym7) => {
                    __result = __state141(text, __tokens, __lookahead, __sym7, ::std::marker::PhantomData::<(&())>)?;
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state243<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        __sym3: (usize, Tok<'input>, usize),
        __sym4: (usize, Tok<'input>, usize),
        __sym5: (usize, Tok<'input>, usize),
        __sym6: (usize, Name, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((_, Tok::Semi, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym6.2.clone();
                let __nt = super::__action38::<>(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6);
                let __nt = __Nonterminal::AlterStmt((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"";""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym6.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state244<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        __sym3: (usize, Tok<'input>, usize),
        __sym4: (usize, Tok<'input>, usize),
        __sym5: (usize, Tok<'input>, usize),
        __sym6: (usize, Name, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((_, Tok::Semi, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym6.2.clone();
                let __nt = super::__action36::<>(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6);
                let __nt = __Nonterminal::AlterStmt((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"";""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym6.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state245<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, ::std::vec::Vec<Name>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, Tok::Id(__tok0), __loc2)) => {
                let __sym1 = (__loc1, (__tok0), __loc2);
                __result = __state32(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Abort, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state33(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Action, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state34(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::After, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state35(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Analyze, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state36(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Asc, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state37(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Attach, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state38(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Before, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state39(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Begin, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state40(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::By, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state41(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cascade, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state42(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Conflict, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state43(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cross, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state44(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Deferred, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state45(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Desc, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state46(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Detach, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state47(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Each, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state48(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::End, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state49(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Exclusive, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state50(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Explain, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state51(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Fail, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state52(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::For, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state53(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::If, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state54(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Ignore, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state55(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Immediate, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state56(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Indexed, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state57(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Initially, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state58(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Inner, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state59(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Instead, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state60(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Key, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state61(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Left, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state62(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Natural, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state63(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::No, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state64(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Of, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state65(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Offset, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state66(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Outer, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state67(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Plan, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state68(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Pragma, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state69(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Query, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state70(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Recursive, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state71(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Reindex, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state72(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Release, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state73(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rename, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state74(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Replace, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state75(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Restrict, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state76(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Right, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state77(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rollback, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state78(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Row, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state79(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Savepoint, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state80(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Temp, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state81(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Trigger, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state82(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Vacuum, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state83(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::View, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state84(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Virtual, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state85(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Without, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state86(text, __tokens, __sym1, ::std::marker::PhantomData::<(&())>)?;
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::ColName(__sym1) => {
                    __result = __state275(text, __tokens, __lookahead, __sym0, __sym1, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                __Nonterminal::Id(__sym1) => {
                    __result = __state29(text, __tokens, __lookahead, __sym1, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Name(__sym1) => {
                    __result = __state141(text, __tokens, __lookahead, __sym1, ::std::marker::PhantomData::<(&())>)?;
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state246<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Name, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, __tok @ Tok::Comma, __loc2)) => {
                let __sym1 = (__loc1, (__tok), __loc2);
                __result = __state276(text, __tokens, __sym0, __sym1, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            Some((_, Tok::RightParen, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action226::<>(text, __sym0);
                let __nt = __Nonterminal::CommaList_3cColName_3e((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state247<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        __sym3: (usize, Tok<'input>, usize),
        __sym4: (usize, Name, usize),
        __sym5: (usize, Tok<'input>, usize),
        __sym6: (usize, Vec<Name>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, __tok @ Tok::RightParen, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state277(text, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"")""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym6.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state248<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, ::std::vec::Vec<Field>, usize),
        __sym1: (usize, Field, usize),
        __sym2: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::Foreign, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Primary, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym2.2.clone();
                let __nt = super::__action233::<>(text, __sym0, __sym1, __sym2);
                let __nt = __Nonterminal::_28_3cField_3e_20_22_2c_22_29_2b((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""foreign""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""primary""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym2.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state249<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, Tok::Id(__tok0), __loc2)) => {
                let __sym3 = (__loc1, (__tok0), __loc2);
                __result = __state32(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Abort, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state33(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Action, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state34(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::After, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state35(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Analyze, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state36(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Asc, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state37(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Attach, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state38(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Before, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state39(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Begin, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state40(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::By, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state41(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cascade, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state42(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Conflict, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state43(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cross, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state44(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Deferred, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state45(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Desc, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state46(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Detach, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state47(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Each, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state48(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::End, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state49(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Exclusive, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state50(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Explain, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state51(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Fail, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state52(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::For, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state53(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::If, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state54(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Ignore, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state55(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Immediate, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state56(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Indexed, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state57(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Initially, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state58(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Inner, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state59(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Instead, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state60(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Key, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state61(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Left, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state62(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Natural, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state63(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::No, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state64(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Of, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state65(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Offset, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state66(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Outer, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state67(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Plan, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state68(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Pragma, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state69(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Query, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state70(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Recursive, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state71(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Reindex, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state72(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Release, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state73(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rename, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state74(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Replace, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state75(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Restrict, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state76(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Right, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state77(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rollback, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state78(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Row, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state79(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Savepoint, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state80(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Temp, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state81(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Trigger, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state82(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Vacuum, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state83(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::View, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state84(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Virtual, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state85(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Without, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state86(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym2.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cColName_3e_20_22_2c_22_29_2b(__sym3) => {
                    __result = __state245(text, __tokens, __lookahead, __sym3, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::ColName(__sym3) => {
                    __result = __state246(text, __tokens, __lookahead, __sym3, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::CommaList_3cColName_3e(__sym3) => {
                    __result = __state278(text, __tokens, __lookahead, __sym0, __sym1, __sym2, __sym3, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                __Nonterminal::Id(__sym3) => {
                    __result = __state29(text, __tokens, __lookahead, __sym3, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Name(__sym3) => {
                    __result = __state141(text, __tokens, __lookahead, __sym3, ::std::marker::PhantomData::<(&())>)?;
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state250<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, Tok::Id(__tok0), __loc2)) => {
                let __sym3 = (__loc1, (__tok0), __loc2);
                __result = __state32(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Abort, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state33(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Action, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state34(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::After, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state35(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Analyze, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state36(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Asc, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state37(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Attach, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state38(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Before, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state39(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Begin, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state40(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::By, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state41(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cascade, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state42(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Conflict, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state43(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cross, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state44(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Deferred, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state45(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Desc, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state46(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Detach, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state47(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Each, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state48(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::End, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state49(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Exclusive, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state50(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Explain, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state51(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Fail, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state52(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::For, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state53(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::If, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state54(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Ignore, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state55(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Immediate, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state56(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Indexed, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state57(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Initially, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state58(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Inner, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state59(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Instead, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state60(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Key, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state61(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Left, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state62(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Natural, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state63(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::No, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state64(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Of, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state65(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Offset, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state66(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Outer, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state67(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Plan, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state68(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Pragma, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state69(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Query, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state70(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Recursive, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state71(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Reindex, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state72(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Release, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state73(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rename, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state74(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Replace, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state75(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Restrict, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state76(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Right, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state77(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rollback, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state78(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Row, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state79(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Savepoint, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state80(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Temp, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state81(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Trigger, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state82(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Vacuum, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state83(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::View, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state84(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Virtual, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state85(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Without, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state86(text, __tokens, __sym3, ::std::marker::PhantomData::<(&())>)?;
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym2.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cColName_3e_20_22_2c_22_29_2b(__sym3) => {
                    __result = __state245(text, __tokens, __lookahead, __sym3, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::ColName(__sym3) => {
                    __result = __state246(text, __tokens, __lookahead, __sym3, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::CommaList_3cColName_3e(__sym3) => {
                    __result = __state279(text, __tokens, __lookahead, __sym0, __sym1, __sym2, __sym3, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                __Nonterminal::Id(__sym3) => {
                    __result = __state29(text, __tokens, __lookahead, __sym3, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Name(__sym3) => {
                    __result = __state141(text, __tokens, __lookahead, __sym3, ::std::marker::PhantomData::<(&())>)?;
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state251<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, ::std::vec::Vec<WhereClause>, usize),
        __sym1: (usize, WhereClause, usize),
        __sym2: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym2.2.clone();
                let __nt = super::__action256::<>(text, __sym0, __sym1, __sym2);
                let __nt = __Nonterminal::_28_3cWhereClause_3e_20_22and_22_29_2b((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym2.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state252<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Column, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::And, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action54::<>(text, __sym0);
                let __nt = __Nonterminal::Expr((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"";""###.to_string(),
                    r###""and""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state253<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Column, usize),
        __sym1: (usize, Op, usize),
        __sym2: (usize, Expr, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::And, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym2.2.clone();
                let __nt = super::__action45::<>(text, __sym0, __sym1, __sym2);
                let __nt = __Nonterminal::WhereClause((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"";""###.to_string(),
                    r###""and""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym2.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state254<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Value, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::And, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action53::<>(text, __sym0);
                let __nt = __Nonterminal::Expr((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"";""###.to_string(),
                    r###""and""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym0.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state255<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Column, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, __tok @ Tok::Null, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state280(text, __tokens, __sym0, __sym1, __sym2, __sym3, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""null""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym2.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state256<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Column, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::And, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym2.2.clone();
                let __nt = super::__action208::<>(text, __sym0, __sym1, __sym2);
                let __nt = __Nonterminal::WhereClause((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"";""###.to_string(),
                    r###""and""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym2.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state257<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, ::std::vec::Vec<Vec<Value>>, usize),
        __sym1: (usize, Vec<Value>, usize),
        __sym2: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::LeftParen, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym2.2.clone();
                let __nt = super::__action252::<>(text, __sym0, __sym1, __sym2);
                let __nt = __Nonterminal::_28_3cValueList_3e_20_22_2c_22_29_2b((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym2.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state258<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, ::std::vec::Vec<Value>, usize),
        __sym1: (usize, Value, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, __tok @ Tok::Comma, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state281(text, __tokens, __sym0, __sym1, __sym2, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            Some((_, Tok::RightParen, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym1.2.clone();
                let __nt = super::__action250::<>(text, __sym0, __sym1);
                let __nt = __Nonterminal::CommaList_3cValue_3e((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym1.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state259<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Vec<Value>, usize),
        __sym2: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym2.2.clone();
                let __nt = super::__action61::<>(text, __sym0, __sym1, __sym2);
                let __nt = __Nonterminal::ValueList((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"",""###.to_string(),
                    r###"";""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym2.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state260<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Value, usize),
        __sym1: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Minus, _)) |
            Some((_, Tok::Float(_), _)) |
            Some((_, Tok::Integer(_), _)) |
            Some((_, Tok::StringLiteralDoubleQuote(_), _)) |
            Some((_, Tok::StringLiteralSingleQuote(_), _)) |
            Some((_, Tok::Null, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym1.2.clone();
                let __nt = super::__action247::<>(text, __sym0, __sym1);
                let __nt = __Nonterminal::_28_3cValue_3e_20_22_2c_22_29_2b((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""+""###.to_string(),
                    r###""-""###.to_string(),
                    r###""Float""###.to_string(),
                    r###""Integer""###.to_string(),
                    r###""StringLiteralDoubleQuote""###.to_string(),
                    r###""StringLiteralSingleQuote""###.to_string(),
                    r###""null""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym1.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state261<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, &'input str, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Where, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym1.2.clone();
                let __nt = super::__action205::<>(text, __sym0, __sym1);
                let __nt = __Nonterminal::Value((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"";""###.to_string(),
                    r###""and""###.to_string(),
                    r###""where""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym1.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state262<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, &'input str, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Where, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym1.2.clone();
                let __nt = super::__action203::<>(text, __sym0, __sym1);
                let __nt = __Nonterminal::Value((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"";""###.to_string(),
                    r###""and""###.to_string(),
                    r###""where""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym1.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state263<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, &'input str, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Where, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym1.2.clone();
                let __nt = super::__action68::<>(text, __sym0, __sym1);
                let __nt = __Nonterminal::Value((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"";""###.to_string(),
                    r###""and""###.to_string(),
                    r###""where""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym1.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state264<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, &'input str, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::And, _)) |
            Some((_, Tok::Where, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym1.2.clone();
                let __nt = super::__action66::<>(text, __sym0, __sym1);
                let __nt = __Nonterminal::Value((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"";""###.to_string(),
                    r###""and""###.to_string(),
                    r###""where""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym1.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state265<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Name, usize),
        __sym1: (usize, Type, usize),
        __sym2: (usize, Tok<'input>, usize),
        __sym3: (usize, Value, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym3.2.clone();
                let __nt = super::__action214::<>(text, __sym0, __sym1, __sym2, __sym3);
                let __nt = __Nonterminal::ColumnField((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"";""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym3.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state266<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Name, usize),
        __sym1: (usize, Type, usize),
        __sym2: (usize, Tok<'input>, usize),
        __sym3: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, __tok @ Tok::Default, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state282(text, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym3.2.clone();
                let __nt = super::__action215::<>(text, __sym0, __sym1, __sym2, __sym3);
                let __nt = __Nonterminal::ColumnField((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"";""###.to_string(),
                    r###""default""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym3.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state267<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, &'input str, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, __tok @ Tok::RightParen, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state283(text, __tokens, __sym0, __sym1, __sym2, __sym3, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"")""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym2.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state268<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, &'input str, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, __tok @ Tok::RightParen, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state284(text, __tokens, __sym0, __sym1, __sym2, __sym3, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"")""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym2.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state269<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, &'input str, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, __tok @ Tok::Comma, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state285(text, __tokens, __sym0, __sym1, __sym2, __sym3, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"",""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym2.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state270<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, &'input str, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, __tok @ Tok::RightParen, __loc2)) => {
                let __sym3 = (__loc1, (__tok), __loc2);
                __result = __state286(text, __tokens, __sym0, __sym1, __sym2, __sym3, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"")""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym2.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state271<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        __sym3: (usize, Tok<'input>, usize),
        __sym4: (usize, Tok<'input>, usize),
        __sym5: (usize, Name, usize),
        __sym6: (usize, Tok<'input>, usize),
        __sym7: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, __tok @ Tok::LeftParen, __loc2)) => {
                let __sym8 = (__loc1, (__tok), __loc2);
                __result = __state287(text, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7, __sym8, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym7.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state272<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        __sym3: (usize, Tok<'input>, usize),
        __sym4: (usize, Tok<'input>, usize),
        __sym5: (usize, Name, usize),
        __sym6: (usize, Tok<'input>, usize),
        __sym7: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, __tok @ Tok::LeftParen, __loc2)) => {
                let __sym8 = (__loc1, (__tok), __loc2);
                __result = __state288(text, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7, __sym8, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym7.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state273<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        __sym3: (usize, Tok<'input>, usize),
        __sym4: (usize, Tok<'input>, usize),
        __sym5: (usize, Name, usize),
        __sym6: (usize, Tok<'input>, usize),
        __sym7: (usize, Vec<Name>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, __tok @ Tok::RightParen, __loc2)) => {
                let __sym8 = (__loc1, (__tok), __loc2);
                __result = __state289(text, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7, __sym8, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"")""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym7.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state274<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        __sym3: (usize, Tok<'input>, usize),
        __sym4: (usize, Tok<'input>, usize),
        __sym5: (usize, Tok<'input>, usize),
        __sym6: (usize, Tok<'input>, usize),
        __sym7: (usize, Vec<Name>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, __tok @ Tok::RightParen, __loc2)) => {
                let __sym8 = (__loc1, (__tok), __loc2);
                __result = __state290(text, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7, __sym8, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"")""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym7.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state275<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, ::std::vec::Vec<Name>, usize),
        __sym1: (usize, Name, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, __tok @ Tok::Comma, __loc2)) => {
                let __sym2 = (__loc1, (__tok), __loc2);
                __result = __state291(text, __tokens, __sym0, __sym1, __sym2, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            Some((_, Tok::RightParen, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym1.2.clone();
                let __nt = super::__action227::<>(text, __sym0, __sym1);
                let __nt = __Nonterminal::CommaList_3cColName_3e((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym1.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state276<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Name, usize),
        __sym1: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym1.2.clone();
                let __nt = super::__action224::<>(text, __sym0, __sym1);
                let __nt = __Nonterminal::_28_3cColName_3e_20_22_2c_22_29_2b((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym1.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state277<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        __sym3: (usize, Tok<'input>, usize),
        __sym4: (usize, Name, usize),
        __sym5: (usize, Tok<'input>, usize),
        __sym6: (usize, Vec<Name>, usize),
        __sym7: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::Semi, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym7.2.clone();
                let __nt = super::__action25::<>(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7);
                let __nt = __Nonterminal::IndexStmt((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"";""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym7.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state278<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Tok<'input>, usize),
        __sym3: (usize, Vec<Name>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, __tok @ Tok::RightParen, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state292(text, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"")""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym3.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state279<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Tok<'input>, usize),
        __sym3: (usize, Vec<Name>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, __tok @ Tok::RightParen, __loc2)) => {
                let __sym4 = (__loc1, (__tok), __loc2);
                __result = __state293(text, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"")""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym3.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state280<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Column, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Tok<'input>, usize),
        __sym3: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::And, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym3.2.clone();
                let __nt = super::__action207::<>(text, __sym0, __sym1, __sym2, __sym3);
                let __nt = __Nonterminal::WhereClause((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"";""###.to_string(),
                    r###""and""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym3.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state281<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, ::std::vec::Vec<Value>, usize),
        __sym1: (usize, Value, usize),
        __sym2: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Minus, _)) |
            Some((_, Tok::Float(_), _)) |
            Some((_, Tok::Integer(_), _)) |
            Some((_, Tok::StringLiteralDoubleQuote(_), _)) |
            Some((_, Tok::StringLiteralSingleQuote(_), _)) |
            Some((_, Tok::Null, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym2.2.clone();
                let __nt = super::__action248::<>(text, __sym0, __sym1, __sym2);
                let __nt = __Nonterminal::_28_3cValue_3e_20_22_2c_22_29_2b((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""+""###.to_string(),
                    r###""-""###.to_string(),
                    r###""Float""###.to_string(),
                    r###""Integer""###.to_string(),
                    r###""StringLiteralDoubleQuote""###.to_string(),
                    r###""StringLiteralSingleQuote""###.to_string(),
                    r###""null""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym2.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state282<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Name, usize),
        __sym1: (usize, Type, usize),
        __sym2: (usize, Tok<'input>, usize),
        __sym3: (usize, Tok<'input>, usize),
        __sym4: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, __tok @ Tok::Plus, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state221(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Minus, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state222(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, Tok::Float(__tok0), __loc2)) => {
                let __sym5 = (__loc1, (__tok0), __loc2);
                __result = __state223(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, Tok::Integer(__tok0), __loc2)) => {
                let __sym5 = (__loc1, (__tok0), __loc2);
                __result = __state224(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, Tok::StringLiteralDoubleQuote(__tok0), __loc2)) => {
                let __sym5 = (__loc1, (__tok0), __loc2);
                __result = __state225(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, Tok::StringLiteralSingleQuote(__tok0), __loc2)) => {
                let __sym5 = (__loc1, (__tok0), __loc2);
                __result = __state226(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Null, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state227(text, __tokens, __sym5, ::std::marker::PhantomData::<(&())>)?;
            }
            _ => {
                let __expected = vec![
                    r###""+""###.to_string(),
                    r###""-""###.to_string(),
                    r###""Float""###.to_string(),
                    r###""Integer""###.to_string(),
                    r###""StringLiteralDoubleQuote""###.to_string(),
                    r###""StringLiteralSingleQuote""###.to_string(),
                    r###""null""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym4.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Value(__sym5) => {
                    __result = __state294(text, __tokens, __lookahead, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state283<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, &'input str, usize),
        __sym3: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::Default, _)) |
            Some((_, Tok::Not, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym3.2.clone();
                let __nt = super::__action74::<>(text, __sym0, __sym1, __sym2, __sym3);
                let __nt = __Nonterminal::Type((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"";""###.to_string(),
                    r###""default""###.to_string(),
                    r###""not""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym3.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state284<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, &'input str, usize),
        __sym3: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::Default, _)) |
            Some((_, Tok::Not, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym3.2.clone();
                let __nt = super::__action69::<>(text, __sym0, __sym1, __sym2, __sym3);
                let __nt = __Nonterminal::Type((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"";""###.to_string(),
                    r###""default""###.to_string(),
                    r###""not""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym3.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state285<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, &'input str, usize),
        __sym3: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, Tok::Integer(__tok0), __loc2)) => {
                let __sym4 = (__loc1, (__tok0), __loc2);
                __result = __state295(text, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""Integer""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym3.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state286<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, &'input str, usize),
        __sym3: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::Default, _)) |
            Some((_, Tok::Not, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym3.2.clone();
                let __nt = super::__action73::<>(text, __sym0, __sym1, __sym2, __sym3);
                let __nt = __Nonterminal::Type((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"";""###.to_string(),
                    r###""default""###.to_string(),
                    r###""not""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym3.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state287<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        __sym3: (usize, Tok<'input>, usize),
        __sym4: (usize, Tok<'input>, usize),
        __sym5: (usize, Name, usize),
        __sym6: (usize, Tok<'input>, usize),
        __sym7: (usize, Tok<'input>, usize),
        __sym8: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, Tok::Id(__tok0), __loc2)) => {
                let __sym9 = (__loc1, (__tok0), __loc2);
                __result = __state32(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Abort, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state33(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Action, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state34(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::After, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state35(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Analyze, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state36(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Asc, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state37(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Attach, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state38(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Before, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state39(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Begin, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state40(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::By, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state41(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cascade, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state42(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Conflict, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state43(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cross, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state44(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Deferred, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state45(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Desc, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state46(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Detach, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state47(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Each, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state48(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::End, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state49(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Exclusive, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state50(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Explain, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state51(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Fail, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state52(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::For, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state53(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::If, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state54(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Ignore, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state55(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Immediate, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state56(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Indexed, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state57(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Initially, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state58(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Inner, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state59(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Instead, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state60(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Key, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state61(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Left, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state62(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Natural, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state63(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::No, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state64(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Of, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state65(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Offset, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state66(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Outer, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state67(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Plan, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state68(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Pragma, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state69(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Query, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state70(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Recursive, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state71(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Reindex, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state72(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Release, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state73(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rename, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state74(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Replace, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state75(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Restrict, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state76(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Right, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state77(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rollback, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state78(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Row, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state79(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Savepoint, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state80(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Temp, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state81(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Trigger, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state82(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Vacuum, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state83(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::View, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state84(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Virtual, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state85(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Without, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state86(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym8.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cColName_3e_20_22_2c_22_29_2b(__sym9) => {
                    __result = __state245(text, __tokens, __lookahead, __sym9, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::ColName(__sym9) => {
                    __result = __state246(text, __tokens, __lookahead, __sym9, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::CommaList_3cColName_3e(__sym9) => {
                    __result = __state296(text, __tokens, __lookahead, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7, __sym8, __sym9, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                __Nonterminal::Id(__sym9) => {
                    __result = __state29(text, __tokens, __lookahead, __sym9, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Name(__sym9) => {
                    __result = __state141(text, __tokens, __lookahead, __sym9, ::std::marker::PhantomData::<(&())>)?;
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state288<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        __sym3: (usize, Tok<'input>, usize),
        __sym4: (usize, Tok<'input>, usize),
        __sym5: (usize, Name, usize),
        __sym6: (usize, Tok<'input>, usize),
        __sym7: (usize, Tok<'input>, usize),
        __sym8: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, Tok::Id(__tok0), __loc2)) => {
                let __sym9 = (__loc1, (__tok0), __loc2);
                __result = __state32(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Abort, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state33(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Action, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state34(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::After, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state35(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Analyze, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state36(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Asc, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state37(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Attach, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state38(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Before, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state39(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Begin, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state40(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::By, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state41(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cascade, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state42(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Conflict, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state43(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cross, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state44(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Deferred, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state45(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Desc, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state46(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Detach, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state47(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Each, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state48(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::End, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state49(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Exclusive, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state50(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Explain, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state51(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Fail, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state52(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::For, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state53(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::If, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state54(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Ignore, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state55(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Immediate, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state56(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Indexed, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state57(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Initially, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state58(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Inner, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state59(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Instead, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state60(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Key, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state61(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Left, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state62(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Natural, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state63(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::No, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state64(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Of, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state65(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Offset, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state66(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Outer, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state67(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Plan, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state68(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Pragma, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state69(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Query, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state70(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Recursive, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state71(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Reindex, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state72(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Release, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state73(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rename, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state74(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Replace, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state75(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Restrict, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state76(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Right, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state77(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rollback, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state78(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Row, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state79(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Savepoint, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state80(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Temp, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state81(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Trigger, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state82(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Vacuum, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state83(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::View, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state84(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Virtual, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state85(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Without, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state86(text, __tokens, __sym9, ::std::marker::PhantomData::<(&())>)?;
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym8.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cColName_3e_20_22_2c_22_29_2b(__sym9) => {
                    __result = __state245(text, __tokens, __lookahead, __sym9, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::ColName(__sym9) => {
                    __result = __state246(text, __tokens, __lookahead, __sym9, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::CommaList_3cColName_3e(__sym9) => {
                    __result = __state297(text, __tokens, __lookahead, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7, __sym8, __sym9, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                __Nonterminal::Id(__sym9) => {
                    __result = __state29(text, __tokens, __lookahead, __sym9, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Name(__sym9) => {
                    __result = __state141(text, __tokens, __lookahead, __sym9, ::std::marker::PhantomData::<(&())>)?;
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state289<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        __sym3: (usize, Tok<'input>, usize),
        __sym4: (usize, Tok<'input>, usize),
        __sym5: (usize, Name, usize),
        __sym6: (usize, Tok<'input>, usize),
        __sym7: (usize, Vec<Name>, usize),
        __sym8: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::Semi, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym8.2.clone();
                let __nt = super::__action27::<>(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7, __sym8);
                let __nt = __Nonterminal::IndexStmt((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"";""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym8.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state290<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        __sym3: (usize, Tok<'input>, usize),
        __sym4: (usize, Tok<'input>, usize),
        __sym5: (usize, Tok<'input>, usize),
        __sym6: (usize, Tok<'input>, usize),
        __sym7: (usize, Vec<Name>, usize),
        __sym8: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::Semi, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym8.2.clone();
                let __nt = super::__action33::<>(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7, __sym8);
                let __nt = __Nonterminal::AlterStmt((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"";""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym8.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state291<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, ::std::vec::Vec<Name>, usize),
        __sym1: (usize, Name, usize),
        __sym2: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Abort, _)) |
            Some((_, Tok::Action, _)) |
            Some((_, Tok::After, _)) |
            Some((_, Tok::Analyze, _)) |
            Some((_, Tok::Asc, _)) |
            Some((_, Tok::Attach, _)) |
            Some((_, Tok::Before, _)) |
            Some((_, Tok::Begin, _)) |
            Some((_, Tok::By, _)) |
            Some((_, Tok::Cascade, _)) |
            Some((_, Tok::Conflict, _)) |
            Some((_, Tok::Cross, _)) |
            Some((_, Tok::Deferred, _)) |
            Some((_, Tok::Desc, _)) |
            Some((_, Tok::Detach, _)) |
            Some((_, Tok::Each, _)) |
            Some((_, Tok::End, _)) |
            Some((_, Tok::Exclusive, _)) |
            Some((_, Tok::Explain, _)) |
            Some((_, Tok::Fail, _)) |
            Some((_, Tok::For, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::Ignore, _)) |
            Some((_, Tok::Immediate, _)) |
            Some((_, Tok::Indexed, _)) |
            Some((_, Tok::Initially, _)) |
            Some((_, Tok::Inner, _)) |
            Some((_, Tok::Instead, _)) |
            Some((_, Tok::Key, _)) |
            Some((_, Tok::Left, _)) |
            Some((_, Tok::Natural, _)) |
            Some((_, Tok::No, _)) |
            Some((_, Tok::Of, _)) |
            Some((_, Tok::Offset, _)) |
            Some((_, Tok::Outer, _)) |
            Some((_, Tok::Plan, _)) |
            Some((_, Tok::Pragma, _)) |
            Some((_, Tok::Query, _)) |
            Some((_, Tok::Recursive, _)) |
            Some((_, Tok::Reindex, _)) |
            Some((_, Tok::Release, _)) |
            Some((_, Tok::Rename, _)) |
            Some((_, Tok::Replace, _)) |
            Some((_, Tok::Restrict, _)) |
            Some((_, Tok::Right, _)) |
            Some((_, Tok::Rollback, _)) |
            Some((_, Tok::Row, _)) |
            Some((_, Tok::Savepoint, _)) |
            Some((_, Tok::Temp, _)) |
            Some((_, Tok::Trigger, _)) |
            Some((_, Tok::Vacuum, _)) |
            Some((_, Tok::View, _)) |
            Some((_, Tok::Virtual, _)) |
            Some((_, Tok::Without, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym2.2.clone();
                let __nt = super::__action225::<>(text, __sym0, __sym1, __sym2);
                let __nt = __Nonterminal::_28_3cColName_3e_20_22_2c_22_29_2b((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym2.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state292<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Tok<'input>, usize),
        __sym3: (usize, Vec<Name>, usize),
        __sym4: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, __tok @ Tok::References, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state298(text, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""references""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym4.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state293<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Tok<'input>, usize),
        __sym3: (usize, Vec<Name>, usize),
        __sym4: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym4.2.clone();
                let __nt = super::__action56::<>(text, __sym0, __sym1, __sym2, __sym3, __sym4);
                let __nt = __Nonterminal::PrimaryKeyField((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym4.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state294<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Name, usize),
        __sym1: (usize, Type, usize),
        __sym2: (usize, Tok<'input>, usize),
        __sym3: (usize, Tok<'input>, usize),
        __sym4: (usize, Tok<'input>, usize),
        __sym5: (usize, Value, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym5.2.clone();
                let __nt = super::__action213::<>(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5);
                let __nt = __Nonterminal::ColumnField((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"";""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym5.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state295<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, &'input str, usize),
        __sym3: (usize, Tok<'input>, usize),
        __sym4: (usize, &'input str, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, __tok @ Tok::RightParen, __loc2)) => {
                let __sym5 = (__loc1, (__tok), __loc2);
                __result = __state299(text, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"")""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym4.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state296<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        __sym3: (usize, Tok<'input>, usize),
        __sym4: (usize, Tok<'input>, usize),
        __sym5: (usize, Name, usize),
        __sym6: (usize, Tok<'input>, usize),
        __sym7: (usize, Tok<'input>, usize),
        __sym8: (usize, Tok<'input>, usize),
        __sym9: (usize, Vec<Name>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, __tok @ Tok::RightParen, __loc2)) => {
                let __sym10 = (__loc1, (__tok), __loc2);
                __result = __state300(text, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7, __sym8, __sym9, __sym10, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"")""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym9.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state297<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        __sym3: (usize, Tok<'input>, usize),
        __sym4: (usize, Tok<'input>, usize),
        __sym5: (usize, Name, usize),
        __sym6: (usize, Tok<'input>, usize),
        __sym7: (usize, Tok<'input>, usize),
        __sym8: (usize, Tok<'input>, usize),
        __sym9: (usize, Vec<Name>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, __tok @ Tok::RightParen, __loc2)) => {
                let __sym10 = (__loc1, (__tok), __loc2);
                __result = __state301(text, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7, __sym8, __sym9, __sym10, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"")""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym9.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state298<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Tok<'input>, usize),
        __sym3: (usize, Vec<Name>, usize),
        __sym4: (usize, Tok<'input>, usize),
        __sym5: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, Tok::Id(__tok0), __loc2)) => {
                let __sym6 = (__loc1, (__tok0), __loc2);
                __result = __state32(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Abort, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state33(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Action, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state34(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::After, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state35(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Analyze, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state36(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Asc, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state37(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Attach, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state38(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Before, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state39(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Begin, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state40(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::By, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state41(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cascade, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state42(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Conflict, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state43(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cross, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state44(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Deferred, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state45(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Desc, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state46(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Detach, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state47(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Each, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state48(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::End, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state49(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Exclusive, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state50(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Explain, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state51(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Fail, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state52(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::For, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state53(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::If, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state54(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Ignore, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state55(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Immediate, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state56(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Indexed, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state57(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Initially, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state58(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Inner, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state59(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Instead, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state60(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Key, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state61(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Left, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state62(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Natural, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state63(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::No, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state64(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Of, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state65(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Offset, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state66(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Outer, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state67(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Plan, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state68(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Pragma, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state69(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Query, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state70(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Recursive, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state71(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Reindex, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state72(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Release, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state73(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rename, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state74(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Replace, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state75(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Restrict, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state76(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Right, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state77(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rollback, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state78(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Row, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state79(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Savepoint, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state80(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Temp, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state81(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Trigger, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state82(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Vacuum, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state83(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::View, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state84(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Virtual, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state85(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Without, __loc2)) => {
                let __sym6 = (__loc1, (__tok), __loc2);
                __result = __state86(text, __tokens, __sym6, ::std::marker::PhantomData::<(&())>)?;
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym5.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Id(__sym6) => {
                    __result = __state29(text, __tokens, __lookahead, __sym6, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Name(__sym6) => {
                    __result = __state30(text, __tokens, __lookahead, __sym6, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::TableName(__sym6) => {
                    __result = __state302(text, __tokens, __lookahead, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state299<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, &'input str, usize),
        __sym3: (usize, Tok<'input>, usize),
        __sym4: (usize, &'input str, usize),
        __sym5: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::Default, _)) |
            Some((_, Tok::Not, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym5.2.clone();
                let __nt = super::__action75::<>(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5);
                let __nt = __Nonterminal::Type((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                    r###"";""###.to_string(),
                    r###""default""###.to_string(),
                    r###""not""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym5.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state300<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        __sym3: (usize, Tok<'input>, usize),
        __sym4: (usize, Tok<'input>, usize),
        __sym5: (usize, Name, usize),
        __sym6: (usize, Tok<'input>, usize),
        __sym7: (usize, Tok<'input>, usize),
        __sym8: (usize, Tok<'input>, usize),
        __sym9: (usize, Vec<Name>, usize),
        __sym10: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, __tok @ Tok::References, __loc2)) => {
                let __sym11 = (__loc1, (__tok), __loc2);
                __result = __state303(text, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7, __sym8, __sym9, __sym10, __sym11, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""references""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym10.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state301<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        __sym3: (usize, Tok<'input>, usize),
        __sym4: (usize, Tok<'input>, usize),
        __sym5: (usize, Name, usize),
        __sym6: (usize, Tok<'input>, usize),
        __sym7: (usize, Tok<'input>, usize),
        __sym8: (usize, Tok<'input>, usize),
        __sym9: (usize, Vec<Name>, usize),
        __sym10: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::Semi, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym10.2.clone();
                let __nt = super::__action35::<>(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7, __sym8, __sym9, __sym10);
                let __nt = __Nonterminal::AlterStmt((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"";""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym10.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state302<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Tok<'input>, usize),
        __sym3: (usize, Vec<Name>, usize),
        __sym4: (usize, Tok<'input>, usize),
        __sym5: (usize, Tok<'input>, usize),
        __sym6: (usize, Name, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, __tok @ Tok::LeftParen, __loc2)) => {
                let __sym7 = (__loc1, (__tok), __loc2);
                __result = __state304(text, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym6.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state303<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        __sym3: (usize, Tok<'input>, usize),
        __sym4: (usize, Tok<'input>, usize),
        __sym5: (usize, Name, usize),
        __sym6: (usize, Tok<'input>, usize),
        __sym7: (usize, Tok<'input>, usize),
        __sym8: (usize, Tok<'input>, usize),
        __sym9: (usize, Vec<Name>, usize),
        __sym10: (usize, Tok<'input>, usize),
        __sym11: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, Tok::Id(__tok0), __loc2)) => {
                let __sym12 = (__loc1, (__tok0), __loc2);
                __result = __state32(text, __tokens, __sym12, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Abort, __loc2)) => {
                let __sym12 = (__loc1, (__tok), __loc2);
                __result = __state33(text, __tokens, __sym12, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Action, __loc2)) => {
                let __sym12 = (__loc1, (__tok), __loc2);
                __result = __state34(text, __tokens, __sym12, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::After, __loc2)) => {
                let __sym12 = (__loc1, (__tok), __loc2);
                __result = __state35(text, __tokens, __sym12, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Analyze, __loc2)) => {
                let __sym12 = (__loc1, (__tok), __loc2);
                __result = __state36(text, __tokens, __sym12, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Asc, __loc2)) => {
                let __sym12 = (__loc1, (__tok), __loc2);
                __result = __state37(text, __tokens, __sym12, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Attach, __loc2)) => {
                let __sym12 = (__loc1, (__tok), __loc2);
                __result = __state38(text, __tokens, __sym12, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Before, __loc2)) => {
                let __sym12 = (__loc1, (__tok), __loc2);
                __result = __state39(text, __tokens, __sym12, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Begin, __loc2)) => {
                let __sym12 = (__loc1, (__tok), __loc2);
                __result = __state40(text, __tokens, __sym12, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::By, __loc2)) => {
                let __sym12 = (__loc1, (__tok), __loc2);
                __result = __state41(text, __tokens, __sym12, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cascade, __loc2)) => {
                let __sym12 = (__loc1, (__tok), __loc2);
                __result = __state42(text, __tokens, __sym12, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Conflict, __loc2)) => {
                let __sym12 = (__loc1, (__tok), __loc2);
                __result = __state43(text, __tokens, __sym12, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cross, __loc2)) => {
                let __sym12 = (__loc1, (__tok), __loc2);
                __result = __state44(text, __tokens, __sym12, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Deferred, __loc2)) => {
                let __sym12 = (__loc1, (__tok), __loc2);
                __result = __state45(text, __tokens, __sym12, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Desc, __loc2)) => {
                let __sym12 = (__loc1, (__tok), __loc2);
                __result = __state46(text, __tokens, __sym12, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Detach, __loc2)) => {
                let __sym12 = (__loc1, (__tok), __loc2);
                __result = __state47(text, __tokens, __sym12, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Each, __loc2)) => {
                let __sym12 = (__loc1, (__tok), __loc2);
                __result = __state48(text, __tokens, __sym12, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::End, __loc2)) => {
                let __sym12 = (__loc1, (__tok), __loc2);
                __result = __state49(text, __tokens, __sym12, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Exclusive, __loc2)) => {
                let __sym12 = (__loc1, (__tok), __loc2);
                __result = __state50(text, __tokens, __sym12, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Explain, __loc2)) => {
                let __sym12 = (__loc1, (__tok), __loc2);
                __result = __state51(text, __tokens, __sym12, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Fail, __loc2)) => {
                let __sym12 = (__loc1, (__tok), __loc2);
                __result = __state52(text, __tokens, __sym12, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::For, __loc2)) => {
                let __sym12 = (__loc1, (__tok), __loc2);
                __result = __state53(text, __tokens, __sym12, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::If, __loc2)) => {
                let __sym12 = (__loc1, (__tok), __loc2);
                __result = __state54(text, __tokens, __sym12, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Ignore, __loc2)) => {
                let __sym12 = (__loc1, (__tok), __loc2);
                __result = __state55(text, __tokens, __sym12, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Immediate, __loc2)) => {
                let __sym12 = (__loc1, (__tok), __loc2);
                __result = __state56(text, __tokens, __sym12, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Indexed, __loc2)) => {
                let __sym12 = (__loc1, (__tok), __loc2);
                __result = __state57(text, __tokens, __sym12, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Initially, __loc2)) => {
                let __sym12 = (__loc1, (__tok), __loc2);
                __result = __state58(text, __tokens, __sym12, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Inner, __loc2)) => {
                let __sym12 = (__loc1, (__tok), __loc2);
                __result = __state59(text, __tokens, __sym12, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Instead, __loc2)) => {
                let __sym12 = (__loc1, (__tok), __loc2);
                __result = __state60(text, __tokens, __sym12, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Key, __loc2)) => {
                let __sym12 = (__loc1, (__tok), __loc2);
                __result = __state61(text, __tokens, __sym12, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Left, __loc2)) => {
                let __sym12 = (__loc1, (__tok), __loc2);
                __result = __state62(text, __tokens, __sym12, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Natural, __loc2)) => {
                let __sym12 = (__loc1, (__tok), __loc2);
                __result = __state63(text, __tokens, __sym12, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::No, __loc2)) => {
                let __sym12 = (__loc1, (__tok), __loc2);
                __result = __state64(text, __tokens, __sym12, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Of, __loc2)) => {
                let __sym12 = (__loc1, (__tok), __loc2);
                __result = __state65(text, __tokens, __sym12, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Offset, __loc2)) => {
                let __sym12 = (__loc1, (__tok), __loc2);
                __result = __state66(text, __tokens, __sym12, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Outer, __loc2)) => {
                let __sym12 = (__loc1, (__tok), __loc2);
                __result = __state67(text, __tokens, __sym12, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Plan, __loc2)) => {
                let __sym12 = (__loc1, (__tok), __loc2);
                __result = __state68(text, __tokens, __sym12, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Pragma, __loc2)) => {
                let __sym12 = (__loc1, (__tok), __loc2);
                __result = __state69(text, __tokens, __sym12, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Query, __loc2)) => {
                let __sym12 = (__loc1, (__tok), __loc2);
                __result = __state70(text, __tokens, __sym12, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Recursive, __loc2)) => {
                let __sym12 = (__loc1, (__tok), __loc2);
                __result = __state71(text, __tokens, __sym12, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Reindex, __loc2)) => {
                let __sym12 = (__loc1, (__tok), __loc2);
                __result = __state72(text, __tokens, __sym12, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Release, __loc2)) => {
                let __sym12 = (__loc1, (__tok), __loc2);
                __result = __state73(text, __tokens, __sym12, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rename, __loc2)) => {
                let __sym12 = (__loc1, (__tok), __loc2);
                __result = __state74(text, __tokens, __sym12, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Replace, __loc2)) => {
                let __sym12 = (__loc1, (__tok), __loc2);
                __result = __state75(text, __tokens, __sym12, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Restrict, __loc2)) => {
                let __sym12 = (__loc1, (__tok), __loc2);
                __result = __state76(text, __tokens, __sym12, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Right, __loc2)) => {
                let __sym12 = (__loc1, (__tok), __loc2);
                __result = __state77(text, __tokens, __sym12, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rollback, __loc2)) => {
                let __sym12 = (__loc1, (__tok), __loc2);
                __result = __state78(text, __tokens, __sym12, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Row, __loc2)) => {
                let __sym12 = (__loc1, (__tok), __loc2);
                __result = __state79(text, __tokens, __sym12, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Savepoint, __loc2)) => {
                let __sym12 = (__loc1, (__tok), __loc2);
                __result = __state80(text, __tokens, __sym12, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Temp, __loc2)) => {
                let __sym12 = (__loc1, (__tok), __loc2);
                __result = __state81(text, __tokens, __sym12, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Trigger, __loc2)) => {
                let __sym12 = (__loc1, (__tok), __loc2);
                __result = __state82(text, __tokens, __sym12, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Vacuum, __loc2)) => {
                let __sym12 = (__loc1, (__tok), __loc2);
                __result = __state83(text, __tokens, __sym12, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::View, __loc2)) => {
                let __sym12 = (__loc1, (__tok), __loc2);
                __result = __state84(text, __tokens, __sym12, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Virtual, __loc2)) => {
                let __sym12 = (__loc1, (__tok), __loc2);
                __result = __state85(text, __tokens, __sym12, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Without, __loc2)) => {
                let __sym12 = (__loc1, (__tok), __loc2);
                __result = __state86(text, __tokens, __sym12, ::std::marker::PhantomData::<(&())>)?;
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym11.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Id(__sym12) => {
                    __result = __state29(text, __tokens, __lookahead, __sym12, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Name(__sym12) => {
                    __result = __state30(text, __tokens, __lookahead, __sym12, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::TableName(__sym12) => {
                    __result = __state305(text, __tokens, __lookahead, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7, __sym8, __sym9, __sym10, __sym11, __sym12, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state304<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Tok<'input>, usize),
        __sym3: (usize, Vec<Name>, usize),
        __sym4: (usize, Tok<'input>, usize),
        __sym5: (usize, Tok<'input>, usize),
        __sym6: (usize, Name, usize),
        __sym7: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, Tok::Id(__tok0), __loc2)) => {
                let __sym8 = (__loc1, (__tok0), __loc2);
                __result = __state32(text, __tokens, __sym8, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Abort, __loc2)) => {
                let __sym8 = (__loc1, (__tok), __loc2);
                __result = __state33(text, __tokens, __sym8, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Action, __loc2)) => {
                let __sym8 = (__loc1, (__tok), __loc2);
                __result = __state34(text, __tokens, __sym8, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::After, __loc2)) => {
                let __sym8 = (__loc1, (__tok), __loc2);
                __result = __state35(text, __tokens, __sym8, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Analyze, __loc2)) => {
                let __sym8 = (__loc1, (__tok), __loc2);
                __result = __state36(text, __tokens, __sym8, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Asc, __loc2)) => {
                let __sym8 = (__loc1, (__tok), __loc2);
                __result = __state37(text, __tokens, __sym8, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Attach, __loc2)) => {
                let __sym8 = (__loc1, (__tok), __loc2);
                __result = __state38(text, __tokens, __sym8, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Before, __loc2)) => {
                let __sym8 = (__loc1, (__tok), __loc2);
                __result = __state39(text, __tokens, __sym8, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Begin, __loc2)) => {
                let __sym8 = (__loc1, (__tok), __loc2);
                __result = __state40(text, __tokens, __sym8, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::By, __loc2)) => {
                let __sym8 = (__loc1, (__tok), __loc2);
                __result = __state41(text, __tokens, __sym8, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cascade, __loc2)) => {
                let __sym8 = (__loc1, (__tok), __loc2);
                __result = __state42(text, __tokens, __sym8, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Conflict, __loc2)) => {
                let __sym8 = (__loc1, (__tok), __loc2);
                __result = __state43(text, __tokens, __sym8, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cross, __loc2)) => {
                let __sym8 = (__loc1, (__tok), __loc2);
                __result = __state44(text, __tokens, __sym8, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Deferred, __loc2)) => {
                let __sym8 = (__loc1, (__tok), __loc2);
                __result = __state45(text, __tokens, __sym8, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Desc, __loc2)) => {
                let __sym8 = (__loc1, (__tok), __loc2);
                __result = __state46(text, __tokens, __sym8, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Detach, __loc2)) => {
                let __sym8 = (__loc1, (__tok), __loc2);
                __result = __state47(text, __tokens, __sym8, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Each, __loc2)) => {
                let __sym8 = (__loc1, (__tok), __loc2);
                __result = __state48(text, __tokens, __sym8, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::End, __loc2)) => {
                let __sym8 = (__loc1, (__tok), __loc2);
                __result = __state49(text, __tokens, __sym8, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Exclusive, __loc2)) => {
                let __sym8 = (__loc1, (__tok), __loc2);
                __result = __state50(text, __tokens, __sym8, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Explain, __loc2)) => {
                let __sym8 = (__loc1, (__tok), __loc2);
                __result = __state51(text, __tokens, __sym8, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Fail, __loc2)) => {
                let __sym8 = (__loc1, (__tok), __loc2);
                __result = __state52(text, __tokens, __sym8, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::For, __loc2)) => {
                let __sym8 = (__loc1, (__tok), __loc2);
                __result = __state53(text, __tokens, __sym8, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::If, __loc2)) => {
                let __sym8 = (__loc1, (__tok), __loc2);
                __result = __state54(text, __tokens, __sym8, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Ignore, __loc2)) => {
                let __sym8 = (__loc1, (__tok), __loc2);
                __result = __state55(text, __tokens, __sym8, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Immediate, __loc2)) => {
                let __sym8 = (__loc1, (__tok), __loc2);
                __result = __state56(text, __tokens, __sym8, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Indexed, __loc2)) => {
                let __sym8 = (__loc1, (__tok), __loc2);
                __result = __state57(text, __tokens, __sym8, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Initially, __loc2)) => {
                let __sym8 = (__loc1, (__tok), __loc2);
                __result = __state58(text, __tokens, __sym8, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Inner, __loc2)) => {
                let __sym8 = (__loc1, (__tok), __loc2);
                __result = __state59(text, __tokens, __sym8, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Instead, __loc2)) => {
                let __sym8 = (__loc1, (__tok), __loc2);
                __result = __state60(text, __tokens, __sym8, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Key, __loc2)) => {
                let __sym8 = (__loc1, (__tok), __loc2);
                __result = __state61(text, __tokens, __sym8, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Left, __loc2)) => {
                let __sym8 = (__loc1, (__tok), __loc2);
                __result = __state62(text, __tokens, __sym8, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Natural, __loc2)) => {
                let __sym8 = (__loc1, (__tok), __loc2);
                __result = __state63(text, __tokens, __sym8, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::No, __loc2)) => {
                let __sym8 = (__loc1, (__tok), __loc2);
                __result = __state64(text, __tokens, __sym8, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Of, __loc2)) => {
                let __sym8 = (__loc1, (__tok), __loc2);
                __result = __state65(text, __tokens, __sym8, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Offset, __loc2)) => {
                let __sym8 = (__loc1, (__tok), __loc2);
                __result = __state66(text, __tokens, __sym8, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Outer, __loc2)) => {
                let __sym8 = (__loc1, (__tok), __loc2);
                __result = __state67(text, __tokens, __sym8, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Plan, __loc2)) => {
                let __sym8 = (__loc1, (__tok), __loc2);
                __result = __state68(text, __tokens, __sym8, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Pragma, __loc2)) => {
                let __sym8 = (__loc1, (__tok), __loc2);
                __result = __state69(text, __tokens, __sym8, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Query, __loc2)) => {
                let __sym8 = (__loc1, (__tok), __loc2);
                __result = __state70(text, __tokens, __sym8, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Recursive, __loc2)) => {
                let __sym8 = (__loc1, (__tok), __loc2);
                __result = __state71(text, __tokens, __sym8, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Reindex, __loc2)) => {
                let __sym8 = (__loc1, (__tok), __loc2);
                __result = __state72(text, __tokens, __sym8, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Release, __loc2)) => {
                let __sym8 = (__loc1, (__tok), __loc2);
                __result = __state73(text, __tokens, __sym8, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rename, __loc2)) => {
                let __sym8 = (__loc1, (__tok), __loc2);
                __result = __state74(text, __tokens, __sym8, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Replace, __loc2)) => {
                let __sym8 = (__loc1, (__tok), __loc2);
                __result = __state75(text, __tokens, __sym8, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Restrict, __loc2)) => {
                let __sym8 = (__loc1, (__tok), __loc2);
                __result = __state76(text, __tokens, __sym8, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Right, __loc2)) => {
                let __sym8 = (__loc1, (__tok), __loc2);
                __result = __state77(text, __tokens, __sym8, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rollback, __loc2)) => {
                let __sym8 = (__loc1, (__tok), __loc2);
                __result = __state78(text, __tokens, __sym8, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Row, __loc2)) => {
                let __sym8 = (__loc1, (__tok), __loc2);
                __result = __state79(text, __tokens, __sym8, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Savepoint, __loc2)) => {
                let __sym8 = (__loc1, (__tok), __loc2);
                __result = __state80(text, __tokens, __sym8, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Temp, __loc2)) => {
                let __sym8 = (__loc1, (__tok), __loc2);
                __result = __state81(text, __tokens, __sym8, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Trigger, __loc2)) => {
                let __sym8 = (__loc1, (__tok), __loc2);
                __result = __state82(text, __tokens, __sym8, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Vacuum, __loc2)) => {
                let __sym8 = (__loc1, (__tok), __loc2);
                __result = __state83(text, __tokens, __sym8, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::View, __loc2)) => {
                let __sym8 = (__loc1, (__tok), __loc2);
                __result = __state84(text, __tokens, __sym8, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Virtual, __loc2)) => {
                let __sym8 = (__loc1, (__tok), __loc2);
                __result = __state85(text, __tokens, __sym8, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Without, __loc2)) => {
                let __sym8 = (__loc1, (__tok), __loc2);
                __result = __state86(text, __tokens, __sym8, ::std::marker::PhantomData::<(&())>)?;
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym7.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cColName_3e_20_22_2c_22_29_2b(__sym8) => {
                    __result = __state245(text, __tokens, __lookahead, __sym8, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::ColName(__sym8) => {
                    __result = __state246(text, __tokens, __lookahead, __sym8, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::CommaList_3cColName_3e(__sym8) => {
                    __result = __state306(text, __tokens, __lookahead, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7, __sym8, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                __Nonterminal::Id(__sym8) => {
                    __result = __state29(text, __tokens, __lookahead, __sym8, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Name(__sym8) => {
                    __result = __state141(text, __tokens, __lookahead, __sym8, ::std::marker::PhantomData::<(&())>)?;
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state305<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        __sym3: (usize, Tok<'input>, usize),
        __sym4: (usize, Tok<'input>, usize),
        __sym5: (usize, Name, usize),
        __sym6: (usize, Tok<'input>, usize),
        __sym7: (usize, Tok<'input>, usize),
        __sym8: (usize, Tok<'input>, usize),
        __sym9: (usize, Vec<Name>, usize),
        __sym10: (usize, Tok<'input>, usize),
        __sym11: (usize, Tok<'input>, usize),
        __sym12: (usize, Name, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, __tok @ Tok::LeftParen, __loc2)) => {
                let __sym13 = (__loc1, (__tok), __loc2);
                __result = __state307(text, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7, __sym8, __sym9, __sym10, __sym11, __sym12, __sym13, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###""(""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym12.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state306<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Tok<'input>, usize),
        __sym3: (usize, Vec<Name>, usize),
        __sym4: (usize, Tok<'input>, usize),
        __sym5: (usize, Tok<'input>, usize),
        __sym6: (usize, Name, usize),
        __sym7: (usize, Tok<'input>, usize),
        __sym8: (usize, Vec<Name>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, __tok @ Tok::RightParen, __loc2)) => {
                let __sym9 = (__loc1, (__tok), __loc2);
                __result = __state308(text, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7, __sym8, __sym9, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"")""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym8.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state307<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        __sym3: (usize, Tok<'input>, usize),
        __sym4: (usize, Tok<'input>, usize),
        __sym5: (usize, Name, usize),
        __sym6: (usize, Tok<'input>, usize),
        __sym7: (usize, Tok<'input>, usize),
        __sym8: (usize, Tok<'input>, usize),
        __sym9: (usize, Vec<Name>, usize),
        __sym10: (usize, Tok<'input>, usize),
        __sym11: (usize, Tok<'input>, usize),
        __sym12: (usize, Name, usize),
        __sym13: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((__loc1, Tok::Id(__tok0), __loc2)) => {
                let __sym14 = (__loc1, (__tok0), __loc2);
                __result = __state32(text, __tokens, __sym14, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Abort, __loc2)) => {
                let __sym14 = (__loc1, (__tok), __loc2);
                __result = __state33(text, __tokens, __sym14, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Action, __loc2)) => {
                let __sym14 = (__loc1, (__tok), __loc2);
                __result = __state34(text, __tokens, __sym14, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::After, __loc2)) => {
                let __sym14 = (__loc1, (__tok), __loc2);
                __result = __state35(text, __tokens, __sym14, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Analyze, __loc2)) => {
                let __sym14 = (__loc1, (__tok), __loc2);
                __result = __state36(text, __tokens, __sym14, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Asc, __loc2)) => {
                let __sym14 = (__loc1, (__tok), __loc2);
                __result = __state37(text, __tokens, __sym14, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Attach, __loc2)) => {
                let __sym14 = (__loc1, (__tok), __loc2);
                __result = __state38(text, __tokens, __sym14, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Before, __loc2)) => {
                let __sym14 = (__loc1, (__tok), __loc2);
                __result = __state39(text, __tokens, __sym14, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Begin, __loc2)) => {
                let __sym14 = (__loc1, (__tok), __loc2);
                __result = __state40(text, __tokens, __sym14, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::By, __loc2)) => {
                let __sym14 = (__loc1, (__tok), __loc2);
                __result = __state41(text, __tokens, __sym14, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cascade, __loc2)) => {
                let __sym14 = (__loc1, (__tok), __loc2);
                __result = __state42(text, __tokens, __sym14, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Conflict, __loc2)) => {
                let __sym14 = (__loc1, (__tok), __loc2);
                __result = __state43(text, __tokens, __sym14, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Cross, __loc2)) => {
                let __sym14 = (__loc1, (__tok), __loc2);
                __result = __state44(text, __tokens, __sym14, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Deferred, __loc2)) => {
                let __sym14 = (__loc1, (__tok), __loc2);
                __result = __state45(text, __tokens, __sym14, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Desc, __loc2)) => {
                let __sym14 = (__loc1, (__tok), __loc2);
                __result = __state46(text, __tokens, __sym14, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Detach, __loc2)) => {
                let __sym14 = (__loc1, (__tok), __loc2);
                __result = __state47(text, __tokens, __sym14, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Each, __loc2)) => {
                let __sym14 = (__loc1, (__tok), __loc2);
                __result = __state48(text, __tokens, __sym14, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::End, __loc2)) => {
                let __sym14 = (__loc1, (__tok), __loc2);
                __result = __state49(text, __tokens, __sym14, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Exclusive, __loc2)) => {
                let __sym14 = (__loc1, (__tok), __loc2);
                __result = __state50(text, __tokens, __sym14, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Explain, __loc2)) => {
                let __sym14 = (__loc1, (__tok), __loc2);
                __result = __state51(text, __tokens, __sym14, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Fail, __loc2)) => {
                let __sym14 = (__loc1, (__tok), __loc2);
                __result = __state52(text, __tokens, __sym14, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::For, __loc2)) => {
                let __sym14 = (__loc1, (__tok), __loc2);
                __result = __state53(text, __tokens, __sym14, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::If, __loc2)) => {
                let __sym14 = (__loc1, (__tok), __loc2);
                __result = __state54(text, __tokens, __sym14, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Ignore, __loc2)) => {
                let __sym14 = (__loc1, (__tok), __loc2);
                __result = __state55(text, __tokens, __sym14, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Immediate, __loc2)) => {
                let __sym14 = (__loc1, (__tok), __loc2);
                __result = __state56(text, __tokens, __sym14, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Indexed, __loc2)) => {
                let __sym14 = (__loc1, (__tok), __loc2);
                __result = __state57(text, __tokens, __sym14, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Initially, __loc2)) => {
                let __sym14 = (__loc1, (__tok), __loc2);
                __result = __state58(text, __tokens, __sym14, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Inner, __loc2)) => {
                let __sym14 = (__loc1, (__tok), __loc2);
                __result = __state59(text, __tokens, __sym14, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Instead, __loc2)) => {
                let __sym14 = (__loc1, (__tok), __loc2);
                __result = __state60(text, __tokens, __sym14, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Key, __loc2)) => {
                let __sym14 = (__loc1, (__tok), __loc2);
                __result = __state61(text, __tokens, __sym14, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Left, __loc2)) => {
                let __sym14 = (__loc1, (__tok), __loc2);
                __result = __state62(text, __tokens, __sym14, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Natural, __loc2)) => {
                let __sym14 = (__loc1, (__tok), __loc2);
                __result = __state63(text, __tokens, __sym14, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::No, __loc2)) => {
                let __sym14 = (__loc1, (__tok), __loc2);
                __result = __state64(text, __tokens, __sym14, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Of, __loc2)) => {
                let __sym14 = (__loc1, (__tok), __loc2);
                __result = __state65(text, __tokens, __sym14, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Offset, __loc2)) => {
                let __sym14 = (__loc1, (__tok), __loc2);
                __result = __state66(text, __tokens, __sym14, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Outer, __loc2)) => {
                let __sym14 = (__loc1, (__tok), __loc2);
                __result = __state67(text, __tokens, __sym14, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Plan, __loc2)) => {
                let __sym14 = (__loc1, (__tok), __loc2);
                __result = __state68(text, __tokens, __sym14, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Pragma, __loc2)) => {
                let __sym14 = (__loc1, (__tok), __loc2);
                __result = __state69(text, __tokens, __sym14, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Query, __loc2)) => {
                let __sym14 = (__loc1, (__tok), __loc2);
                __result = __state70(text, __tokens, __sym14, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Recursive, __loc2)) => {
                let __sym14 = (__loc1, (__tok), __loc2);
                __result = __state71(text, __tokens, __sym14, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Reindex, __loc2)) => {
                let __sym14 = (__loc1, (__tok), __loc2);
                __result = __state72(text, __tokens, __sym14, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Release, __loc2)) => {
                let __sym14 = (__loc1, (__tok), __loc2);
                __result = __state73(text, __tokens, __sym14, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rename, __loc2)) => {
                let __sym14 = (__loc1, (__tok), __loc2);
                __result = __state74(text, __tokens, __sym14, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Replace, __loc2)) => {
                let __sym14 = (__loc1, (__tok), __loc2);
                __result = __state75(text, __tokens, __sym14, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Restrict, __loc2)) => {
                let __sym14 = (__loc1, (__tok), __loc2);
                __result = __state76(text, __tokens, __sym14, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Right, __loc2)) => {
                let __sym14 = (__loc1, (__tok), __loc2);
                __result = __state77(text, __tokens, __sym14, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Rollback, __loc2)) => {
                let __sym14 = (__loc1, (__tok), __loc2);
                __result = __state78(text, __tokens, __sym14, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Row, __loc2)) => {
                let __sym14 = (__loc1, (__tok), __loc2);
                __result = __state79(text, __tokens, __sym14, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Savepoint, __loc2)) => {
                let __sym14 = (__loc1, (__tok), __loc2);
                __result = __state80(text, __tokens, __sym14, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Temp, __loc2)) => {
                let __sym14 = (__loc1, (__tok), __loc2);
                __result = __state81(text, __tokens, __sym14, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Trigger, __loc2)) => {
                let __sym14 = (__loc1, (__tok), __loc2);
                __result = __state82(text, __tokens, __sym14, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Vacuum, __loc2)) => {
                let __sym14 = (__loc1, (__tok), __loc2);
                __result = __state83(text, __tokens, __sym14, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::View, __loc2)) => {
                let __sym14 = (__loc1, (__tok), __loc2);
                __result = __state84(text, __tokens, __sym14, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Virtual, __loc2)) => {
                let __sym14 = (__loc1, (__tok), __loc2);
                __result = __state85(text, __tokens, __sym14, ::std::marker::PhantomData::<(&())>)?;
            }
            Some((__loc1, __tok @ Tok::Without, __loc2)) => {
                let __sym14 = (__loc1, (__tok), __loc2);
                __result = __state86(text, __tokens, __sym14, ::std::marker::PhantomData::<(&())>)?;
            }
            _ => {
                let __expected = vec![
                    r###""Id""###.to_string(),
                    r###""abort""###.to_string(),
                    r###""action""###.to_string(),
                    r###""after""###.to_string(),
                    r###""analyze""###.to_string(),
                    r###""asc""###.to_string(),
                    r###""attach""###.to_string(),
                    r###""before""###.to_string(),
                    r###""begin""###.to_string(),
                    r###""by""###.to_string(),
                    r###""cascade""###.to_string(),
                    r###""conflict""###.to_string(),
                    r###""cross""###.to_string(),
                    r###""deferred""###.to_string(),
                    r###""desc""###.to_string(),
                    r###""detach""###.to_string(),
                    r###""each""###.to_string(),
                    r###""end""###.to_string(),
                    r###""exclusive""###.to_string(),
                    r###""explain""###.to_string(),
                    r###""fail""###.to_string(),
                    r###""for""###.to_string(),
                    r###""if""###.to_string(),
                    r###""ignore""###.to_string(),
                    r###""immediate""###.to_string(),
                    r###""indexed""###.to_string(),
                    r###""initially""###.to_string(),
                    r###""inner""###.to_string(),
                    r###""instead""###.to_string(),
                    r###""key""###.to_string(),
                    r###""left""###.to_string(),
                    r###""natural""###.to_string(),
                    r###""no""###.to_string(),
                    r###""of""###.to_string(),
                    r###""offset""###.to_string(),
                    r###""outer""###.to_string(),
                    r###""plan""###.to_string(),
                    r###""pragma""###.to_string(),
                    r###""query""###.to_string(),
                    r###""recursive""###.to_string(),
                    r###""reindex""###.to_string(),
                    r###""release""###.to_string(),
                    r###""rename""###.to_string(),
                    r###""replace""###.to_string(),
                    r###""restrict""###.to_string(),
                    r###""right""###.to_string(),
                    r###""rollback""###.to_string(),
                    r###""row""###.to_string(),
                    r###""savepoint""###.to_string(),
                    r###""temp""###.to_string(),
                    r###""trigger""###.to_string(),
                    r###""vacuum""###.to_string(),
                    r###""view""###.to_string(),
                    r###""virtual""###.to_string(),
                    r###""without""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym13.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
        loop {
            let (__lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cColName_3e_20_22_2c_22_29_2b(__sym14) => {
                    __result = __state245(text, __tokens, __lookahead, __sym14, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::ColName(__sym14) => {
                    __result = __state246(text, __tokens, __lookahead, __sym14, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::CommaList_3cColName_3e(__sym14) => {
                    __result = __state309(text, __tokens, __lookahead, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7, __sym8, __sym9, __sym10, __sym11, __sym12, __sym13, __sym14, ::std::marker::PhantomData::<(&())>)?;
                    return Ok(__result);
                }
                __Nonterminal::Id(__sym14) => {
                    __result = __state29(text, __tokens, __lookahead, __sym14, ::std::marker::PhantomData::<(&())>)?;
                }
                __Nonterminal::Name(__sym14) => {
                    __result = __state141(text, __tokens, __lookahead, __sym14, ::std::marker::PhantomData::<(&())>)?;
                }
                _ => {
                    return Ok((__lookahead, __nt));
                }
            }
        }
    }

    fn __state308<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Tok<'input>, usize),
        __sym3: (usize, Vec<Name>, usize),
        __sym4: (usize, Tok<'input>, usize),
        __sym5: (usize, Tok<'input>, usize),
        __sym6: (usize, Name, usize),
        __sym7: (usize, Tok<'input>, usize),
        __sym8: (usize, Vec<Name>, usize),
        __sym9: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym9.2.clone();
                let __nt = super::__action57::<>(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7, __sym8, __sym9);
                let __nt = __Nonterminal::ForeignKeyField((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"")""###.to_string(),
                    r###"",""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym9.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state309<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        __sym3: (usize, Tok<'input>, usize),
        __sym4: (usize, Tok<'input>, usize),
        __sym5: (usize, Name, usize),
        __sym6: (usize, Tok<'input>, usize),
        __sym7: (usize, Tok<'input>, usize),
        __sym8: (usize, Tok<'input>, usize),
        __sym9: (usize, Vec<Name>, usize),
        __sym10: (usize, Tok<'input>, usize),
        __sym11: (usize, Tok<'input>, usize),
        __sym12: (usize, Name, usize),
        __sym13: (usize, Tok<'input>, usize),
        __sym14: (usize, Vec<Name>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        match __lookahead {
            Some((__loc1, __tok @ Tok::RightParen, __loc2)) => {
                let __sym15 = (__loc1, (__tok), __loc2);
                __result = __state310(text, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7, __sym8, __sym9, __sym10, __sym11, __sym12, __sym13, __sym14, __sym15, ::std::marker::PhantomData::<(&())>)?;
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"")""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym14.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }

    fn __state310<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),__lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>>,
    >(
        text: &'input str,
        __tokens: &mut __TOKENS,
        __sym0: (usize, Tok<'input>, usize),
        __sym1: (usize, Tok<'input>, usize),
        __sym2: (usize, Name, usize),
        __sym3: (usize, Tok<'input>, usize),
        __sym4: (usize, Tok<'input>, usize),
        __sym5: (usize, Name, usize),
        __sym6: (usize, Tok<'input>, usize),
        __sym7: (usize, Tok<'input>, usize),
        __sym8: (usize, Tok<'input>, usize),
        __sym9: (usize, Vec<Name>, usize),
        __sym10: (usize, Tok<'input>, usize),
        __sym11: (usize, Tok<'input>, usize),
        __sym12: (usize, Name, usize),
        __sym13: (usize, Tok<'input>, usize),
        __sym14: (usize, Vec<Name>, usize),
        __sym15: (usize, Tok<'input>, usize),
        _: ::std::marker::PhantomData<(&'input ())>,
    ) -> Result<(Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>
    {
        let mut __result: (Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            Some(Err(e)) => return Err(e),
            None => None,
        };
        match __lookahead {
            Some((_, Tok::Semi, _)) => {
                let __start = __sym0.0.clone();
                let __end = __sym15.2.clone();
                let __nt = super::__action37::<>(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7, __sym8, __sym9, __sym10, __sym11, __sym12, __sym13, __sym14, __sym15);
                let __nt = __Nonterminal::AlterStmt((
                    __start,
                    __nt,
                    __end,
                ));
                __result = (__lookahead, __nt);
                return Ok(__result);
            }
            _ => {
                let __expected = vec![
                    r###"";""###.to_string(),
                ];
                return Err(
                    match __lookahead {
                        Some(__token) => {
                            __lalrpop_util::ParseError::UnrecognizedToken {
                                token: __token,
                                expected: __expected,
                            }
                        }
                        None => {
                            let __location = __sym15.2.clone();
                            __lalrpop_util::ParseError::UnrecognizedEOF {
                                location: __location,
                                expected: __expected,
                            }
                        }
                    }
                )
            }
        }
    }
}
pub use self::__parse__Sql::SqlParser;

#[allow(unused_variables)]
fn __action0<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Sql, usize),
) -> Sql
{
    (__0)
}

#[allow(unused_variables)]
fn __action1<
    'input,
>(
    text: &'input str,
    (_, stmt_list, _): (usize, ::std::vec::Vec<Stmt>, usize),
) -> Sql
{
    {
        Sql{stmt_list:stmt_list}
    }
}

#[allow(unused_variables)]
fn __action2<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, SystemStmt, usize),
    (_, _, _): (usize, Tok<'input>, usize),
) -> Stmt
{
    Stmt::System(__0)
}

#[allow(unused_variables)]
fn __action3<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, DatabaseStmt, usize),
    (_, _, _): (usize, Tok<'input>, usize),
) -> Stmt
{
    Stmt::Database(__0)
}

#[allow(unused_variables)]
fn __action4<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, TableStmt, usize),
    (_, _, _): (usize, Tok<'input>, usize),
) -> Stmt
{
    Stmt::Table(__0)
}

#[allow(unused_variables)]
fn __action5<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, IndexStmt, usize),
    (_, _, _): (usize, Tok<'input>, usize),
) -> Stmt
{
    Stmt::Index(__0)
}

#[allow(unused_variables)]
fn __action6<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, AlterStmt, usize),
    (_, _, _): (usize, Tok<'input>, usize),
) -> Stmt
{
    Stmt::Alter(__0)
}

#[allow(unused_variables)]
fn __action7<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, CopyStmt, usize),
    (_, _, _): (usize, Tok<'input>, usize),
) -> Stmt
{
    Stmt::Copy(__0)
}

#[allow(unused_variables)]
fn __action8<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Name, usize),
) -> Name
{
    (__0)
}

#[allow(unused_variables)]
fn __action9<
    'input,
>(
    text: &'input str,
    (_, _, _): (usize, Tok<'input>, usize),
    (_, tb_name, _): (usize, Name, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, path, _): (usize, Name, usize),
) -> CopyStmt
{
    CopyStmt { tb_name:tb_name, path:path }
}

#[allow(unused_variables)]
fn __action10<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
    (_, __1, _): (usize, Tok<'input>, usize),
) -> SystemStmt
{
    SystemStmt::ShowDatabases
}

#[allow(unused_variables)]
fn __action11<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Name, usize),
) -> Name
{
    (__0)
}

#[allow(unused_variables)]
fn __action12<
    'input,
>(
    text: &'input str,
    (_, _, _): (usize, Tok<'input>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, db_name, _): (usize, Name, usize),
) -> DatabaseStmt
{
    DatabaseStmt::CreateDatabase { db_name:db_name }
}

#[allow(unused_variables)]
fn __action13<
    'input,
>(
    text: &'input str,
    (_, _, _): (usize, Tok<'input>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, db_name, _): (usize, Name, usize),
) -> DatabaseStmt
{
    DatabaseStmt::DropDatabase { db_name:db_name }
}

#[allow(unused_variables)]
fn __action14<
    'input,
>(
    text: &'input str,
    (_, _, _): (usize, Tok<'input>, usize),
    (_, db_name, _): (usize, Name, usize),
) -> DatabaseStmt
{
    DatabaseStmt::UseDatabase { db_name:db_name }
}

#[allow(unused_variables)]
fn __action15<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
    (_, __1, _): (usize, Tok<'input>, usize),
) -> DatabaseStmt
{
    DatabaseStmt::ShowTables
}

#[allow(unused_variables)]
fn __action16<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Name, usize),
) -> Name
{
    (__0)
}

#[allow(unused_variables)]
fn __action17<
    'input,
>(
    text: &'input str,
    (_, _, _): (usize, Tok<'input>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, tb_name, _): (usize, Name, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, field_list, _): (usize, Vec<Field>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
) -> TableStmt
{
    TableStmt::CreateTable { tb_name:tb_name, field_list:field_list }
}

#[allow(unused_variables)]
fn __action18<
    'input,
>(
    text: &'input str,
    (_, _, _): (usize, Tok<'input>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, tb_name, _): (usize, Name, usize),
) -> TableStmt
{
    TableStmt::DropTable { tb_name:tb_name }
}

#[allow(unused_variables)]
fn __action19<
    'input,
>(
    text: &'input str,
    (_, _, _): (usize, Tok<'input>, usize),
    (_, tb_name, _): (usize, Name, usize),
) -> TableStmt
{
    TableStmt::Desc { tb_name:tb_name }
}

#[allow(unused_variables)]
fn __action20<
    'input,
>(
    text: &'input str,
    (_, _, _): (usize, Tok<'input>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, tb_name, _): (usize, Name, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, value_lists, _): (usize, Vec<Vec<Value>>, usize),
) -> TableStmt
{
    TableStmt::Insert { tb_name:tb_name, value_lists:value_lists }
}

#[allow(unused_variables)]
fn __action21<
    'input,
>(
    text: &'input str,
    (_, _, _): (usize, Tok<'input>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, tb_name, _): (usize, Name, usize),
    (_, where_clause, _): (usize, ::std::option::Option<Vec<WhereClause>>, usize),
) -> TableStmt
{
    TableStmt::Delete { tb_name:tb_name, where_clause:where_clause }
}

#[allow(unused_variables)]
fn __action22<
    'input,
>(
    text: &'input str,
    (_, _, _): (usize, Tok<'input>, usize),
    (_, tb_name, _): (usize, Name, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, set_clause, _): (usize, Vec<SetClause>, usize),
    (_, where_clause, _): (usize, ::std::option::Option<Vec<WhereClause>>, usize),
) -> TableStmt
{
    TableStmt::Update { tb_name:tb_name, set_clause:set_clause, where_clause:where_clause }
}

#[allow(unused_variables)]
fn __action23<
    'input,
>(
    text: &'input str,
    (_, _, _): (usize, Tok<'input>, usize),
    (_, selector, _): (usize, Selector, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, table_list, _): (usize, Vec<Name>, usize),
    (_, where_clause, _): (usize, ::std::option::Option<Vec<WhereClause>>, usize),
) -> TableStmt
{
    TableStmt::Select { selector:selector, table_list:table_list, where_clause:where_clause }
}

#[allow(unused_variables)]
fn __action24<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Name, usize),
) -> Name
{
    (__0)
}

#[allow(unused_variables)]
fn __action25<
    'input,
>(
    text: &'input str,
    (_, _, _): (usize, Tok<'input>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, idx_name, _): (usize, Name, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, tb_name, _): (usize, Name, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, column_list, _): (usize, Vec<Name>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
) -> IndexStmt
{
    {
        IndexStmt::CreateIndex { idx_name:idx_name, tb_name:tb_name, column_list:column_list }
    }
}

#[allow(unused_variables)]
fn __action26<
    'input,
>(
    text: &'input str,
    (_, _, _): (usize, Tok<'input>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, idx_name, _): (usize, Name, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, tb_name, _): (usize, Name, usize),
) -> IndexStmt
{
    IndexStmt::DropIndex { idx_name:idx_name, tb_name:tb_name }
}

#[allow(unused_variables)]
fn __action27<
    'input,
>(
    text: &'input str,
    (_, _, _): (usize, Tok<'input>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, tb_name, _): (usize, Name, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, idx_name, _): (usize, Name, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, column_list, _): (usize, Vec<Name>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
) -> IndexStmt
{
    {
        IndexStmt::AlterAddIndex { tb_name:tb_name, idx_name:idx_name, column_list:column_list }
    }
}

#[allow(unused_variables)]
fn __action28<
    'input,
>(
    text: &'input str,
    (_, _, _): (usize, Tok<'input>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, tb_name, _): (usize, Name, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, idx_name, _): (usize, Name, usize),
) -> IndexStmt
{
    IndexStmt::AlterDropIndex { tb_name:tb_name, idx_name:idx_name }
}

#[allow(unused_variables)]
fn __action29<
    'input,
>(
    text: &'input str,
    (_, _, _): (usize, Tok<'input>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, tb_name, _): (usize, Name, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, field, _): (usize, Field, usize),
) -> AlterStmt
{
    AlterStmt::AddColumn { tb_name:tb_name, field:field }
}

#[allow(unused_variables)]
fn __action30<
    'input,
>(
    text: &'input str,
    (_, _, _): (usize, Tok<'input>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, tb_name, _): (usize, Name, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, col_name, _): (usize, Name, usize),
) -> AlterStmt
{
    AlterStmt::DropColumn { tb_name:tb_name, col_name:col_name }
}

#[allow(unused_variables)]
fn __action31<
    'input,
>(
    text: &'input str,
    (_, _, _): (usize, Tok<'input>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, tb_name, _): (usize, Name, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, col_name, _): (usize, Name, usize),
    (_, field, _): (usize, Field, usize),
) -> AlterStmt
{
    AlterStmt::ChangeColumn { tb_name:tb_name, col_name:col_name, field:field }
}

#[allow(unused_variables)]
fn __action32<
    'input,
>(
    text: &'input str,
    (_, _, _): (usize, Tok<'input>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, tb_name, _): (usize, Name, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, new_name, _): (usize, Name, usize),
) -> AlterStmt
{
    AlterStmt::RenameTable { tb_name:tb_name, new_name:new_name }
}

#[allow(unused_variables)]
fn __action33<
    'input,
>(
    text: &'input str,
    (_, _, _): (usize, Tok<'input>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, tb_name, _): (usize, Name, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, column_list, _): (usize, Vec<Name>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
) -> AlterStmt
{
    AlterStmt::AddPrimaryKey { tb_name:tb_name, column_list:column_list }
}

#[allow(unused_variables)]
fn __action34<
    'input,
>(
    text: &'input str,
    (_, _, _): (usize, Tok<'input>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, tb_name, _): (usize, Name, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
) -> AlterStmt
{
    AlterStmt::DropPrimaryKey { tb_name:tb_name }
}

#[allow(unused_variables)]
fn __action35<
    'input,
>(
    text: &'input str,
    (_, _, _): (usize, Tok<'input>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, tb_name, _): (usize, Name, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, pk_name, _): (usize, Name, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, column_list, _): (usize, Vec<Name>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
) -> AlterStmt
{
    AlterStmt::AddConstraintPrimaryKey { tb_name:tb_name, pk_name:pk_name, column_list:column_list }
}

#[allow(unused_variables)]
fn __action36<
    'input,
>(
    text: &'input str,
    (_, _, _): (usize, Tok<'input>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, tb_name, _): (usize, Name, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, pk_name, _): (usize, Name, usize),
) -> AlterStmt
{
    AlterStmt::DropConstraintPrimaryKey { tb_name:tb_name, pk_name:pk_name }
}

#[allow(unused_variables)]
fn __action37<
    'input,
>(
    text: &'input str,
    (_, _, _): (usize, Tok<'input>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, tb_name, _): (usize, Name, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, fk_name, _): (usize, Name, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, column_list, _): (usize, Vec<Name>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, foreign_tb_name, _): (usize, Name, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, foreign_column_list, _): (usize, Vec<Name>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
) -> AlterStmt
{
    {
        AlterStmt::AddConstraintForeignKey { tb_name:tb_name, fk_name:fk_name, column_list:column_list, foreign_tb_name:foreign_tb_name, foreign_column_list:foreign_column_list }
    }
}

#[allow(unused_variables)]
fn __action38<
    'input,
>(
    text: &'input str,
    (_, _, _): (usize, Tok<'input>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, tb_name, _): (usize, Name, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, fk_name, _): (usize, Name, usize),
) -> AlterStmt
{
    AlterStmt::DropConstraintForeignKey { tb_name:tb_name, fk_name:fk_name }
}

#[allow(unused_variables)]
fn __action39<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Name, usize),
) -> Name
{
    (__0)
}

#[allow(unused_variables)]
fn __action40<
    'input,
>(
    text: &'input str,
    (_, col_name, _): (usize, Name, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, value, _): (usize, Value, usize),
) -> SetClause
{
    SetClause { col_name:col_name, value:value }
}

#[allow(unused_variables)]
fn __action41<
    'input,
>(
    text: &'input str,
    (_, v, _): (usize, ::std::vec::Vec<WhereClause>, usize),
    (_, e, _): (usize, WhereClause, usize),
) -> Vec<WhereClause>
{
    {
        let mut v = v;
        v.push(e);
        v
    }
}

#[allow(unused_variables)]
fn __action42<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Selector
{
    Selector::All
}

#[allow(unused_variables)]
fn __action43<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Vec<Column>, usize),
) -> Selector
{
    Selector::Columns(__0)
}

#[allow(unused_variables)]
fn __action44<
    'input,
>(
    text: &'input str,
    (_, tb_name, _): (usize, ::std::option::Option<Name>, usize),
    (_, col_name, _): (usize, Name, usize),
) -> Column
{
    Column{ tb_name:tb_name, col_name:col_name }
}

#[allow(unused_variables)]
fn __action45<
    'input,
>(
    text: &'input str,
    (_, col, _): (usize, Column, usize),
    (_, op, _): (usize, Op, usize),
    (_, expr, _): (usize, Expr, usize),
) -> WhereClause
{
    WhereClause::Comparison { col:col, op:op, expr:expr }
}

#[allow(unused_variables)]
fn __action46<
    'input,
>(
    text: &'input str,
    (_, col, _): (usize, Column, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, not_null, _): (usize, ::std::option::Option<Tok<'input>>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
) -> WhereClause
{
    {
        WhereClause::IsAssert {
            col: col,
            null: not_null.is_none(),
        }
    }
}

#[allow(unused_variables)]
fn __action47<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Op
{
    Op::Equal
}

#[allow(unused_variables)]
fn __action48<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Op
{
    Op::NotEqual
}

#[allow(unused_variables)]
fn __action49<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Op
{
    Op::LessEqual
}

#[allow(unused_variables)]
fn __action50<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Op
{
    Op::GreaterEqual
}

#[allow(unused_variables)]
fn __action51<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Op
{
    Op::Less
}

#[allow(unused_variables)]
fn __action52<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Op
{
    Op::Greater
}

#[allow(unused_variables)]
fn __action53<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Value, usize),
) -> Expr
{
    Expr::Value(__0)
}

#[allow(unused_variables)]
fn __action54<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Column, usize),
) -> Expr
{
    Expr::Column(__0)
}

#[allow(unused_variables)]
fn __action55<
    'input,
>(
    text: &'input str,
    (_, col_name, _): (usize, Name, usize),
    (_, ty, _): (usize, Type, usize),
    (_, not_null, _): (usize, ::std::option::Option<(Tok<'input>, Tok<'input>)>, usize),
    (_, default_value, _): (usize, ::std::option::Option<Value>, usize),
) -> Field
{
    {
        let not_null = not_null.is_some();
        Field::ColumnField { col_name:col_name, ty:ty, not_null:not_null, default_value:default_value }
    }
}

#[allow(unused_variables)]
fn __action56<
    'input,
>(
    text: &'input str,
    (_, _, _): (usize, Tok<'input>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, column_list, _): (usize, Vec<Name>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
) -> Field
{
    Field::PrimaryKeyField { column_list:column_list }
}

#[allow(unused_variables)]
fn __action57<
    'input,
>(
    text: &'input str,
    (_, _, _): (usize, Tok<'input>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, column_list, _): (usize, Vec<Name>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, foreign_tb_name, _): (usize, Name, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, foreign_column_list, _): (usize, Vec<Name>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
) -> Field
{
    Field::ForeignKeyField { column_list:column_list, foreign_tb_name:foreign_tb_name, foreign_column_list:foreign_column_list }
}

#[allow(unused_variables)]
fn __action58<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Field, usize),
) -> Field
{
    (__0)
}

#[allow(unused_variables)]
fn __action59<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Field, usize),
) -> Field
{
    (__0)
}

#[allow(unused_variables)]
fn __action60<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Field, usize),
) -> Field
{
    (__0)
}

#[allow(unused_variables)]
fn __action61<
    'input,
>(
    text: &'input str,
    (_, _, _): (usize, Tok<'input>, usize),
    (_, __0, _): (usize, Vec<Value>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
) -> Vec<Value>
{
    (__0)
}

#[allow(unused_variables)]
fn __action62<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Value
{
    Value::Null
}

#[allow(unused_variables)]
fn __action63<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, &'input str, usize),
) -> Value
{
    Value::Str(__0.to_owned())
}

#[allow(unused_variables)]
fn __action64<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, &'input str, usize),
) -> Value
{
    Value::Date(__0.to_owned())
}

#[allow(unused_variables)]
fn __action65<
    'input,
>(
    text: &'input str,
    (_, _, _): (usize, ::std::option::Option<Tok<'input>>, usize),
    (_, __0, _): (usize, &'input str, usize),
) -> Value
{
    { Value::Int( __0.to_owned() ) }
}

#[allow(unused_variables)]
fn __action66<
    'input,
>(
    text: &'input str,
    (_, _, _): (usize, Tok<'input>, usize),
    (_, __0, _): (usize, &'input str, usize),
) -> Value
{
    { Value::Int( format!("-{}", __0) ) }
}

#[allow(unused_variables)]
fn __action67<
    'input,
>(
    text: &'input str,
    (_, _, _): (usize, ::std::option::Option<Tok<'input>>, usize),
    (_, __0, _): (usize, &'input str, usize),
) -> Value
{
    { Value::Float( __0.to_owned() ) }
}

#[allow(unused_variables)]
fn __action68<
    'input,
>(
    text: &'input str,
    (_, _, _): (usize, Tok<'input>, usize),
    (_, __0, _): (usize, &'input str, usize),
) -> Value
{
    { Value::Float( format!("-{}", __0) ) }
}

#[allow(unused_variables)]
fn __action69<
    'input,
>(
    text: &'input str,
    (_, _, _): (usize, Tok<'input>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, __0, _): (usize, &'input str, usize),
    (_, _, _): (usize, Tok<'input>, usize),
) -> Type
{
    {
        Type::Int(i64::from_str(__0).unwrap())
    }
}

#[allow(unused_variables)]
fn __action70<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Type
{
    {
        Type::Int(0)
    }
}

#[allow(unused_variables)]
fn __action71<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Type
{
    {
        Type::Int(0)
    }
}

#[allow(unused_variables)]
fn __action72<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Type
{
    {
        Type::Int(0)
    }
}

#[allow(unused_variables)]
fn __action73<
    'input,
>(
    text: &'input str,
    (_, _, _): (usize, Tok<'input>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, __0, _): (usize, &'input str, usize),
    (_, _, _): (usize, Tok<'input>, usize),
) -> Type
{
    {
        Type::Varchar(i64::from_str(__0).unwrap())
    }
}

#[allow(unused_variables)]
fn __action74<
    'input,
>(
    text: &'input str,
    (_, _, _): (usize, Tok<'input>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, __0, _): (usize, &'input str, usize),
    (_, _, _): (usize, Tok<'input>, usize),
) -> Type
{
    {
        Type::Varchar(i64::from_str(__0).unwrap())
    }
}

#[allow(unused_variables)]
fn __action75<
    'input,
>(
    text: &'input str,
    (_, _, _): (usize, Tok<'input>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, a, _): (usize, &'input str, usize),
    (_, _, _): (usize, Tok<'input>, usize),
    (_, b, _): (usize, &'input str, usize),
    (_, _, _): (usize, Tok<'input>, usize),
) -> Type
{
    {
        Type::Numeric(i64::from_str(a).unwrap(), i64::from_str(b).unwrap())
    }
}

#[allow(unused_variables)]
fn __action76<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Type
{
    {
        Type::Numeric(19, 2)
    }
}

#[allow(unused_variables)]
fn __action77<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Type
{
    {
        Type::Date
    }
}

#[allow(unused_variables)]
fn __action78<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Type
{
    {
        Type::Float
    }
}

#[allow(unused_variables)]
fn __action79<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, &'input str, usize),
) -> Name
{
    __0.to_owned()
}

#[allow(unused_variables)]
fn __action80<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Name
{
    "indexed".to_owned()
}

#[allow(unused_variables)]
fn __action81<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Name
{
    "abort".to_owned()
}

#[allow(unused_variables)]
fn __action82<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Name
{
    "action".to_owned()
}

#[allow(unused_variables)]
fn __action83<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Name
{
    "after".to_owned()
}

#[allow(unused_variables)]
fn __action84<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Name
{
    "analyze".to_owned()
}

#[allow(unused_variables)]
fn __action85<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Name
{
    "asc".to_owned()
}

#[allow(unused_variables)]
fn __action86<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Name
{
    "attach".to_owned()
}

#[allow(unused_variables)]
fn __action87<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Name
{
    "before".to_owned()
}

#[allow(unused_variables)]
fn __action88<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Name
{
    "begin".to_owned()
}

#[allow(unused_variables)]
fn __action89<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Name
{
    "by".to_owned()
}

#[allow(unused_variables)]
fn __action90<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Name
{
    "cascade".to_owned()
}

#[allow(unused_variables)]
fn __action91<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Name
{
    "conflict".to_owned()
}

#[allow(unused_variables)]
fn __action92<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Name
{
    "deferred".to_owned()
}

#[allow(unused_variables)]
fn __action93<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Name
{
    "desc".to_owned()
}

#[allow(unused_variables)]
fn __action94<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Name
{
    "detach".to_owned()
}

#[allow(unused_variables)]
fn __action95<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Name
{
    "each".to_owned()
}

#[allow(unused_variables)]
fn __action96<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Name
{
    "end".to_owned()
}

#[allow(unused_variables)]
fn __action97<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Name
{
    "exclusive".to_owned()
}

#[allow(unused_variables)]
fn __action98<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Name
{
    "explain".to_owned()
}

#[allow(unused_variables)]
fn __action99<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Name
{
    "fail".to_owned()
}

#[allow(unused_variables)]
fn __action100<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Name
{
    "for".to_owned()
}

#[allow(unused_variables)]
fn __action101<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Name
{
    "ignore".to_owned()
}

#[allow(unused_variables)]
fn __action102<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Name
{
    "immediate".to_owned()
}

#[allow(unused_variables)]
fn __action103<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Name
{
    "initially".to_owned()
}

#[allow(unused_variables)]
fn __action104<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Name
{
    "instead".to_owned()
}

#[allow(unused_variables)]
fn __action105<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Name
{
    "no".to_owned()
}

#[allow(unused_variables)]
fn __action106<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Name
{
    "plan".to_owned()
}

#[allow(unused_variables)]
fn __action107<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Name
{
    "query".to_owned()
}

#[allow(unused_variables)]
fn __action108<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Name
{
    "key".to_owned()
}

#[allow(unused_variables)]
fn __action109<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Name
{
    "of".to_owned()
}

#[allow(unused_variables)]
fn __action110<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Name
{
    "offset".to_owned()
}

#[allow(unused_variables)]
fn __action111<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Name
{
    "pragma".to_owned()
}

#[allow(unused_variables)]
fn __action112<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Name
{
    "recursive".to_owned()
}

#[allow(unused_variables)]
fn __action113<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Name
{
    "release".to_owned()
}

#[allow(unused_variables)]
fn __action114<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Name
{
    "replace".to_owned()
}

#[allow(unused_variables)]
fn __action115<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Name
{
    "restrict".to_owned()
}

#[allow(unused_variables)]
fn __action116<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Name
{
    "row".to_owned()
}

#[allow(unused_variables)]
fn __action117<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Name
{
    "rollback".to_owned()
}

#[allow(unused_variables)]
fn __action118<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Name
{
    "savepoint".to_owned()
}

#[allow(unused_variables)]
fn __action119<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Name
{
    "temp".to_owned()
}

#[allow(unused_variables)]
fn __action120<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Name
{
    "trigger".to_owned()
}

#[allow(unused_variables)]
fn __action121<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Name
{
    "vacuum".to_owned()
}

#[allow(unused_variables)]
fn __action122<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Name
{
    "view".to_owned()
}

#[allow(unused_variables)]
fn __action123<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Name
{
    "virtual".to_owned()
}

#[allow(unused_variables)]
fn __action124<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Name
{
    "without".to_owned()
}

#[allow(unused_variables)]
fn __action125<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Name
{
    "reindex".to_owned()
}

#[allow(unused_variables)]
fn __action126<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Name
{
    "rename".to_owned()
}

#[allow(unused_variables)]
fn __action127<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Name
{
    "if".to_owned()
}

#[allow(unused_variables)]
fn __action128<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Name, usize),
) -> Name
{
    (__0)
}

#[allow(unused_variables)]
fn __action129<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Name, usize),
) -> Name
{
    (__0)
}

#[allow(unused_variables)]
fn __action130<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Name
{
    "cross".to_owned()
}

#[allow(unused_variables)]
fn __action131<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Name
{
    "inner".to_owned()
}

#[allow(unused_variables)]
fn __action132<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Name
{
    "left".to_owned()
}

#[allow(unused_variables)]
fn __action133<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Name
{
    "natural".to_owned()
}

#[allow(unused_variables)]
fn __action134<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Name
{
    "outer".to_owned()
}

#[allow(unused_variables)]
fn __action135<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> Name
{
    "right".to_owned()
}

#[allow(unused_variables)]
fn __action136<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> ::std::option::Option<Tok<'input>>
{
    Some(__0)
}

#[allow(unused_variables)]
fn __action137<
    'input,
>(
    text: &'input str,
    __lookbehind: &usize,
    __lookahead: &usize,
) -> ::std::option::Option<Tok<'input>>
{
    None
}

#[allow(unused_variables)]
fn __action138<
    'input,
>(
    text: &'input str,
    (_, v, _): (usize, ::std::vec::Vec<Value>, usize),
    (_, e, _): (usize, Value, usize),
) -> Vec<Value>
{
    {
        let mut v = v;
        v.push(e);
        v
    }
}

#[allow(unused_variables)]
fn __action139<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Value, usize),
) -> ::std::option::Option<Value>
{
    Some(__0)
}

#[allow(unused_variables)]
fn __action140<
    'input,
>(
    text: &'input str,
    __lookbehind: &usize,
    __lookahead: &usize,
) -> ::std::option::Option<Value>
{
    None
}

#[allow(unused_variables)]
fn __action141<
    'input,
>(
    text: &'input str,
    (_, _, _): (usize, Tok<'input>, usize),
    (_, __0, _): (usize, Value, usize),
) -> Value
{
    (__0)
}

#[allow(unused_variables)]
fn __action142<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, (Tok<'input>, Tok<'input>), usize),
) -> ::std::option::Option<(Tok<'input>, Tok<'input>)>
{
    Some(__0)
}

#[allow(unused_variables)]
fn __action143<
    'input,
>(
    text: &'input str,
    __lookbehind: &usize,
    __lookahead: &usize,
) -> ::std::option::Option<(Tok<'input>, Tok<'input>)>
{
    None
}

#[allow(unused_variables)]
fn __action144<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
    (_, __1, _): (usize, Tok<'input>, usize),
) -> (Tok<'input>, Tok<'input>)
{
    (__0, __1)
}

#[allow(unused_variables)]
fn __action145<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Tok<'input>, usize),
) -> ::std::option::Option<Tok<'input>>
{
    Some(__0)
}

#[allow(unused_variables)]
fn __action146<
    'input,
>(
    text: &'input str,
    __lookbehind: &usize,
    __lookahead: &usize,
) -> ::std::option::Option<Tok<'input>>
{
    None
}

#[allow(unused_variables)]
fn __action147<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Name, usize),
) -> ::std::option::Option<Name>
{
    Some(__0)
}

#[allow(unused_variables)]
fn __action148<
    'input,
>(
    text: &'input str,
    __lookbehind: &usize,
    __lookahead: &usize,
) -> ::std::option::Option<Name>
{
    None
}

#[allow(unused_variables)]
fn __action149<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Name, usize),
    (_, _, _): (usize, Tok<'input>, usize),
) -> Name
{
    (__0)
}

#[allow(unused_variables)]
fn __action150<
    'input,
>(
    text: &'input str,
    (_, v, _): (usize, ::std::vec::Vec<Column>, usize),
    (_, e, _): (usize, Column, usize),
) -> Vec<Column>
{
    {
        let mut v = v;
        v.push(e);
        v
    }
}

#[allow(unused_variables)]
fn __action151<
    'input,
>(
    text: &'input str,
    __lookbehind: &usize,
    __lookahead: &usize,
) -> ::std::vec::Vec<WhereClause>
{
    vec![]
}

#[allow(unused_variables)]
fn __action152<
    'input,
>(
    text: &'input str,
    (_, v, _): (usize, ::std::vec::Vec<WhereClause>, usize),
) -> ::std::vec::Vec<WhereClause>
{
    v
}

#[allow(unused_variables)]
fn __action153<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, WhereClause, usize),
    (_, _, _): (usize, Tok<'input>, usize),
) -> WhereClause
{
    (__0)
}

#[allow(unused_variables)]
fn __action154<
    'input,
>(
    text: &'input str,
    (_, v, _): (usize, ::std::vec::Vec<Name>, usize),
    (_, e, _): (usize, Name, usize),
) -> Vec<Name>
{
    {
        let mut v = v;
        v.push(e);
        v
    }
}

#[allow(unused_variables)]
fn __action155<
    'input,
>(
    text: &'input str,
    (_, v, _): (usize, ::std::vec::Vec<Name>, usize),
    (_, e, _): (usize, Name, usize),
) -> Vec<Name>
{
    {
        let mut v = v;
        v.push(e);
        v
    }
}

#[allow(unused_variables)]
fn __action156<
    'input,
>(
    text: &'input str,
    (_, v, _): (usize, ::std::vec::Vec<SetClause>, usize),
    (_, e, _): (usize, SetClause, usize),
) -> Vec<SetClause>
{
    {
        let mut v = v;
        v.push(e);
        v
    }
}

#[allow(unused_variables)]
fn __action157<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Vec<WhereClause>, usize),
) -> ::std::option::Option<Vec<WhereClause>>
{
    Some(__0)
}

#[allow(unused_variables)]
fn __action158<
    'input,
>(
    text: &'input str,
    __lookbehind: &usize,
    __lookahead: &usize,
) -> ::std::option::Option<Vec<WhereClause>>
{
    None
}

#[allow(unused_variables)]
fn __action159<
    'input,
>(
    text: &'input str,
    (_, _, _): (usize, Tok<'input>, usize),
    (_, __0, _): (usize, Vec<WhereClause>, usize),
) -> Vec<WhereClause>
{
    (__0)
}

#[allow(unused_variables)]
fn __action160<
    'input,
>(
    text: &'input str,
    (_, v, _): (usize, ::std::vec::Vec<Vec<Value>>, usize),
    (_, e, _): (usize, Vec<Value>, usize),
) -> Vec<Vec<Value>>
{
    {
        let mut v = v;
        v.push(e);
        v
    }
}

#[allow(unused_variables)]
fn __action161<
    'input,
>(
    text: &'input str,
    (_, v, _): (usize, ::std::vec::Vec<Field>, usize),
    (_, e, _): (usize, Field, usize),
) -> Vec<Field>
{
    {
        let mut v = v;
        v.push(e);
        v
    }
}

#[allow(unused_variables)]
fn __action162<
    'input,
>(
    text: &'input str,
    __lookbehind: &usize,
    __lookahead: &usize,
) -> ::std::vec::Vec<Stmt>
{
    vec![]
}

#[allow(unused_variables)]
fn __action163<
    'input,
>(
    text: &'input str,
    (_, v, _): (usize, ::std::vec::Vec<Stmt>, usize),
) -> ::std::vec::Vec<Stmt>
{
    v
}

#[allow(unused_variables)]
fn __action164<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Stmt, usize),
) -> ::std::vec::Vec<Stmt>
{
    vec![__0]
}

#[allow(unused_variables)]
fn __action165<
    'input,
>(
    text: &'input str,
    (_, v, _): (usize, ::std::vec::Vec<Stmt>, usize),
    (_, e, _): (usize, Stmt, usize),
) -> ::std::vec::Vec<Stmt>
{
    { let mut v = v; v.push(e); v }
}

#[allow(unused_variables)]
fn __action166<
    'input,
>(
    text: &'input str,
    __lookbehind: &usize,
    __lookahead: &usize,
) -> ::std::vec::Vec<Field>
{
    vec![]
}

#[allow(unused_variables)]
fn __action167<
    'input,
>(
    text: &'input str,
    (_, v, _): (usize, ::std::vec::Vec<Field>, usize),
) -> ::std::vec::Vec<Field>
{
    v
}

#[allow(unused_variables)]
fn __action168<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Field, usize),
    (_, _, _): (usize, Tok<'input>, usize),
) -> Field
{
    (__0)
}

#[allow(unused_variables)]
fn __action169<
    'input,
>(
    text: &'input str,
    __lookbehind: &usize,
    __lookahead: &usize,
) -> ::std::vec::Vec<Vec<Value>>
{
    vec![]
}

#[allow(unused_variables)]
fn __action170<
    'input,
>(
    text: &'input str,
    (_, v, _): (usize, ::std::vec::Vec<Vec<Value>>, usize),
) -> ::std::vec::Vec<Vec<Value>>
{
    v
}

#[allow(unused_variables)]
fn __action171<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Vec<Value>, usize),
    (_, _, _): (usize, Tok<'input>, usize),
) -> Vec<Value>
{
    (__0)
}

#[allow(unused_variables)]
fn __action172<
    'input,
>(
    text: &'input str,
    __lookbehind: &usize,
    __lookahead: &usize,
) -> ::std::vec::Vec<SetClause>
{
    vec![]
}

#[allow(unused_variables)]
fn __action173<
    'input,
>(
    text: &'input str,
    (_, v, _): (usize, ::std::vec::Vec<SetClause>, usize),
) -> ::std::vec::Vec<SetClause>
{
    v
}

#[allow(unused_variables)]
fn __action174<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, SetClause, usize),
    (_, _, _): (usize, Tok<'input>, usize),
) -> SetClause
{
    (__0)
}

#[allow(unused_variables)]
fn __action175<
    'input,
>(
    text: &'input str,
    __lookbehind: &usize,
    __lookahead: &usize,
) -> ::std::vec::Vec<Name>
{
    vec![]
}

#[allow(unused_variables)]
fn __action176<
    'input,
>(
    text: &'input str,
    (_, v, _): (usize, ::std::vec::Vec<Name>, usize),
) -> ::std::vec::Vec<Name>
{
    v
}

#[allow(unused_variables)]
fn __action177<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Name, usize),
    (_, _, _): (usize, Tok<'input>, usize),
) -> Name
{
    (__0)
}

#[allow(unused_variables)]
fn __action178<
    'input,
>(
    text: &'input str,
    __lookbehind: &usize,
    __lookahead: &usize,
) -> ::std::vec::Vec<Name>
{
    vec![]
}

#[allow(unused_variables)]
fn __action179<
    'input,
>(
    text: &'input str,
    (_, v, _): (usize, ::std::vec::Vec<Name>, usize),
) -> ::std::vec::Vec<Name>
{
    v
}

#[allow(unused_variables)]
fn __action180<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Name, usize),
    (_, _, _): (usize, Tok<'input>, usize),
) -> Name
{
    (__0)
}

#[allow(unused_variables)]
fn __action181<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, WhereClause, usize),
) -> ::std::vec::Vec<WhereClause>
{
    vec![__0]
}

#[allow(unused_variables)]
fn __action182<
    'input,
>(
    text: &'input str,
    (_, v, _): (usize, ::std::vec::Vec<WhereClause>, usize),
    (_, e, _): (usize, WhereClause, usize),
) -> ::std::vec::Vec<WhereClause>
{
    { let mut v = v; v.push(e); v }
}

#[allow(unused_variables)]
fn __action183<
    'input,
>(
    text: &'input str,
    __lookbehind: &usize,
    __lookahead: &usize,
) -> ::std::vec::Vec<Column>
{
    vec![]
}

#[allow(unused_variables)]
fn __action184<
    'input,
>(
    text: &'input str,
    (_, v, _): (usize, ::std::vec::Vec<Column>, usize),
) -> ::std::vec::Vec<Column>
{
    v
}

#[allow(unused_variables)]
fn __action185<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Column, usize),
    (_, _, _): (usize, Tok<'input>, usize),
) -> Column
{
    (__0)
}

#[allow(unused_variables)]
fn __action186<
    'input,
>(
    text: &'input str,
    __lookbehind: &usize,
    __lookahead: &usize,
) -> ::std::vec::Vec<Value>
{
    vec![]
}

#[allow(unused_variables)]
fn __action187<
    'input,
>(
    text: &'input str,
    (_, v, _): (usize, ::std::vec::Vec<Value>, usize),
) -> ::std::vec::Vec<Value>
{
    v
}

#[allow(unused_variables)]
fn __action188<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Value, usize),
    (_, _, _): (usize, Tok<'input>, usize),
) -> Value
{
    (__0)
}

#[allow(unused_variables)]
fn __action189<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Value, usize),
) -> ::std::vec::Vec<Value>
{
    vec![__0]
}

#[allow(unused_variables)]
fn __action190<
    'input,
>(
    text: &'input str,
    (_, v, _): (usize, ::std::vec::Vec<Value>, usize),
    (_, e, _): (usize, Value, usize),
) -> ::std::vec::Vec<Value>
{
    { let mut v = v; v.push(e); v }
}

#[allow(unused_variables)]
fn __action191<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Column, usize),
) -> ::std::vec::Vec<Column>
{
    vec![__0]
}

#[allow(unused_variables)]
fn __action192<
    'input,
>(
    text: &'input str,
    (_, v, _): (usize, ::std::vec::Vec<Column>, usize),
    (_, e, _): (usize, Column, usize),
) -> ::std::vec::Vec<Column>
{
    { let mut v = v; v.push(e); v }
}

#[allow(unused_variables)]
fn __action193<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Name, usize),
) -> ::std::vec::Vec<Name>
{
    vec![__0]
}

#[allow(unused_variables)]
fn __action194<
    'input,
>(
    text: &'input str,
    (_, v, _): (usize, ::std::vec::Vec<Name>, usize),
    (_, e, _): (usize, Name, usize),
) -> ::std::vec::Vec<Name>
{
    { let mut v = v; v.push(e); v }
}

#[allow(unused_variables)]
fn __action195<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Name, usize),
) -> ::std::vec::Vec<Name>
{
    vec![__0]
}

#[allow(unused_variables)]
fn __action196<
    'input,
>(
    text: &'input str,
    (_, v, _): (usize, ::std::vec::Vec<Name>, usize),
    (_, e, _): (usize, Name, usize),
) -> ::std::vec::Vec<Name>
{
    { let mut v = v; v.push(e); v }
}

#[allow(unused_variables)]
fn __action197<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, SetClause, usize),
) -> ::std::vec::Vec<SetClause>
{
    vec![__0]
}

#[allow(unused_variables)]
fn __action198<
    'input,
>(
    text: &'input str,
    (_, v, _): (usize, ::std::vec::Vec<SetClause>, usize),
    (_, e, _): (usize, SetClause, usize),
) -> ::std::vec::Vec<SetClause>
{
    { let mut v = v; v.push(e); v }
}

#[allow(unused_variables)]
fn __action199<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Vec<Value>, usize),
) -> ::std::vec::Vec<Vec<Value>>
{
    vec![__0]
}

#[allow(unused_variables)]
fn __action200<
    'input,
>(
    text: &'input str,
    (_, v, _): (usize, ::std::vec::Vec<Vec<Value>>, usize),
    (_, e, _): (usize, Vec<Value>, usize),
) -> ::std::vec::Vec<Vec<Value>>
{
    { let mut v = v; v.push(e); v }
}

#[allow(unused_variables)]
fn __action201<
    'input,
>(
    text: &'input str,
    (_, __0, _): (usize, Field, usize),
) -> ::std::vec::Vec<Field>
{
    vec![__0]
}

#[allow(unused_variables)]
fn __action202<
    'input,
>(
    text: &'input str,
    (_, v, _): (usize, ::std::vec::Vec<Field>, usize),
    (_, e, _): (usize, Field, usize),
) -> ::std::vec::Vec<Field>
{
    { let mut v = v; v.push(e); v }
}

#[allow(unused_variables)]
fn __action203<
    'input,
>(
    text: &'input str,
    __0: (usize, Tok<'input>, usize),
    __1: (usize, &'input str, usize),
) -> Value
{
    let __start0 = __0.0.clone();
    let __end0 = __0.2.clone();
    let __temp0 = __action136(
        text,
        __0,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action65(
        text,
        __temp0,
        __1,
    )
}

#[allow(unused_variables)]
fn __action204<
    'input,
>(
    text: &'input str,
    __0: (usize, &'input str, usize),
) -> Value
{
    let __start0 = __0.0.clone();
    let __end0 = __0.0.clone();
    let __temp0 = __action137(
        text,
        &__start0,
        &__end0,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action65(
        text,
        __temp0,
        __0,
    )
}

#[allow(unused_variables)]
fn __action205<
    'input,
>(
    text: &'input str,
    __0: (usize, Tok<'input>, usize),
    __1: (usize, &'input str, usize),
) -> Value
{
    let __start0 = __0.0.clone();
    let __end0 = __0.2.clone();
    let __temp0 = __action136(
        text,
        __0,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action67(
        text,
        __temp0,
        __1,
    )
}

#[allow(unused_variables)]
fn __action206<
    'input,
>(
    text: &'input str,
    __0: (usize, &'input str, usize),
) -> Value
{
    let __start0 = __0.0.clone();
    let __end0 = __0.0.clone();
    let __temp0 = __action137(
        text,
        &__start0,
        &__end0,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action67(
        text,
        __temp0,
        __0,
    )
}

#[allow(unused_variables)]
fn __action207<
    'input,
>(
    text: &'input str,
    __0: (usize, Column, usize),
    __1: (usize, Tok<'input>, usize),
    __2: (usize, Tok<'input>, usize),
    __3: (usize, Tok<'input>, usize),
) -> WhereClause
{
    let __start0 = __2.0.clone();
    let __end0 = __2.2.clone();
    let __temp0 = __action145(
        text,
        __2,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action46(
        text,
        __0,
        __1,
        __temp0,
        __3,
    )
}

#[allow(unused_variables)]
fn __action208<
    'input,
>(
    text: &'input str,
    __0: (usize, Column, usize),
    __1: (usize, Tok<'input>, usize),
    __2: (usize, Tok<'input>, usize),
) -> WhereClause
{
    let __start0 = __1.2.clone();
    let __end0 = __2.0.clone();
    let __temp0 = __action146(
        text,
        &__start0,
        &__end0,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action46(
        text,
        __0,
        __1,
        __temp0,
        __2,
    )
}

#[allow(unused_variables)]
fn __action209<
    'input,
>(
    text: &'input str,
    __0: (usize, Tok<'input>, usize),
    __1: (usize, Value, usize),
) -> ::std::option::Option<Value>
{
    let __start0 = __0.0.clone();
    let __end0 = __1.2.clone();
    let __temp0 = __action141(
        text,
        __0,
        __1,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action139(
        text,
        __temp0,
    )
}

#[allow(unused_variables)]
fn __action210<
    'input,
>(
    text: &'input str,
    __0: (usize, Name, usize),
    __1: (usize, Type, usize),
    __2: (usize, ::std::option::Option<(Tok<'input>, Tok<'input>)>, usize),
    __3: (usize, Tok<'input>, usize),
    __4: (usize, Value, usize),
) -> Field
{
    let __start0 = __3.0.clone();
    let __end0 = __4.2.clone();
    let __temp0 = __action209(
        text,
        __3,
        __4,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action55(
        text,
        __0,
        __1,
        __2,
        __temp0,
    )
}

#[allow(unused_variables)]
fn __action211<
    'input,
>(
    text: &'input str,
    __0: (usize, Name, usize),
    __1: (usize, Type, usize),
    __2: (usize, ::std::option::Option<(Tok<'input>, Tok<'input>)>, usize),
) -> Field
{
    let __start0 = __2.2.clone();
    let __end0 = __2.2.clone();
    let __temp0 = __action140(
        text,
        &__start0,
        &__end0,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action55(
        text,
        __0,
        __1,
        __2,
        __temp0,
    )
}

#[allow(unused_variables)]
fn __action212<
    'input,
>(
    text: &'input str,
    __0: (usize, Tok<'input>, usize),
    __1: (usize, Tok<'input>, usize),
) -> ::std::option::Option<(Tok<'input>, Tok<'input>)>
{
    let __start0 = __0.0.clone();
    let __end0 = __1.2.clone();
    let __temp0 = __action144(
        text,
        __0,
        __1,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action142(
        text,
        __temp0,
    )
}

#[allow(unused_variables)]
fn __action213<
    'input,
>(
    text: &'input str,
    __0: (usize, Name, usize),
    __1: (usize, Type, usize),
    __2: (usize, Tok<'input>, usize),
    __3: (usize, Tok<'input>, usize),
    __4: (usize, Tok<'input>, usize),
    __5: (usize, Value, usize),
) -> Field
{
    let __start0 = __2.0.clone();
    let __end0 = __3.2.clone();
    let __temp0 = __action212(
        text,
        __2,
        __3,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action210(
        text,
        __0,
        __1,
        __temp0,
        __4,
        __5,
    )
}

#[allow(unused_variables)]
fn __action214<
    'input,
>(
    text: &'input str,
    __0: (usize, Name, usize),
    __1: (usize, Type, usize),
    __2: (usize, Tok<'input>, usize),
    __3: (usize, Value, usize),
) -> Field
{
    let __start0 = __1.2.clone();
    let __end0 = __2.0.clone();
    let __temp0 = __action143(
        text,
        &__start0,
        &__end0,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action210(
        text,
        __0,
        __1,
        __temp0,
        __2,
        __3,
    )
}

#[allow(unused_variables)]
fn __action215<
    'input,
>(
    text: &'input str,
    __0: (usize, Name, usize),
    __1: (usize, Type, usize),
    __2: (usize, Tok<'input>, usize),
    __3: (usize, Tok<'input>, usize),
) -> Field
{
    let __start0 = __2.0.clone();
    let __end0 = __3.2.clone();
    let __temp0 = __action212(
        text,
        __2,
        __3,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action211(
        text,
        __0,
        __1,
        __temp0,
    )
}

#[allow(unused_variables)]
fn __action216<
    'input,
>(
    text: &'input str,
    __0: (usize, Name, usize),
    __1: (usize, Type, usize),
) -> Field
{
    let __start0 = __1.2.clone();
    let __end0 = __1.2.clone();
    let __temp0 = __action143(
        text,
        &__start0,
        &__end0,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action211(
        text,
        __0,
        __1,
        __temp0,
    )
}

#[allow(unused_variables)]
fn __action217<
    'input,
>(
    text: &'input str,
    __0: (usize, Tok<'input>, usize),
    __1: (usize, Vec<WhereClause>, usize),
) -> ::std::option::Option<Vec<WhereClause>>
{
    let __start0 = __0.0.clone();
    let __end0 = __1.2.clone();
    let __temp0 = __action159(
        text,
        __0,
        __1,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action157(
        text,
        __temp0,
    )
}

#[allow(unused_variables)]
fn __action218<
    'input,
>(
    text: &'input str,
    __0: (usize, Tok<'input>, usize),
    __1: (usize, Tok<'input>, usize),
    __2: (usize, Name, usize),
    __3: (usize, Tok<'input>, usize),
    __4: (usize, Vec<WhereClause>, usize),
) -> TableStmt
{
    let __start0 = __3.0.clone();
    let __end0 = __4.2.clone();
    let __temp0 = __action217(
        text,
        __3,
        __4,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action21(
        text,
        __0,
        __1,
        __2,
        __temp0,
    )
}

#[allow(unused_variables)]
fn __action219<
    'input,
>(
    text: &'input str,
    __0: (usize, Tok<'input>, usize),
    __1: (usize, Tok<'input>, usize),
    __2: (usize, Name, usize),
) -> TableStmt
{
    let __start0 = __2.2.clone();
    let __end0 = __2.2.clone();
    let __temp0 = __action158(
        text,
        &__start0,
        &__end0,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action21(
        text,
        __0,
        __1,
        __2,
        __temp0,
    )
}

#[allow(unused_variables)]
fn __action220<
    'input,
>(
    text: &'input str,
    __0: (usize, Tok<'input>, usize),
    __1: (usize, Name, usize),
    __2: (usize, Tok<'input>, usize),
    __3: (usize, Vec<SetClause>, usize),
    __4: (usize, Tok<'input>, usize),
    __5: (usize, Vec<WhereClause>, usize),
) -> TableStmt
{
    let __start0 = __4.0.clone();
    let __end0 = __5.2.clone();
    let __temp0 = __action217(
        text,
        __4,
        __5,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action22(
        text,
        __0,
        __1,
        __2,
        __3,
        __temp0,
    )
}

#[allow(unused_variables)]
fn __action221<
    'input,
>(
    text: &'input str,
    __0: (usize, Tok<'input>, usize),
    __1: (usize, Name, usize),
    __2: (usize, Tok<'input>, usize),
    __3: (usize, Vec<SetClause>, usize),
) -> TableStmt
{
    let __start0 = __3.2.clone();
    let __end0 = __3.2.clone();
    let __temp0 = __action158(
        text,
        &__start0,
        &__end0,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action22(
        text,
        __0,
        __1,
        __2,
        __3,
        __temp0,
    )
}

#[allow(unused_variables)]
fn __action222<
    'input,
>(
    text: &'input str,
    __0: (usize, Tok<'input>, usize),
    __1: (usize, Selector, usize),
    __2: (usize, Tok<'input>, usize),
    __3: (usize, Vec<Name>, usize),
    __4: (usize, Tok<'input>, usize),
    __5: (usize, Vec<WhereClause>, usize),
) -> TableStmt
{
    let __start0 = __4.0.clone();
    let __end0 = __5.2.clone();
    let __temp0 = __action217(
        text,
        __4,
        __5,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action23(
        text,
        __0,
        __1,
        __2,
        __3,
        __temp0,
    )
}

#[allow(unused_variables)]
fn __action223<
    'input,
>(
    text: &'input str,
    __0: (usize, Tok<'input>, usize),
    __1: (usize, Selector, usize),
    __2: (usize, Tok<'input>, usize),
    __3: (usize, Vec<Name>, usize),
) -> TableStmt
{
    let __start0 = __3.2.clone();
    let __end0 = __3.2.clone();
    let __temp0 = __action158(
        text,
        &__start0,
        &__end0,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action23(
        text,
        __0,
        __1,
        __2,
        __3,
        __temp0,
    )
}

#[allow(unused_variables)]
fn __action224<
    'input,
>(
    text: &'input str,
    __0: (usize, Name, usize),
    __1: (usize, Tok<'input>, usize),
) -> ::std::vec::Vec<Name>
{
    let __start0 = __0.0.clone();
    let __end0 = __1.2.clone();
    let __temp0 = __action180(
        text,
        __0,
        __1,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action193(
        text,
        __temp0,
    )
}

#[allow(unused_variables)]
fn __action225<
    'input,
>(
    text: &'input str,
    __0: (usize, ::std::vec::Vec<Name>, usize),
    __1: (usize, Name, usize),
    __2: (usize, Tok<'input>, usize),
) -> ::std::vec::Vec<Name>
{
    let __start0 = __1.0.clone();
    let __end0 = __2.2.clone();
    let __temp0 = __action180(
        text,
        __1,
        __2,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action194(
        text,
        __0,
        __temp0,
    )
}

#[allow(unused_variables)]
fn __action226<
    'input,
>(
    text: &'input str,
    __0: (usize, Name, usize),
) -> Vec<Name>
{
    let __start0 = __0.0.clone();
    let __end0 = __0.0.clone();
    let __temp0 = __action178(
        text,
        &__start0,
        &__end0,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action154(
        text,
        __temp0,
        __0,
    )
}

#[allow(unused_variables)]
fn __action227<
    'input,
>(
    text: &'input str,
    __0: (usize, ::std::vec::Vec<Name>, usize),
    __1: (usize, Name, usize),
) -> Vec<Name>
{
    let __start0 = __0.0.clone();
    let __end0 = __0.2.clone();
    let __temp0 = __action179(
        text,
        __0,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action154(
        text,
        __temp0,
        __1,
    )
}

#[allow(unused_variables)]
fn __action228<
    'input,
>(
    text: &'input str,
    __0: (usize, Column, usize),
    __1: (usize, Tok<'input>, usize),
) -> ::std::vec::Vec<Column>
{
    let __start0 = __0.0.clone();
    let __end0 = __1.2.clone();
    let __temp0 = __action185(
        text,
        __0,
        __1,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action191(
        text,
        __temp0,
    )
}

#[allow(unused_variables)]
fn __action229<
    'input,
>(
    text: &'input str,
    __0: (usize, ::std::vec::Vec<Column>, usize),
    __1: (usize, Column, usize),
    __2: (usize, Tok<'input>, usize),
) -> ::std::vec::Vec<Column>
{
    let __start0 = __1.0.clone();
    let __end0 = __2.2.clone();
    let __temp0 = __action185(
        text,
        __1,
        __2,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action192(
        text,
        __0,
        __temp0,
    )
}

#[allow(unused_variables)]
fn __action230<
    'input,
>(
    text: &'input str,
    __0: (usize, Column, usize),
) -> Vec<Column>
{
    let __start0 = __0.0.clone();
    let __end0 = __0.0.clone();
    let __temp0 = __action183(
        text,
        &__start0,
        &__end0,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action150(
        text,
        __temp0,
        __0,
    )
}

#[allow(unused_variables)]
fn __action231<
    'input,
>(
    text: &'input str,
    __0: (usize, ::std::vec::Vec<Column>, usize),
    __1: (usize, Column, usize),
) -> Vec<Column>
{
    let __start0 = __0.0.clone();
    let __end0 = __0.2.clone();
    let __temp0 = __action184(
        text,
        __0,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action150(
        text,
        __temp0,
        __1,
    )
}

#[allow(unused_variables)]
fn __action232<
    'input,
>(
    text: &'input str,
    __0: (usize, Field, usize),
    __1: (usize, Tok<'input>, usize),
) -> ::std::vec::Vec<Field>
{
    let __start0 = __0.0.clone();
    let __end0 = __1.2.clone();
    let __temp0 = __action168(
        text,
        __0,
        __1,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action201(
        text,
        __temp0,
    )
}

#[allow(unused_variables)]
fn __action233<
    'input,
>(
    text: &'input str,
    __0: (usize, ::std::vec::Vec<Field>, usize),
    __1: (usize, Field, usize),
    __2: (usize, Tok<'input>, usize),
) -> ::std::vec::Vec<Field>
{
    let __start0 = __1.0.clone();
    let __end0 = __2.2.clone();
    let __temp0 = __action168(
        text,
        __1,
        __2,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action202(
        text,
        __0,
        __temp0,
    )
}

#[allow(unused_variables)]
fn __action234<
    'input,
>(
    text: &'input str,
    __0: (usize, Field, usize),
) -> Vec<Field>
{
    let __start0 = __0.0.clone();
    let __end0 = __0.0.clone();
    let __temp0 = __action166(
        text,
        &__start0,
        &__end0,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action161(
        text,
        __temp0,
        __0,
    )
}

#[allow(unused_variables)]
fn __action235<
    'input,
>(
    text: &'input str,
    __0: (usize, ::std::vec::Vec<Field>, usize),
    __1: (usize, Field, usize),
) -> Vec<Field>
{
    let __start0 = __0.0.clone();
    let __end0 = __0.2.clone();
    let __temp0 = __action167(
        text,
        __0,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action161(
        text,
        __temp0,
        __1,
    )
}

#[allow(unused_variables)]
fn __action236<
    'input,
>(
    text: &'input str,
    __0: (usize, SetClause, usize),
    __1: (usize, Tok<'input>, usize),
) -> ::std::vec::Vec<SetClause>
{
    let __start0 = __0.0.clone();
    let __end0 = __1.2.clone();
    let __temp0 = __action174(
        text,
        __0,
        __1,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action197(
        text,
        __temp0,
    )
}

#[allow(unused_variables)]
fn __action237<
    'input,
>(
    text: &'input str,
    __0: (usize, ::std::vec::Vec<SetClause>, usize),
    __1: (usize, SetClause, usize),
    __2: (usize, Tok<'input>, usize),
) -> ::std::vec::Vec<SetClause>
{
    let __start0 = __1.0.clone();
    let __end0 = __2.2.clone();
    let __temp0 = __action174(
        text,
        __1,
        __2,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action198(
        text,
        __0,
        __temp0,
    )
}

#[allow(unused_variables)]
fn __action238<
    'input,
>(
    text: &'input str,
    __0: (usize, SetClause, usize),
) -> Vec<SetClause>
{
    let __start0 = __0.0.clone();
    let __end0 = __0.0.clone();
    let __temp0 = __action172(
        text,
        &__start0,
        &__end0,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action156(
        text,
        __temp0,
        __0,
    )
}

#[allow(unused_variables)]
fn __action239<
    'input,
>(
    text: &'input str,
    __0: (usize, ::std::vec::Vec<SetClause>, usize),
    __1: (usize, SetClause, usize),
) -> Vec<SetClause>
{
    let __start0 = __0.0.clone();
    let __end0 = __0.2.clone();
    let __temp0 = __action173(
        text,
        __0,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action156(
        text,
        __temp0,
        __1,
    )
}

#[allow(unused_variables)]
fn __action240<
    'input,
>(
    text: &'input str,
    __0: (usize, Name, usize),
    __1: (usize, Tok<'input>, usize),
) -> ::std::vec::Vec<Name>
{
    let __start0 = __0.0.clone();
    let __end0 = __1.2.clone();
    let __temp0 = __action177(
        text,
        __0,
        __1,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action195(
        text,
        __temp0,
    )
}

#[allow(unused_variables)]
fn __action241<
    'input,
>(
    text: &'input str,
    __0: (usize, ::std::vec::Vec<Name>, usize),
    __1: (usize, Name, usize),
    __2: (usize, Tok<'input>, usize),
) -> ::std::vec::Vec<Name>
{
    let __start0 = __1.0.clone();
    let __end0 = __2.2.clone();
    let __temp0 = __action177(
        text,
        __1,
        __2,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action196(
        text,
        __0,
        __temp0,
    )
}

#[allow(unused_variables)]
fn __action242<
    'input,
>(
    text: &'input str,
    __0: (usize, Name, usize),
) -> Vec<Name>
{
    let __start0 = __0.0.clone();
    let __end0 = __0.0.clone();
    let __temp0 = __action175(
        text,
        &__start0,
        &__end0,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action155(
        text,
        __temp0,
        __0,
    )
}

#[allow(unused_variables)]
fn __action243<
    'input,
>(
    text: &'input str,
    __0: (usize, ::std::vec::Vec<Name>, usize),
    __1: (usize, Name, usize),
) -> Vec<Name>
{
    let __start0 = __0.0.clone();
    let __end0 = __0.2.clone();
    let __temp0 = __action176(
        text,
        __0,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action155(
        text,
        __temp0,
        __1,
    )
}

#[allow(unused_variables)]
fn __action244<
    'input,
>(
    text: &'input str,
    __0: (usize, Name, usize),
    __1: (usize, Tok<'input>, usize),
) -> ::std::option::Option<Name>
{
    let __start0 = __0.0.clone();
    let __end0 = __1.2.clone();
    let __temp0 = __action149(
        text,
        __0,
        __1,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action147(
        text,
        __temp0,
    )
}

#[allow(unused_variables)]
fn __action245<
    'input,
>(
    text: &'input str,
    __0: (usize, Name, usize),
    __1: (usize, Tok<'input>, usize),
    __2: (usize, Name, usize),
) -> Column
{
    let __start0 = __0.0.clone();
    let __end0 = __1.2.clone();
    let __temp0 = __action244(
        text,
        __0,
        __1,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action44(
        text,
        __temp0,
        __2,
    )
}

#[allow(unused_variables)]
fn __action246<
    'input,
>(
    text: &'input str,
    __0: (usize, Name, usize),
) -> Column
{
    let __start0 = __0.0.clone();
    let __end0 = __0.0.clone();
    let __temp0 = __action148(
        text,
        &__start0,
        &__end0,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action44(
        text,
        __temp0,
        __0,
    )
}

#[allow(unused_variables)]
fn __action247<
    'input,
>(
    text: &'input str,
    __0: (usize, Value, usize),
    __1: (usize, Tok<'input>, usize),
) -> ::std::vec::Vec<Value>
{
    let __start0 = __0.0.clone();
    let __end0 = __1.2.clone();
    let __temp0 = __action188(
        text,
        __0,
        __1,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action189(
        text,
        __temp0,
    )
}

#[allow(unused_variables)]
fn __action248<
    'input,
>(
    text: &'input str,
    __0: (usize, ::std::vec::Vec<Value>, usize),
    __1: (usize, Value, usize),
    __2: (usize, Tok<'input>, usize),
) -> ::std::vec::Vec<Value>
{
    let __start0 = __1.0.clone();
    let __end0 = __2.2.clone();
    let __temp0 = __action188(
        text,
        __1,
        __2,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action190(
        text,
        __0,
        __temp0,
    )
}

#[allow(unused_variables)]
fn __action249<
    'input,
>(
    text: &'input str,
    __0: (usize, Value, usize),
) -> Vec<Value>
{
    let __start0 = __0.0.clone();
    let __end0 = __0.0.clone();
    let __temp0 = __action186(
        text,
        &__start0,
        &__end0,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action138(
        text,
        __temp0,
        __0,
    )
}

#[allow(unused_variables)]
fn __action250<
    'input,
>(
    text: &'input str,
    __0: (usize, ::std::vec::Vec<Value>, usize),
    __1: (usize, Value, usize),
) -> Vec<Value>
{
    let __start0 = __0.0.clone();
    let __end0 = __0.2.clone();
    let __temp0 = __action187(
        text,
        __0,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action138(
        text,
        __temp0,
        __1,
    )
}

#[allow(unused_variables)]
fn __action251<
    'input,
>(
    text: &'input str,
    __0: (usize, Vec<Value>, usize),
    __1: (usize, Tok<'input>, usize),
) -> ::std::vec::Vec<Vec<Value>>
{
    let __start0 = __0.0.clone();
    let __end0 = __1.2.clone();
    let __temp0 = __action171(
        text,
        __0,
        __1,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action199(
        text,
        __temp0,
    )
}

#[allow(unused_variables)]
fn __action252<
    'input,
>(
    text: &'input str,
    __0: (usize, ::std::vec::Vec<Vec<Value>>, usize),
    __1: (usize, Vec<Value>, usize),
    __2: (usize, Tok<'input>, usize),
) -> ::std::vec::Vec<Vec<Value>>
{
    let __start0 = __1.0.clone();
    let __end0 = __2.2.clone();
    let __temp0 = __action171(
        text,
        __1,
        __2,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action200(
        text,
        __0,
        __temp0,
    )
}

#[allow(unused_variables)]
fn __action253<
    'input,
>(
    text: &'input str,
    __0: (usize, Vec<Value>, usize),
) -> Vec<Vec<Value>>
{
    let __start0 = __0.0.clone();
    let __end0 = __0.0.clone();
    let __temp0 = __action169(
        text,
        &__start0,
        &__end0,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action160(
        text,
        __temp0,
        __0,
    )
}

#[allow(unused_variables)]
fn __action254<
    'input,
>(
    text: &'input str,
    __0: (usize, ::std::vec::Vec<Vec<Value>>, usize),
    __1: (usize, Vec<Value>, usize),
) -> Vec<Vec<Value>>
{
    let __start0 = __0.0.clone();
    let __end0 = __0.2.clone();
    let __temp0 = __action170(
        text,
        __0,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action160(
        text,
        __temp0,
        __1,
    )
}

#[allow(unused_variables)]
fn __action255<
    'input,
>(
    text: &'input str,
    __0: (usize, WhereClause, usize),
    __1: (usize, Tok<'input>, usize),
) -> ::std::vec::Vec<WhereClause>
{
    let __start0 = __0.0.clone();
    let __end0 = __1.2.clone();
    let __temp0 = __action153(
        text,
        __0,
        __1,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action181(
        text,
        __temp0,
    )
}

#[allow(unused_variables)]
fn __action256<
    'input,
>(
    text: &'input str,
    __0: (usize, ::std::vec::Vec<WhereClause>, usize),
    __1: (usize, WhereClause, usize),
    __2: (usize, Tok<'input>, usize),
) -> ::std::vec::Vec<WhereClause>
{
    let __start0 = __1.0.clone();
    let __end0 = __2.2.clone();
    let __temp0 = __action153(
        text,
        __1,
        __2,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action182(
        text,
        __0,
        __temp0,
    )
}

#[allow(unused_variables)]
fn __action257<
    'input,
>(
    text: &'input str,
    __0: (usize, WhereClause, usize),
) -> Vec<WhereClause>
{
    let __start0 = __0.0.clone();
    let __end0 = __0.0.clone();
    let __temp0 = __action151(
        text,
        &__start0,
        &__end0,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action41(
        text,
        __temp0,
        __0,
    )
}

#[allow(unused_variables)]
fn __action258<
    'input,
>(
    text: &'input str,
    __0: (usize, ::std::vec::Vec<WhereClause>, usize),
    __1: (usize, WhereClause, usize),
) -> Vec<WhereClause>
{
    let __start0 = __0.0.clone();
    let __end0 = __0.2.clone();
    let __temp0 = __action152(
        text,
        __0,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action41(
        text,
        __temp0,
        __1,
    )
}

#[allow(unused_variables)]
fn __action259<
    'input,
>(
    text: &'input str,
    __lookbehind: &usize,
    __lookahead: &usize,
) -> Sql
{
    let __start0 = __lookbehind.clone();
    let __end0 = __lookahead.clone();
    let __temp0 = __action162(
        text,
        &__start0,
        &__end0,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action1(
        text,
        __temp0,
    )
}

#[allow(unused_variables)]
fn __action260<
    'input,
>(
    text: &'input str,
    __0: (usize, ::std::vec::Vec<Stmt>, usize),
) -> Sql
{
    let __start0 = __0.0.clone();
    let __end0 = __0.2.clone();
    let __temp0 = __action163(
        text,
        __0,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action1(
        text,
        __temp0,
    )
}

pub trait __ToTriple<'input, > {
    fn to_triple(value: Self) -> Result<(usize,Tok<'input>,usize), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>>;
}

impl<'input, > __ToTriple<'input, > for (usize, Tok<'input>, usize) {
    fn to_triple(value: Self) -> Result<(usize,Tok<'input>,usize), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>> {
        Ok(value)
    }
}
impl<'input, > __ToTriple<'input, > for Result<(usize, Tok<'input>, usize), tok::Error> {
    fn to_triple(value: Self) -> Result<(usize,Tok<'input>,usize), __lalrpop_util::ParseError<usize, Tok<'input>, tok::Error>> {
        match value {
            Ok(v) => Ok(v),
            Err(error) => Err(__lalrpop_util::ParseError::User { error }),
        }
    }
}
